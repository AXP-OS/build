From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jakub Pawlowski <jpawlowski@google.com>
Date: Wed, 28 Sep 2016 09:02:39 -0700
Subject: [PATCH] Separate the definition of BTM layer types from control
 blocks

Right now, data types, control blocks, and functions used in the BTM
layer are defined in the same header files. This means that if someone
wants to write a test that uses those data types, they must also define
all control blocks, or compile the whole module.

This patch separates the data types from other definitions. Thanks to
it, we will be able to write unit tests, once other dependencies get
separated.

Change-Id: Ibc089e273cc37642fbb8672964b266c20f8d825d
---
 stack/btm/btm_ble_int.h           |  308 +----
 stack/btm/btm_ble_int_types.h     |  339 +++++
 stack/btm/btm_int.h               |  870 +------------
 stack/btm/btm_int_types.h         |  907 ++++++++++++++
 stack/include/btm_api.h           | 1879 +---------------------------
 stack/include/btm_api_types.h     | 1900 +++++++++++++++++++++++++++++
 stack/include/btm_ble_api.h       |  859 +------------
 stack/include/btm_ble_api_types.h |  890 ++++++++++++++
 stack/include/smp_api.h           |  269 +---
 stack/include/smp_api_types.h     |  300 +++++
 10 files changed, 4341 insertions(+), 4180 deletions(-)
 create mode 100644 stack/btm/btm_ble_int_types.h
 create mode 100644 stack/btm/btm_int_types.h
 create mode 100644 stack/include/btm_api_types.h
 create mode 100644 stack/include/btm_ble_api_types.h
 create mode 100644 stack/include/smp_api_types.h

diff --git a/stack/btm/btm_ble_int.h b/stack/btm/btm_ble_int.h
index 166cb5e0a..437503e12 100644
--- a/stack/btm/btm_ble_int.h
+++ b/stack/btm/btm_ble_int.h
@@ -36,313 +36,7 @@
 #include "smp_api.h"
 #endif
 
-
-/* scanning enable status */
-#define BTM_BLE_SCAN_ENABLE      0x01
-#define BTM_BLE_SCAN_DISABLE     0x00
-
-/* advertising enable status */
-#define BTM_BLE_ADV_ENABLE     0x01
-#define BTM_BLE_ADV_DISABLE    0x00
-
-/* use the high 4 bits unused by inquiry mode */
-#define BTM_BLE_SELECT_SCAN     0x20
-#define BTM_BLE_NAME_REQUEST    0x40
-#define BTM_BLE_OBSERVE         0x80
-
-#define BTM_BLE_MAX_WL_ENTRY        1
-#define BTM_BLE_AD_DATA_LEN         31
-
-#define BTM_BLE_ENC_MASK    0x03
-
-#define BTM_BLE_DUPLICATE_ENABLE        1
-#define BTM_BLE_DUPLICATE_DISABLE       0
-
-#define BTM_BLE_GAP_DISC_SCAN_INT      18         /* Interval(scan_int) = 11.25 ms= 0x0010 * 0.625 ms */
-#define BTM_BLE_GAP_DISC_SCAN_WIN      18         /* scan_window = 11.25 ms= 0x0010 * 0.625 ms */
-#define BTM_BLE_GAP_ADV_INT            512        /* Tgap(gen_disc) = 1.28 s= 512 * 0.625 ms */
-#define BTM_BLE_GAP_LIM_TIMEOUT_MS     (180 * 1000) /* Tgap(lim_timeout) = 180s max */
-#define BTM_BLE_LOW_LATENCY_SCAN_INT   8000       /* Interval(scan_int) = 5s= 8000 * 0.625 ms */
-#define BTM_BLE_LOW_LATENCY_SCAN_WIN   8000       /* scan_window = 5s= 8000 * 0.625 ms */
-
-
-#define BTM_BLE_GAP_ADV_FAST_INT_1         48         /* TGAP(adv_fast_interval1) = 30(used) ~ 60 ms  = 48 *0.625 */
-#define BTM_BLE_GAP_ADV_FAST_INT_2         160         /* TGAP(adv_fast_interval2) = 100(used) ~ 150 ms = 160 * 0.625 ms */
-#define BTM_BLE_GAP_ADV_SLOW_INT           2048         /* Tgap(adv_slow_interval) = 1.28 s= 512 * 0.625 ms */
-#define BTM_BLE_GAP_ADV_DIR_MAX_INT        800         /* Tgap(dir_conn_adv_int_max) = 500 ms = 800 * 0.625 ms */
-#define BTM_BLE_GAP_ADV_DIR_MIN_INT        400         /* Tgap(dir_conn_adv_int_min) = 250 ms = 400 * 0.625 ms */
-
-#define BTM_BLE_GAP_FAST_ADV_TIMEOUT_MS    (30 * 1000)
-
-#define BTM_BLE_SEC_REQ_ACT_NONE           0
-#define BTM_BLE_SEC_REQ_ACT_ENCRYPT        1 /* encrypt the link using current key or key refresh */
-#define BTM_BLE_SEC_REQ_ACT_PAIR           2
-#define BTM_BLE_SEC_REQ_ACT_DISCARD        3 /* discard the sec request while encryption is started but not completed */
-typedef UINT8   tBTM_BLE_SEC_REQ_ACT;
-
-#define BLE_STATIC_PRIVATE_MSB_MASK          0x3f
-#define BLE_RESOLVE_ADDR_MSB                 0x40   /*  most significant bit, bit7, bit6 is 01 to be resolvable random */
-#define BLE_RESOLVE_ADDR_MASK                0xc0   /* bit 6, and bit7 */
-#define BTM_BLE_IS_RESOLVE_BDA(x)           ((x[0] & BLE_RESOLVE_ADDR_MASK) == BLE_RESOLVE_ADDR_MSB)
-
-#define BLE_PUBLIC_ADDR_MSB_MASK            0xC0
-#define BLE_PUBLIC_ADDR_MSB                 0x80   /*  most significant bit, bit7, bit6 is 10 to be public address*/
-#define BTM_IS_PUBLIC_BDA(x)               ((x[0]  & BLE_PUBLIC_ADDR_MSB) == BLE_PUBLIC_ADDR_MSB_MASK)
-
-/* LE scan activity bit mask, continue with LE inquiry bits */
-#define BTM_LE_SELECT_CONN_ACTIVE      0x40     /* selection connection is in progress */
-#define BTM_LE_OBSERVE_ACTIVE          0x80     /* observe is in progress */
-
-/* BLE scan activity mask checking */
-#define BTM_BLE_IS_SCAN_ACTIVE(x)   ((x) & BTM_BLE_SCAN_ACTIVE_MASK)
-#define BTM_BLE_IS_INQ_ACTIVE(x)   ((x) & BTM_BLE_INQUIRY_MASK)
-#define BTM_BLE_IS_OBS_ACTIVE(x)   ((x) & BTM_LE_OBSERVE_ACTIVE)
-#define BTM_BLE_IS_SEL_CONN_ACTIVE(x)   ((x) & BTM_LE_SELECT_CONN_ACTIVE)
-
-/* BLE ADDR type ID bit */
-#define BLE_ADDR_TYPE_ID_BIT 0x02
-
-#define BTM_VSC_CHIP_CAPABILITY_L_VERSION 55
-#define BTM_VSC_CHIP_CAPABILITY_M_VERSION 95
-
-typedef struct
-{
-    UINT16              data_mask;
-    UINT8               *p_flags;
-    UINT8               ad_data[BTM_BLE_AD_DATA_LEN];
-    UINT8               *p_pad;
-}tBTM_BLE_LOCAL_ADV_DATA;
-
-typedef struct
-{
-    UINT32          inq_count;          /* Used for determining if a response has already been      */
-                                        /* received for the current inquiry operation. (We do not   */
-                                        /* want to flood the caller with multiple responses from    */
-                                        /* the same device.                                         */
-    BOOLEAN         scan_rsp;
-    tBLE_BD_ADDR    le_bda;
-} tINQ_LE_BDADDR;
-
-#define BTM_BLE_ADV_DATA_LEN_MAX        31
-#define BTM_BLE_CACHE_ADV_DATA_MAX      62
-
-#define BTM_BLE_ISVALID_PARAM(x, min, max)  (((x) >= (min) && (x) <= (max)) || ((x) == BTM_BLE_CONN_PARAM_UNDEF))
-
-/* 15 minutes minimum for random address refreshing */
-#define BTM_BLE_PRIVATE_ADDR_INT_MS     (15 * 60 * 1000)
-
-typedef struct
-{
-    UINT16 discoverable_mode;
-    UINT16 connectable_mode;
-    UINT32 scan_window;
-    UINT32 scan_interval;
-    UINT8 scan_type; /* current scan type: active or passive */
-    UINT8 scan_duplicate_filter; /* duplicate filter enabled for scan */
-    UINT16 adv_interval_min;
-    UINT16 adv_interval_max;
-    tBTM_BLE_AFP afp; /* advertising filter policy */
-    tBTM_BLE_SFP sfp; /* scanning filter policy */
-
-    tBLE_ADDR_TYPE adv_addr_type;
-    UINT8 evt_type;
-    UINT8 adv_mode;
-    tBLE_BD_ADDR direct_bda;
-    tBTM_BLE_EVT directed_conn;
-    BOOLEAN fast_adv_on;
-    alarm_t *fast_adv_timer;
-
-    UINT8 adv_len;
-    UINT8 adv_data_cache[BTM_BLE_CACHE_ADV_DATA_MAX];
-
-    /* inquiry BD addr database */
-    UINT8 num_bd_entries;
-    UINT8 max_bd_entries;
-    tBTM_BLE_LOCAL_ADV_DATA adv_data;
-    tBTM_BLE_ADV_CHNL_MAP adv_chnl_map;
-
-    alarm_t *inquiry_timer;
-    BOOLEAN scan_rsp;
-    UINT8 state; /* Current state that the inquiry process is in */
-    INT8 tx_power;
-} tBTM_BLE_INQ_CB;
-
-
-/* random address resolving complete callback */
-typedef void (tBTM_BLE_RESOLVE_CBACK) (void * match_rec, void *p);
-
-typedef void (tBTM_BLE_ADDR_CBACK) (BD_ADDR_PTR static_random, void *p);
-
-/* random address management control block */
-typedef struct
-{
-    tBLE_ADDR_TYPE              own_addr_type;         /* local device LE address type */
-    BD_ADDR                     private_addr;
-    BD_ADDR                     random_bda;
-    BOOLEAN                     busy;
-    tBTM_BLE_ADDR_CBACK         *p_generate_cback;
-    void                        *p;
-    alarm_t                     *refresh_raddr_timer;
-} tBTM_LE_RANDOM_CB;
-
-#define BTM_BLE_MAX_BG_CONN_DEV_NUM    10
-
-typedef struct
-{
-    UINT16              min_conn_int;
-    UINT16              max_conn_int;
-    UINT16              slave_latency;
-    UINT16              supervision_tout;
-
-}tBTM_LE_CONN_PRAMS;
-
-
-typedef struct
-{
-    BD_ADDR     bd_addr;
-    UINT8       attr;
-    BOOLEAN     is_connected;
-    BOOLEAN     in_use;
-}tBTM_LE_BG_CONN_DEV;
-
-  /* white list using state as a bit mask */
-#define BTM_BLE_WL_IDLE         0
-#define BTM_BLE_WL_INIT         1
-#define BTM_BLE_WL_SCAN         2
-#define BTM_BLE_WL_ADV          4
-typedef UINT8 tBTM_BLE_WL_STATE;
-
-/* resolving list using state as a bit mask */
-#define BTM_BLE_RL_IDLE         0
-#define BTM_BLE_RL_INIT         1
-#define BTM_BLE_RL_SCAN         2
-#define BTM_BLE_RL_ADV          4
-typedef UINT8 tBTM_BLE_RL_STATE;
-
-/* BLE connection state */
-#define BLE_CONN_IDLE    0
-#define BLE_DIR_CONN     1
-#define BLE_BG_CONN      2
-#define BLE_CONN_CANCEL  3
-typedef UINT8 tBTM_BLE_CONN_ST;
-
-typedef struct
-{
-    void    *p_param;
-}tBTM_BLE_CONN_REQ;
-
-/* LE state request */
-#define BTM_BLE_STATE_INVALID               0
-#define BTM_BLE_STATE_CONN_ADV              1
-#define BTM_BLE_STATE_INIT                  2
-#define BTM_BLE_STATE_MASTER                3
-#define BTM_BLE_STATE_SLAVE                 4
-#define BTM_BLE_STATE_LO_DUTY_DIR_ADV       5
-#define BTM_BLE_STATE_HI_DUTY_DIR_ADV       6
-#define BTM_BLE_STATE_NON_CONN_ADV          7
-#define BTM_BLE_STATE_PASSIVE_SCAN          8
-#define BTM_BLE_STATE_ACTIVE_SCAN           9
-#define BTM_BLE_STATE_SCAN_ADV              10
-#define BTM_BLE_STATE_MAX                   11
-typedef UINT8 tBTM_BLE_STATE;
-
-#define BTM_BLE_STATE_CONN_ADV_BIT          0x0001
-#define BTM_BLE_STATE_INIT_BIT              0x0002
-#define BTM_BLE_STATE_MASTER_BIT            0x0004
-#define BTM_BLE_STATE_SLAVE_BIT             0x0008
-#define BTM_BLE_STATE_LO_DUTY_DIR_ADV_BIT   0x0010
-#define BTM_BLE_STATE_HI_DUTY_DIR_ADV_BIT   0x0020
-#define BTM_BLE_STATE_NON_CONN_ADV_BIT      0x0040
-#define BTM_BLE_STATE_PASSIVE_SCAN_BIT      0x0080
-#define BTM_BLE_STATE_ACTIVE_SCAN_BIT       0x0100
-#define BTM_BLE_STATE_SCAN_ADV_BIT          0x0200
-typedef UINT16 tBTM_BLE_STATE_MASK;
-
-#define BTM_BLE_STATE_ALL_MASK              0x03ff
-#define BTM_BLE_STATE_ALL_ADV_MASK          (BTM_BLE_STATE_CONN_ADV_BIT|BTM_BLE_STATE_LO_DUTY_DIR_ADV_BIT|BTM_BLE_STATE_HI_DUTY_DIR_ADV_BIT|BTM_BLE_STATE_SCAN_ADV_BIT)
-#define BTM_BLE_STATE_ALL_SCAN_MASK         (BTM_BLE_STATE_PASSIVE_SCAN_BIT|BTM_BLE_STATE_ACTIVE_SCAN_BIT)
-#define BTM_BLE_STATE_ALL_CONN_MASK         (BTM_BLE_STATE_MASTER_BIT|BTM_BLE_STATE_SLAVE_BIT)
-
-#ifndef BTM_LE_RESOLVING_LIST_MAX
-#define BTM_LE_RESOLVING_LIST_MAX     0x20
-#endif
-
-typedef struct
-{
-    BD_ADDR         *resolve_q_random_pseudo;
-    UINT8           *resolve_q_action;
-    UINT8           q_next;
-    UINT8           q_pending;
-} tBTM_BLE_RESOLVE_Q;
-
-typedef struct
-{
-    BOOLEAN     in_use;
-    BOOLEAN     to_add;
-    BD_ADDR     bd_addr;
-    UINT8       attr;
-}tBTM_BLE_WL_OP;
-
-/* BLE privacy mode */
-#define BTM_PRIVACY_NONE    0              /* BLE no privacy */
-#define BTM_PRIVACY_1_1     1              /* BLE privacy 1.1, do not support privacy 1.0 */
-#define BTM_PRIVACY_1_2     2              /* BLE privacy 1.2 */
-#define BTM_PRIVACY_MIXED   3              /* BLE privacy mixed mode, broadcom propietary mode */
-typedef UINT8 tBTM_PRIVACY_MODE;
-
-/* data length change event callback */
-typedef void (tBTM_DATA_LENGTH_CHANGE_CBACK) (UINT16 max_tx_length, UINT16 max_rx_length);
-
-/* Define BLE Device Management control structure
-*/
-typedef struct
-{
-    UINT8 scan_activity;         /* LE scan activity mask */
-
-    /*****************************************************
-    **      BLE Inquiry
-    *****************************************************/
-    tBTM_BLE_INQ_CB inq_var;
-
-    /* observer callback and timer */
-    tBTM_INQ_RESULTS_CB *p_obs_results_cb;
-    tBTM_CMPL_CB *p_obs_cmpl_cb;
-    alarm_t *observer_timer;
-
-    /* background connection procedure cb value */
-    tBTM_BLE_CONN_TYPE bg_conn_type;
-    UINT32 scan_int;
-    UINT32 scan_win;
-    tBTM_BLE_SEL_CBACK *p_select_cback;
-
-    /* white list information */
-    UINT8 white_list_avail_size;
-    tBTM_BLE_WL_STATE wl_state;
-
-    fixed_queue_t *conn_pending_q;
-    tBTM_BLE_CONN_ST conn_state;
-
-    /* random address management control block */
-    tBTM_LE_RANDOM_CB addr_mgnt_cb;
-
-    BOOLEAN enabled;
-
-#if BLE_PRIVACY_SPT == TRUE
-    BOOLEAN mixed_mode; /* privacy 1.2 mixed mode is on or not */
-    tBTM_PRIVACY_MODE privacy_mode; /* privacy mode */
-    UINT8 resolving_list_avail_size; /* resolving list available size */
-    tBTM_BLE_RESOLVE_Q resolving_list_pend_q; /* Resolving list queue */
-    tBTM_BLE_RL_STATE suspended_rl_state; /* Suspended resolving list state */
-    UINT8 *irk_list_mask; /* IRK list availability mask, up to max entry bits */
-    tBTM_BLE_RL_STATE rl_state; /* Resolving list state */
-#endif
-
-    tBTM_BLE_WL_OP wl_op_q[BTM_BLE_MAX_BG_CONN_DEV_NUM];
-
-    /* current BLE link state */
-    tBTM_BLE_STATE_MASK cur_states; /* bit mask of tBTM_BLE_STATE */
-    UINT8 link_count[2]; /* total link count master and slave*/
-} tBTM_BLE_CB;
+#include "btm_ble_int_types.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/stack/btm/btm_ble_int_types.h b/stack/btm/btm_ble_int_types.h
new file mode 100644
index 000000000..dd633ef61
--- /dev/null
+++ b/stack/btm/btm_ble_int_types.h
@@ -0,0 +1,339 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef BTM_BLE_INT_TYPES_H
+#define BTM_BLE_INT_TYPES_H
+
+#include "osi/include/alarm.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* scanning enable status */
+#define BTM_BLE_SCAN_ENABLE      0x01
+#define BTM_BLE_SCAN_DISABLE     0x00
+
+/* advertising enable status */
+#define BTM_BLE_ADV_ENABLE     0x01
+#define BTM_BLE_ADV_DISABLE    0x00
+
+/* use the high 4 bits unused by inquiry mode */
+#define BTM_BLE_SELECT_SCAN     0x20
+#define BTM_BLE_NAME_REQUEST    0x40
+#define BTM_BLE_OBSERVE         0x80
+
+#define BTM_BLE_MAX_WL_ENTRY        1
+#define BTM_BLE_AD_DATA_LEN         31
+
+#define BTM_BLE_ENC_MASK    0x03
+
+#define BTM_BLE_DUPLICATE_ENABLE        1
+#define BTM_BLE_DUPLICATE_DISABLE       0
+
+#define BTM_BLE_GAP_DISC_SCAN_INT      18         /* Interval(scan_int) = 11.25 ms= 0x0010 * 0.625 ms */
+#define BTM_BLE_GAP_DISC_SCAN_WIN      18         /* scan_window = 11.25 ms= 0x0010 * 0.625 ms */
+#define BTM_BLE_GAP_ADV_INT            512        /* Tgap(gen_disc) = 1.28 s= 512 * 0.625 ms */
+#define BTM_BLE_GAP_LIM_TIMEOUT_MS     (180 * 1000) /* Tgap(lim_timeout) = 180s max */
+#define BTM_BLE_LOW_LATENCY_SCAN_INT   8000       /* Interval(scan_int) = 5s= 8000 * 0.625 ms */
+#define BTM_BLE_LOW_LATENCY_SCAN_WIN   8000       /* scan_window = 5s= 8000 * 0.625 ms */
+
+
+#define BTM_BLE_GAP_ADV_FAST_INT_1         48         /* TGAP(adv_fast_interval1) = 30(used) ~ 60 ms  = 48 *0.625 */
+#define BTM_BLE_GAP_ADV_FAST_INT_2         160         /* TGAP(adv_fast_interval2) = 100(used) ~ 150 ms = 160 * 0.625 ms */
+#define BTM_BLE_GAP_ADV_SLOW_INT           2048         /* Tgap(adv_slow_interval) = 1.28 s= 512 * 0.625 ms */
+#define BTM_BLE_GAP_ADV_DIR_MAX_INT        800         /* Tgap(dir_conn_adv_int_max) = 500 ms = 800 * 0.625 ms */
+#define BTM_BLE_GAP_ADV_DIR_MIN_INT        400         /* Tgap(dir_conn_adv_int_min) = 250 ms = 400 * 0.625 ms */
+
+#define BTM_BLE_GAP_FAST_ADV_TIMEOUT_MS    (30 * 1000)
+
+#define BTM_BLE_SEC_REQ_ACT_NONE           0
+#define BTM_BLE_SEC_REQ_ACT_ENCRYPT        1 /* encrypt the link using current key or key refresh */
+#define BTM_BLE_SEC_REQ_ACT_PAIR           2
+#define BTM_BLE_SEC_REQ_ACT_DISCARD        3 /* discard the sec request while encryption is started but not completed */
+typedef UINT8   tBTM_BLE_SEC_REQ_ACT;
+
+#define BLE_STATIC_PRIVATE_MSB_MASK          0x3f
+#define BLE_RESOLVE_ADDR_MSB                 0x40   /*  most significant bit, bit7, bit6 is 01 to be resolvable random */
+#define BLE_RESOLVE_ADDR_MASK                0xc0   /* bit 6, and bit7 */
+#define BTM_BLE_IS_RESOLVE_BDA(x)           ((x[0] & BLE_RESOLVE_ADDR_MASK) == BLE_RESOLVE_ADDR_MSB)
+
+#define BLE_PUBLIC_ADDR_MSB_MASK            0xC0
+#define BLE_PUBLIC_ADDR_MSB                 0x80   /*  most significant bit, bit7, bit6 is 10 to be public address*/
+#define BTM_IS_PUBLIC_BDA(x)               ((x[0]  & BLE_PUBLIC_ADDR_MSB) == BLE_PUBLIC_ADDR_MSB_MASK)
+
+/* LE scan activity bit mask, continue with LE inquiry bits */
+#define BTM_LE_SELECT_CONN_ACTIVE      0x40     /* selection connection is in progress */
+#define BTM_LE_OBSERVE_ACTIVE          0x80     /* observe is in progress */
+
+/* BLE scan activity mask checking */
+#define BTM_BLE_IS_SCAN_ACTIVE(x)   ((x) & BTM_BLE_SCAN_ACTIVE_MASK)
+#define BTM_BLE_IS_INQ_ACTIVE(x)   ((x) & BTM_BLE_INQUIRY_MASK)
+#define BTM_BLE_IS_OBS_ACTIVE(x)   ((x) & BTM_LE_OBSERVE_ACTIVE)
+#define BTM_BLE_IS_SEL_CONN_ACTIVE(x)   ((x) & BTM_LE_SELECT_CONN_ACTIVE)
+
+/* BLE ADDR type ID bit */
+#define BLE_ADDR_TYPE_ID_BIT 0x02
+
+#define BTM_VSC_CHIP_CAPABILITY_L_VERSION 55
+#define BTM_VSC_CHIP_CAPABILITY_M_VERSION 95
+
+typedef struct
+{
+    UINT16              data_mask;
+    UINT8               *p_flags;
+    UINT8               ad_data[BTM_BLE_AD_DATA_LEN];
+    UINT8               *p_pad;
+}tBTM_BLE_LOCAL_ADV_DATA;
+
+typedef struct
+{
+    UINT32          inq_count;          /* Used for determining if a response has already been      */
+                                        /* received for the current inquiry operation. (We do not   */
+                                        /* want to flood the caller with multiple responses from    */
+                                        /* the same device.                                         */
+    BOOLEAN         scan_rsp;
+    tBLE_BD_ADDR    le_bda;
+} tINQ_LE_BDADDR;
+
+#define BTM_BLE_ADV_DATA_LEN_MAX        31
+#define BTM_BLE_CACHE_ADV_DATA_MAX      62
+
+#define BTM_BLE_ISVALID_PARAM(x, min, max)  (((x) >= (min) && (x) <= (max)) || ((x) == BTM_BLE_CONN_PARAM_UNDEF))
+
+/* 15 minutes minimum for random address refreshing */
+#define BTM_BLE_PRIVATE_ADDR_INT_MS     (15 * 60 * 1000)
+
+typedef struct
+{
+    UINT16 discoverable_mode;
+    UINT16 connectable_mode;
+    UINT32 scan_window;
+    UINT32 scan_interval;
+    UINT8 scan_type; /* current scan type: active or passive */
+    UINT8 scan_duplicate_filter; /* duplicate filter enabled for scan */
+    UINT16 adv_interval_min;
+    UINT16 adv_interval_max;
+    tBTM_BLE_AFP afp; /* advertising filter policy */
+    tBTM_BLE_SFP sfp; /* scanning filter policy */
+
+    tBLE_ADDR_TYPE adv_addr_type;
+    UINT8 evt_type;
+    UINT8 adv_mode;
+    tBLE_BD_ADDR direct_bda;
+    tBTM_BLE_EVT directed_conn;
+    BOOLEAN fast_adv_on;
+    alarm_t *fast_adv_timer;
+
+    UINT8 adv_len;
+    UINT8 adv_data_cache[BTM_BLE_CACHE_ADV_DATA_MAX];
+
+    /* inquiry BD addr database */
+    UINT8 num_bd_entries;
+    UINT8 max_bd_entries;
+    tBTM_BLE_LOCAL_ADV_DATA adv_data;
+    tBTM_BLE_ADV_CHNL_MAP adv_chnl_map;
+
+    alarm_t *inquiry_timer;
+    BOOLEAN scan_rsp;
+    UINT8 state; /* Current state that the inquiry process is in */
+    INT8 tx_power;
+} tBTM_BLE_INQ_CB;
+
+
+/* random address resolving complete callback */
+typedef void (tBTM_BLE_RESOLVE_CBACK) (void * match_rec, void *p);
+
+typedef void (tBTM_BLE_ADDR_CBACK) (BD_ADDR_PTR static_random, void *p);
+
+/* random address management control block */
+typedef struct
+{
+    tBLE_ADDR_TYPE              own_addr_type;         /* local device LE address type */
+    BD_ADDR                     private_addr;
+    BD_ADDR                     random_bda;
+    BOOLEAN                     busy;
+    tBTM_BLE_ADDR_CBACK         *p_generate_cback;
+    void                        *p;
+    alarm_t                     *refresh_raddr_timer;
+} tBTM_LE_RANDOM_CB;
+
+#define BTM_BLE_MAX_BG_CONN_DEV_NUM    10
+
+typedef struct
+{
+    UINT16              min_conn_int;
+    UINT16              max_conn_int;
+    UINT16              slave_latency;
+    UINT16              supervision_tout;
+
+}tBTM_LE_CONN_PRAMS;
+
+
+typedef struct
+{
+    BD_ADDR     bd_addr;
+    UINT8       attr;
+    BOOLEAN     is_connected;
+    BOOLEAN     in_use;
+}tBTM_LE_BG_CONN_DEV;
+
+  /* white list using state as a bit mask */
+#define BTM_BLE_WL_IDLE         0
+#define BTM_BLE_WL_INIT         1
+#define BTM_BLE_WL_SCAN         2
+#define BTM_BLE_WL_ADV          4
+typedef UINT8 tBTM_BLE_WL_STATE;
+
+/* resolving list using state as a bit mask */
+#define BTM_BLE_RL_IDLE         0
+#define BTM_BLE_RL_INIT         1
+#define BTM_BLE_RL_SCAN         2
+#define BTM_BLE_RL_ADV          4
+typedef UINT8 tBTM_BLE_RL_STATE;
+
+/* BLE connection state */
+#define BLE_CONN_IDLE    0
+#define BLE_DIR_CONN     1
+#define BLE_BG_CONN      2
+#define BLE_CONN_CANCEL  3
+typedef UINT8 tBTM_BLE_CONN_ST;
+
+typedef struct
+{
+    void    *p_param;
+}tBTM_BLE_CONN_REQ;
+
+/* LE state request */
+#define BTM_BLE_STATE_INVALID               0
+#define BTM_BLE_STATE_CONN_ADV              1
+#define BTM_BLE_STATE_INIT                  2
+#define BTM_BLE_STATE_MASTER                3
+#define BTM_BLE_STATE_SLAVE                 4
+#define BTM_BLE_STATE_LO_DUTY_DIR_ADV       5
+#define BTM_BLE_STATE_HI_DUTY_DIR_ADV       6
+#define BTM_BLE_STATE_NON_CONN_ADV          7
+#define BTM_BLE_STATE_PASSIVE_SCAN          8
+#define BTM_BLE_STATE_ACTIVE_SCAN           9
+#define BTM_BLE_STATE_SCAN_ADV              10
+#define BTM_BLE_STATE_MAX                   11
+typedef UINT8 tBTM_BLE_STATE;
+
+#define BTM_BLE_STATE_CONN_ADV_BIT          0x0001
+#define BTM_BLE_STATE_INIT_BIT              0x0002
+#define BTM_BLE_STATE_MASTER_BIT            0x0004
+#define BTM_BLE_STATE_SLAVE_BIT             0x0008
+#define BTM_BLE_STATE_LO_DUTY_DIR_ADV_BIT   0x0010
+#define BTM_BLE_STATE_HI_DUTY_DIR_ADV_BIT   0x0020
+#define BTM_BLE_STATE_NON_CONN_ADV_BIT      0x0040
+#define BTM_BLE_STATE_PASSIVE_SCAN_BIT      0x0080
+#define BTM_BLE_STATE_ACTIVE_SCAN_BIT       0x0100
+#define BTM_BLE_STATE_SCAN_ADV_BIT          0x0200
+typedef UINT16 tBTM_BLE_STATE_MASK;
+
+#define BTM_BLE_STATE_ALL_MASK              0x03ff
+#define BTM_BLE_STATE_ALL_ADV_MASK          (BTM_BLE_STATE_CONN_ADV_BIT|BTM_BLE_STATE_LO_DUTY_DIR_ADV_BIT|BTM_BLE_STATE_HI_DUTY_DIR_ADV_BIT|BTM_BLE_STATE_SCAN_ADV_BIT)
+#define BTM_BLE_STATE_ALL_SCAN_MASK         (BTM_BLE_STATE_PASSIVE_SCAN_BIT|BTM_BLE_STATE_ACTIVE_SCAN_BIT)
+#define BTM_BLE_STATE_ALL_CONN_MASK         (BTM_BLE_STATE_MASTER_BIT|BTM_BLE_STATE_SLAVE_BIT)
+
+#ifndef BTM_LE_RESOLVING_LIST_MAX
+#define BTM_LE_RESOLVING_LIST_MAX     0x20
+#endif
+
+typedef struct
+{
+    BD_ADDR         *resolve_q_random_pseudo;
+    UINT8           *resolve_q_action;
+    UINT8           q_next;
+    UINT8           q_pending;
+} tBTM_BLE_RESOLVE_Q;
+
+typedef struct
+{
+    BOOLEAN     in_use;
+    BOOLEAN     to_add;
+    BD_ADDR     bd_addr;
+    UINT8       attr;
+}tBTM_BLE_WL_OP;
+
+/* BLE privacy mode */
+#define BTM_PRIVACY_NONE    0              /* BLE no privacy */
+#define BTM_PRIVACY_1_1     1              /* BLE privacy 1.1, do not support privacy 1.0 */
+#define BTM_PRIVACY_1_2     2              /* BLE privacy 1.2 */
+#define BTM_PRIVACY_MIXED   3              /* BLE privacy mixed mode, broadcom propietary mode */
+typedef UINT8 tBTM_PRIVACY_MODE;
+
+/* data length change event callback */
+typedef void (tBTM_DATA_LENGTH_CHANGE_CBACK) (UINT16 max_tx_length, UINT16 max_rx_length);
+
+/* Define BLE Device Management control structure
+*/
+typedef struct
+{
+    UINT8 scan_activity;         /* LE scan activity mask */
+
+    /*****************************************************
+    **      BLE Inquiry
+    *****************************************************/
+    tBTM_BLE_INQ_CB inq_var;
+
+    /* observer callback and timer */
+    tBTM_INQ_RESULTS_CB *p_obs_results_cb;
+    tBTM_CMPL_CB *p_obs_cmpl_cb;
+    alarm_t *observer_timer;
+
+    /* background connection procedure cb value */
+    tBTM_BLE_CONN_TYPE bg_conn_type;
+    UINT32 scan_int;
+    UINT32 scan_win;
+    tBTM_BLE_SEL_CBACK *p_select_cback;
+
+    /* white list information */
+    UINT8 white_list_avail_size;
+    tBTM_BLE_WL_STATE wl_state;
+
+    fixed_queue_t *conn_pending_q;
+    tBTM_BLE_CONN_ST conn_state;
+
+    /* random address management control block */
+    tBTM_LE_RANDOM_CB addr_mgnt_cb;
+
+    BOOLEAN enabled;
+
+#if BLE_PRIVACY_SPT == TRUE
+    BOOLEAN mixed_mode; /* privacy 1.2 mixed mode is on or not */
+    tBTM_PRIVACY_MODE privacy_mode; /* privacy mode */
+    UINT8 resolving_list_avail_size; /* resolving list available size */
+    tBTM_BLE_RESOLVE_Q resolving_list_pend_q; /* Resolving list queue */
+    tBTM_BLE_RL_STATE suspended_rl_state; /* Suspended resolving list state */
+    UINT8 *irk_list_mask; /* IRK list availability mask, up to max entry bits */
+    tBTM_BLE_RL_STATE rl_state; /* Resolving list state */
+#endif
+
+    tBTM_BLE_WL_OP wl_op_q[BTM_BLE_MAX_BG_CONN_DEV_NUM];
+
+    /* current BLE link state */
+    tBTM_BLE_STATE_MASK cur_states; /* bit mask of tBTM_BLE_STATE */
+    UINT8 link_count[2]; /* total link count master and slave*/
+} tBTM_BLE_CB;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // BTM_BLE_INT_TYPES_H
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
index ebf96758e..6b3e52826 100644
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -43,875 +43,7 @@
 #endif
 #endif
 
-#if BTM_MAX_LOC_BD_NAME_LEN > 0
-typedef char tBTM_LOC_BD_NAME[BTM_MAX_LOC_BD_NAME_LEN + 1];
-#endif
-
-#define  BTM_ACL_IS_CONNECTED(bda)   (btm_bda_to_acl (bda, BT_TRANSPORT_BR_EDR) != NULL)
-
-/* Definitions for Server Channel Number (SCN) management
-*/
-#define BTM_MAX_SCN      PORT_MAX_RFC_PORTS
-
-/* Define masks for supported and exception 2.0 ACL packet types
-*/
-#define BTM_ACL_SUPPORTED_PKTS_MASK      (HCI_PKT_TYPES_MASK_DM1        | \
-                                          HCI_PKT_TYPES_MASK_DH1        | \
-                                          HCI_PKT_TYPES_MASK_DM3        | \
-                                          HCI_PKT_TYPES_MASK_DH3        | \
-                                          HCI_PKT_TYPES_MASK_DM5        | \
-                                          HCI_PKT_TYPES_MASK_DH5)
-
-#define BTM_ACL_EXCEPTION_PKTS_MASK      (HCI_PKT_TYPES_MASK_NO_2_DH1   | \
-                                          HCI_PKT_TYPES_MASK_NO_3_DH1   | \
-                                          HCI_PKT_TYPES_MASK_NO_2_DH3   | \
-                                          HCI_PKT_TYPES_MASK_NO_3_DH3   | \
-                                          HCI_PKT_TYPES_MASK_NO_2_DH5   | \
-                                          HCI_PKT_TYPES_MASK_NO_3_DH5)
-
-#define BTM_EPR_AVAILABLE(p) ((HCI_ATOMIC_ENCRYPT_SUPPORTED((p)->peer_lmp_features[HCI_EXT_FEATURES_PAGE_0]) && \
-                               HCI_ATOMIC_ENCRYPT_SUPPORTED(controller_get_interface()->get_features_classic(0)->as_array)) \
-                               ? TRUE : FALSE)
-
-#define BTM_IS_BRCM_CONTROLLER() (controller_get_interface()->get_bt_version()->manufacturer == LMP_COMPID_BROADCOM)
-
-/* Define the ACL Management control structure
-*/
-typedef struct
-{
-    UINT16          hci_handle;
-    UINT16          pkt_types_mask;
-    UINT16          clock_offset;
-    BD_ADDR         remote_addr;
-    DEV_CLASS       remote_dc;
-    BD_NAME         remote_name;
-
-    UINT16          manufacturer;
-    UINT16          lmp_subversion;
-    UINT16          link_super_tout;
-    BD_FEATURES     peer_lmp_features[HCI_EXT_FEATURES_PAGE_MAX + 1];    /* Peer LMP Extended features mask table for the device */
-    UINT8           num_read_pages;
-    UINT8           lmp_version;
-
-    BOOLEAN         in_use;
-    UINT8           link_role;
-    BOOLEAN         link_up_issued;     /* True if busy_level link up has been issued */
-
-#define BTM_ACL_SWKEY_STATE_IDLE                0
-#define BTM_ACL_SWKEY_STATE_MODE_CHANGE         1
-#define BTM_ACL_SWKEY_STATE_ENCRYPTION_OFF      2
-#define BTM_ACL_SWKEY_STATE_SWITCHING           3
-#define BTM_ACL_SWKEY_STATE_ENCRYPTION_ON       4
-#define BTM_ACL_SWKEY_STATE_IN_PROGRESS         5
-    UINT8           switch_role_state;
-#define BTM_MAX_SW_ROLE_FAILED_ATTEMPTS         3
-    UINT8           switch_role_failed_attempts;
-
-#define BTM_ACL_ENCRYPT_STATE_IDLE              0
-#define BTM_ACL_ENCRYPT_STATE_ENCRYPT_OFF       1   /* encryption turning off */
-#define BTM_ACL_ENCRYPT_STATE_TEMP_FUNC         2   /* temporarily off for change link key or role switch */
-#define BTM_ACL_ENCRYPT_STATE_ENCRYPT_ON        3   /* encryption turning on */
-    UINT8           encrypt_state;                  /* overall BTM encryption state */
-
-#if BLE_INCLUDED == TRUE
-    tBT_TRANSPORT   transport;
-    BD_ADDR         conn_addr;              /* local device address used for this connection */
-    UINT8           conn_addr_type;         /* local device address type for this connection */
-    BD_ADDR         active_remote_addr;     /* remote address used on this connection */
-    UINT8           active_remote_addr_type;         /* local device address type for this connection */
-    BD_FEATURES     peer_le_features;       /* Peer LE Used features mask for the device */
-
-#endif
-
-} tACL_CONN;
-
-/* Define the Device Management control structure
-*/
-typedef struct
-{
-    tBTM_DEV_STATUS_CB  *p_dev_status_cb;   /* Device status change callback        */
-    tBTM_VS_EVT_CB      *p_vend_spec_cb[BTM_MAX_VSE_CALLBACKS];     /* Register for vendor specific events  */
-
-    tBTM_CMPL_CB        *p_stored_link_key_cmpl_cb;   /* Read/Write/Delete stored link key    */
-
-    alarm_t             *read_local_name_timer; /* Read local name timer */
-    tBTM_CMPL_CB        *p_rln_cmpl_cb;     /* Callback function to be called when  */
-                                            /* read local name function complete    */
-    alarm_t             *read_rssi_timer;   /* Read RSSI timer */
-    tBTM_CMPL_CB        *p_rssi_cmpl_cb;    /* Callback function to be called when  */
-                                            /* read RSSI function completes */
-    alarm_t             *read_link_quality_timer;
-    tBTM_CMPL_CB        *p_link_qual_cmpl_cb; /* Callback function to be called when  */
-                                            /* read link quality function completes */
-
-    alarm_t             *read_inq_tx_power_timer;
-    tBTM_CMPL_CB        *p_inq_tx_power_cmpl_cb; /* Callback function to be called when  */
-                                            /* read inq tx power function completes  */
-
-    alarm_t             *qos_setup_timer;   /* QoS setup timer */
-    tBTM_CMPL_CB        *p_qos_setup_cmpl_cb; /* Callback function to be called when  */
-                                            /* qos setup function completes         */
-
-    tBTM_ROLE_SWITCH_CMPL switch_role_ref_data;
-    tBTM_CMPL_CB        *p_switch_role_cb;  /* Callback function to be called when  */
-                                            /* requested switch role is completed   */
-
-    alarm_t             *read_tx_power_timer; /* Read tx power timer */
-    tBTM_CMPL_CB        *p_tx_power_cmpl_cb;/* Callback function to be called       */
-
-    DEV_CLASS            dev_class;         /* Local device class                   */
-
-#if BLE_INCLUDED == TRUE
-
-    tBTM_CMPL_CB        *p_le_test_cmd_cmpl_cb;   /* Callback function to be called when
-                                                  LE test mode command has been sent successfully */
-
-    BD_ADDR                 read_tx_pwr_addr;   /* read TX power target address     */
-
-#define BTM_LE_SUPPORT_STATE_SIZE   8
-UINT8                   le_supported_states[BTM_LE_SUPPORT_STATE_SIZE];
-
-tBTM_BLE_LOCAL_ID_KEYS id_keys; /* local BLE ID keys */
-BT_OCTET16 ble_encryption_key_value; /* BLE encryption key */
-
-#if BTM_BLE_CONFORMANCE_TESTING == TRUE
-    BOOLEAN                 no_disc_if_pair_fail;
-    BOOLEAN                 enable_test_mac_val;
-    BT_OCTET8               test_mac;
-    BOOLEAN                 enable_test_local_sign_cntr;
-    UINT32                  test_local_sign_cntr;
-#endif
-
-#endif  /* BLE_INCLUDED */
-
-#if HCI_RAW_CMD_INCLUDED == TRUE
-    tBTM_RAW_CMPL_CB     *p_hci_evt_cb;       /* Callback function to be called when
-                                                HCI event is received successfully */
-#endif
-
-    tBTM_IO_CAP          loc_io_caps;       /* IO capability of the local device */
-    tBTM_AUTH_REQ        loc_auth_req;      /* the auth_req flag  */
-    BOOLEAN              secure_connections_only;    /* Rejects service level 0 connections if */
-                                                     /* itself or peer device doesn't support */
-                                                     /* secure connections */
-} tBTM_DEVCB;
-
-
-/* Define the structures and constants used for inquiry
-*/
-
-/* Definitions of limits for inquiries */
-#define BTM_PER_INQ_MIN_MAX_PERIOD      HCI_PER_INQ_MIN_MAX_PERIOD
-#define BTM_PER_INQ_MAX_MAX_PERIOD      HCI_PER_INQ_MAX_MAX_PERIOD
-#define BTM_PER_INQ_MIN_MIN_PERIOD      HCI_PER_INQ_MIN_MIN_PERIOD
-#define BTM_PER_INQ_MAX_MIN_PERIOD      HCI_PER_INQ_MAX_MIN_PERIOD
-#define BTM_MAX_INQUIRY_LENGTH          HCI_MAX_INQUIRY_LENGTH
-#define BTM_MIN_INQUIRY_LEN             0x01
-
-#define BTM_MIN_INQ_TX_POWER    -70
-#define BTM_MAX_INQ_TX_POWER    20
-
-typedef struct
-{
-    UINT32          inq_count;          /* Used for determining if a response has already been      */
-                                        /* received for the current inquiry operation. (We do not   */
-                                        /* want to flood the caller with multiple responses from    */
-                                        /* the same device.                                         */
-    BD_ADDR         bd_addr;
-} tINQ_BDADDR;
-
-typedef struct
-{
-    UINT32          time_of_resp;
-    UINT32          inq_count;          /* "timestamps" the entry with a particular inquiry count   */
-                                        /* Used for determining if a response has already been      */
-                                        /* received for the current inquiry operation. (We do not   */
-                                        /* want to flood the caller with multiple responses from    */
-                                        /* the same device.                                         */
-    tBTM_INQ_INFO   inq_info;
-    BOOLEAN         in_use;
-
-#if (BLE_INCLUDED == TRUE)
-    BOOLEAN         scan_rsp;
-#endif
-} tINQ_DB_ENT;
-
-
-enum
-{
-    INQ_NONE,
-    INQ_LE_OBSERVE,
-    INQ_GENERAL
-};
-typedef UINT8 tBTM_INQ_TYPE;
-
-typedef struct
-{
-    tBTM_CMPL_CB *p_remname_cmpl_cb;
-
-#define BTM_EXT_RMT_NAME_TIMEOUT_MS (40 * 1000) /* 40 seconds */
-
-
-    alarm_t         *remote_name_timer;
-
-    UINT16           discoverable_mode;
-    UINT16           connectable_mode;
-    UINT16           page_scan_window;
-    UINT16           page_scan_period;
-    UINT16           inq_scan_window;
-    UINT16           inq_scan_period;
-    UINT16           inq_scan_type;
-    UINT16           page_scan_type;        /* current page scan type */
-    tBTM_INQ_TYPE    scan_type;
-
-    BD_ADDR          remname_bda;           /* Name of bd addr for active remote name request */
-#define BTM_RMT_NAME_INACTIVE       0
-#define BTM_RMT_NAME_EXT            0x1     /* Initiated through API */
-#define BTM_RMT_NAME_SEC            0x2     /* Initiated internally by security manager */
-#define BTM_RMT_NAME_INQ            0x4     /* Remote name initiated internally by inquiry */
-    BOOLEAN          remname_active;        /* State of a remote name request by external API */
-
-    tBTM_CMPL_CB    *p_inq_cmpl_cb;
-    tBTM_INQ_RESULTS_CB *p_inq_results_cb;
-    tBTM_CMPL_CB    *p_inq_ble_cmpl_cb;     /*completion callback exclusively for LE Observe*/
-    tBTM_INQ_RESULTS_CB *p_inq_ble_results_cb;/*results callback exclusively for LE observe*/
-    tBTM_CMPL_CB    *p_inqfilter_cmpl_cb;   /* Called (if not NULL) after inquiry filter completed */
-    UINT32           inq_counter;           /* Counter incremented each time an inquiry completes */
-                                            /* Used for determining whether or not duplicate devices */
-                                            /* have responded to the same inquiry */
-    tINQ_BDADDR     *p_bd_db;               /* Pointer to memory that holds bdaddrs */
-    UINT16           num_bd_entries;        /* Number of entries in database */
-    UINT16           max_bd_entries;        /* Maximum number of entries that can be stored */
-    tINQ_DB_ENT      inq_db[BTM_INQ_DB_SIZE];
-    tBTM_INQ_PARMS   inqparms;              /* Contains the parameters for the current inquiry */
-    tBTM_INQUIRY_CMPL inq_cmpl_info;        /* Status and number of responses from the last inquiry */
-
-    UINT16           per_min_delay;         /* Current periodic minimum delay */
-    UINT16           per_max_delay;         /* Current periodic maximum delay */
-    BOOLEAN          inqfilt_active;
-    UINT8            pending_filt_complete_event; /* to take care of btm_event_filter_complete corresponding to */
-                                                  /* inquiry that has been cancelled*/
-    UINT8            inqfilt_type;          /* Contains the inquiry filter type (BD ADDR, COD, or Clear) */
-
-#define BTM_INQ_INACTIVE_STATE      0
-#define BTM_INQ_CLR_FILT_STATE      1   /* Currently clearing the inquiry filter preceeding the inquiry request */
-                                        /* (bypassed if filtering is not used)                                  */
-#define BTM_INQ_SET_FILT_STATE      2   /* Sets the new filter (or turns off filtering) in this state */
-#define BTM_INQ_ACTIVE_STATE        3   /* Actual inquiry or periodic inquiry is in progress */
-#define BTM_INQ_REMNAME_STATE       4   /* Remote name requests are active  */
-
-    UINT8            state;             /* Current state that the inquiry process is in */
-    UINT8            inq_active;        /* Bit Mask indicating type of inquiry is active */
-    BOOLEAN          no_inc_ssp;        /* TRUE, to stop inquiry on incoming SSP */
-#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
-    btm_inq_state    next_state;        /*interleaving state to determine next mode to be inquired*/
-#endif
-} tBTM_INQUIRY_VAR_ST;
-
-/* The MSB of the clock offset field indicates that the offset is valid if TRUE */
-#define BTM_CLOCK_OFFSET_VALID      0x8000
-
-/* Define the structures needed by security management
-*/
-
-#define BTM_SEC_INVALID_HANDLE  0xFFFF
-
-typedef UINT8 *BTM_BD_NAME_PTR;                        /* Pointer to Device name */
-
-/* Security callback is called by this unit when security
-**   procedures are completed.  Parameters are
-**              BD Address of remote
-**              Result of the operation
-*/
-typedef tBTM_SEC_CBACK tBTM_SEC_CALLBACK;
-
-typedef void (tBTM_SCO_IND_CBACK) (UINT16 sco_inx) ;
-
-/* MACROs to convert from SCO packet types mask to ESCO and back */
-#define BTM_SCO_PKT_TYPE_MASK   (   HCI_PKT_TYPES_MASK_HV1      \
-                                 |  HCI_PKT_TYPES_MASK_HV2      \
-                                 |  HCI_PKT_TYPES_MASK_HV3)
-
-/* Mask defining only the SCO types of an esco packet type */
-#define BTM_ESCO_PKT_TYPE_MASK  (   HCI_ESCO_PKT_TYPES_MASK_HV1 \
-                                 |  HCI_ESCO_PKT_TYPES_MASK_HV2 \
-                                 |  HCI_ESCO_PKT_TYPES_MASK_HV3)
-
-#define BTM_SCO_2_ESCO(scotype)  ((UINT16)(((scotype) & BTM_SCO_PKT_TYPE_MASK) >> 5))
-#define BTM_ESCO_2_SCO(escotype) ((UINT16)(((escotype) & BTM_ESCO_PKT_TYPE_MASK) << 5))
-
-/* Define masks for supported and exception 2.0 SCO packet types
-*/
-#define BTM_SCO_SUPPORTED_PKTS_MASK      (HCI_ESCO_PKT_TYPES_MASK_HV1       | \
-                                          HCI_ESCO_PKT_TYPES_MASK_HV2       | \
-                                          HCI_ESCO_PKT_TYPES_MASK_HV3       | \
-                                          HCI_ESCO_PKT_TYPES_MASK_EV3       | \
-                                          HCI_ESCO_PKT_TYPES_MASK_EV4       | \
-                                          HCI_ESCO_PKT_TYPES_MASK_EV5)
-
-#define BTM_SCO_EXCEPTION_PKTS_MASK      (HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3  | \
-                                          HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3  | \
-                                          HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5  | \
-                                          HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5)
-
-
-#define BTM_SCO_ROUTE_UNKNOWN       0xff
-
-/* Define the structure that contains (e)SCO data */
-typedef struct
-{
-    tBTM_ESCO_CBACK    *p_esco_cback;   /* Callback for eSCO events     */
-    tBTM_ESCO_PARAMS    setup;
-    tBTM_ESCO_DATA      data;           /* Connection complete information */
-    UINT8               hci_status;
-} tBTM_ESCO_INFO;
-
-/* Define the structure used for SCO Management
-*/
-typedef struct
-{
-    tBTM_ESCO_INFO   esco;              /* Current settings             */
-#if BTM_SCO_HCI_INCLUDED == TRUE
-    fixed_queue_t   *xmit_data_q;       /* SCO data transmitting queue  */
-#endif
-    tBTM_SCO_CB     *p_conn_cb;         /* Callback for when connected  */
-    tBTM_SCO_CB     *p_disc_cb;         /* Callback for when disconnect */
-    UINT16           state;             /* The state of the SCO link    */
-    UINT16           hci_handle;        /* HCI Handle                   */
-    BOOLEAN          is_orig;           /* TRUE if the originator       */
-    BOOLEAN          rem_bd_known;      /* TRUE if remote BD addr known */
-
-} tSCO_CONN;
-
-/* SCO Management control block */
-typedef struct
-{
-    tBTM_SCO_IND_CBACK  *app_sco_ind_cb;
-#if BTM_SCO_HCI_INCLUDED == TRUE
-    tBTM_SCO_DATA_CB     *p_data_cb;        /* Callback for SCO data over HCI */
-    UINT32               xmit_window_size; /* Total SCO window in bytes  */
-#endif
-    tSCO_CONN            sco_db[BTM_MAX_SCO_LINKS];
-    tBTM_ESCO_PARAMS     def_esco_parms;
-    BD_ADDR              xfer_addr;
-    UINT16               sco_disc_reason;
-    BOOLEAN              esco_supported;    /* TRUE if 1.2 cntlr AND supports eSCO links */
-    tBTM_SCO_TYPE        desired_sco_mode;
-    tBTM_SCO_TYPE        xfer_sco_type;
-    tBTM_SCO_PCM_PARAM   sco_pcm_param;
-    tBTM_SCO_CODEC_TYPE  codec_in_use;      /* None, CVSD, MSBC, etc. */
-#if BTM_SCO_HCI_INCLUDED == TRUE
-    tBTM_SCO_ROUTE_TYPE  sco_path;
-#endif
-
-} tSCO_CB;
-
-
-#if BTM_SCO_INCLUDED == TRUE
-extern void     btm_set_sco_ind_cback( tBTM_SCO_IND_CBACK *sco_ind_cb );
-extern void     btm_accept_sco_link(UINT16 sco_inx, tBTM_ESCO_PARAMS *p_setup,
-                                    tBTM_SCO_CB *p_conn_cb, tBTM_SCO_CB *p_disc_cb);
-extern void     btm_reject_sco_link(UINT16 sco_inx );
-extern void btm_sco_chk_pend_rolechange (UINT16 hci_handle);
-extern void btm_sco_disc_chk_pend_for_modechange (UINT16 hci_handle);
-
-#else
-#define btm_accept_sco_link(sco_inx, p_setup, p_conn_cb, p_disc_cb)
-#define btm_reject_sco_link(sco_inx)
-#define btm_set_sco_ind_cback(sco_ind_cb)
-#define btm_sco_chk_pend_rolechange(hci_handle)
-#endif  /* BTM_SCO_INCLUDED */
-
-/*
-** Define structure for Security Service Record.
-** A record exists for each service registered with the Security Manager
-*/
-#define BTM_SEC_OUT_FLAGS   (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHORIZE)
-#define BTM_SEC_IN_FLAGS    (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHORIZE)
-
-#define BTM_SEC_OUT_LEVEL4_FLAGS   (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT | \
-                                    BTM_SEC_OUT_MITM | BTM_SEC_MODE4_LEVEL4)
-
-#define BTM_SEC_IN_LEVEL4_FLAGS    (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT | \
-                                    BTM_SEC_IN_MITM | BTM_SEC_MODE4_LEVEL4)
-typedef struct
-{
-    UINT32          mx_proto_id;        /* Service runs over this multiplexer protocol */
-    UINT32          orig_mx_chan_id;    /* Channel on the multiplexer protocol    */
-    UINT32          term_mx_chan_id;    /* Channel on the multiplexer protocol    */
-    UINT16          psm;                /* L2CAP PSM value */
-    UINT16          security_flags;     /* Bitmap of required security features */
-    UINT8           service_id;         /* Passed in authorization callback */
-#if (L2CAP_UCD_INCLUDED == TRUE)
-    UINT16          ucd_security_flags; /* Bitmap of required security features for UCD */
-#endif
-#if BTM_SEC_SERVICE_NAME_LEN > 0
-    UINT8           orig_service_name[BTM_SEC_SERVICE_NAME_LEN + 1];
-    UINT8           term_service_name[BTM_SEC_SERVICE_NAME_LEN + 1];
-#endif
-} tBTM_SEC_SERV_REC;
-
-#if BLE_INCLUDED == TRUE
-/* LE Security information of device in Slave Role */
-typedef struct
-{
-    BT_OCTET16          irk;            /* peer diverified identity root */
-    BT_OCTET16          pltk;           /* peer long term key */
-    BT_OCTET16          pcsrk;          /* peer SRK peer device used to secured sign local data  */
-
-    BT_OCTET16          lltk;           /* local long term key */
-    BT_OCTET16          lcsrk;          /* local SRK peer device used to secured sign local data  */
-
-    BT_OCTET8           rand;           /* random vector for LTK generation */
-    UINT16              ediv;           /* LTK diversifier of this slave device */
-    UINT16              div;            /* local DIV  to generate local LTK=d1(ER,DIV,0) and CSRK=d1(ER,DIV,1)  */
-    UINT8               sec_level;      /* local pairing security level */
-    UINT8               key_size;       /* key size of the LTK delivered to peer device */
-    UINT8               srk_sec_level;  /* security property of peer SRK for this device */
-    UINT8               local_csrk_sec_level;  /* security property of local CSRK for this device */
-
-    UINT32              counter;        /* peer sign counter for verifying rcv signed cmd */
-    UINT32              local_counter;  /* local sign counter for sending signed write cmd*/
-}tBTM_SEC_BLE_KEYS;
-
-typedef struct
-{
-    BD_ADDR pseudo_addr; /* LE pseudo address of the device if different from device address  */
-    tBLE_ADDR_TYPE      ble_addr_type;  /* LE device type: public or random address */
-    tBLE_ADDR_TYPE      static_addr_type;   /* static address type */
-    BD_ADDR             static_addr;    /* static address */
-
-#define BTM_WHITE_LIST_BIT          0x01
-#define BTM_RESOLVING_LIST_BIT      0x02
-    UINT8               in_controller_list;   /* in controller resolving list or not */
-    UINT8               resolving_list_index;
-#if BLE_PRIVACY_SPT == TRUE
-    BD_ADDR             cur_rand_addr;  /* current random address */
-
-#define BTM_BLE_ADDR_PSEUDO         0   /* address index device record */
-#define BTM_BLE_ADDR_RRA            1   /* cur_rand_addr */
-#define BTM_BLE_ADDR_STATIC         2   /* static_addr  */
-    UINT8               active_addr_type;
-#endif
-
-#if SMP_INCLUDED == TRUE
-    tBTM_LE_KEY_TYPE    key_type;       /* bit mask of valid key types in record */
-    tBTM_SEC_BLE_KEYS   keys;           /* LE device security info in slave rode */
-#endif
-} tBTM_SEC_BLE;
-
-
-#endif  /* BLE_INCLUDED */
-
-/* Peering bond type */
-enum
-{
-    BOND_TYPE_UNKNOWN,
-    BOND_TYPE_PERSISTENT,
-    BOND_TYPE_TEMPORARY
-};
-typedef UINT8 tBTM_BOND_TYPE;
-
-/*
-** Define structure for Security Device Record.
-** A record exists for each device authenticated with this device
-*/
-typedef struct
-{
-    tBTM_SEC_SERV_REC   *p_cur_service;
-    tBTM_SEC_CALLBACK   *p_callback;
-    void                *p_ref_data;
-    UINT32               timestamp;         /* Timestamp of the last connection   */
-    UINT32               trusted_mask[BTM_SEC_SERVICE_ARRAY_SIZE];  /* Bitwise OR of trusted services     */
-    UINT16               hci_handle;        /* Handle to connection when exists   */
-    UINT16               clock_offset;      /* Latest known clock offset          */
-    BD_ADDR              bd_addr;           /* BD_ADDR of the device              */
-    DEV_CLASS            dev_class;         /* DEV_CLASS of the device            */
-    LINK_KEY             link_key;          /* Device link key                    */
-    UINT8                pin_code_length;   /* Length of the pin_code used for paring */
-
-#define BTM_SEC_AUTHORIZED      BTM_SEC_FLAG_AUTHORIZED     /* 0x01 */
-#define BTM_SEC_AUTHENTICATED   BTM_SEC_FLAG_AUTHENTICATED  /* 0x02 */
-#define BTM_SEC_ENCRYPTED       BTM_SEC_FLAG_ENCRYPTED      /* 0x04 */
-#define BTM_SEC_NAME_KNOWN      0x08
-#define BTM_SEC_LINK_KEY_KNOWN  BTM_SEC_FLAG_LKEY_KNOWN /* 0x10 */
-#define BTM_SEC_LINK_KEY_AUTHED BTM_SEC_FLAG_LKEY_AUTHED    /* 0x20 */
-#define BTM_SEC_ROLE_SWITCHED   0x40
-#define BTM_SEC_IN_USE          0x80
-    /* LE link security flag */
-#define BTM_SEC_LE_AUTHENTICATED   0x0200   /* LE link is encrypted after pairing with MITM */
-#define BTM_SEC_LE_ENCRYPTED       0x0400   /* LE link is encrypted */
-#define BTM_SEC_LE_NAME_KNOWN      0x0800   /* not used */
-#define BTM_SEC_LE_LINK_KEY_KNOWN  0x1000   /* bonded with peer (peer LTK and/or SRK is saved) */
-#define BTM_SEC_LE_LINK_KEY_AUTHED 0x2000   /* pairing is done with MITM */
-#define BTM_SEC_16_DIGIT_PIN_AUTHED 0x4000   /* pairing is done with 16 digit pin */
-
-    UINT16           sec_flags;          /* Current device security state      */
-
-    tBTM_BD_NAME    sec_bd_name;        /* User friendly name of the device. (may be truncated to save space in dev_rec table) */
-    BD_FEATURES     features[HCI_EXT_FEATURES_PAGE_MAX + 1];           /* Features supported by the device */
-    UINT8           num_read_pages;
-    UINT8           rnr_retry_cnt;
-    UINT8           cc_retry_cnt;
-
-#define BTM_SEC_STATE_IDLE               0
-#define BTM_SEC_STATE_AUTHENTICATING     1
-#define BTM_SEC_STATE_ENCRYPTING         2
-#define BTM_SEC_STATE_GETTING_NAME       3
-#define BTM_SEC_STATE_AUTHORIZING        4
-#define BTM_SEC_STATE_SWITCHING_ROLE     5
-#define BTM_SEC_STATE_DISCONNECTING      6 /* disconnecting BR/EDR */
-#define BTM_SEC_STATE_DELAY_FOR_ENC      7 /* delay to check for encryption to work around */
-                                           /* controller problems */
-#define BTM_SEC_STATE_DISCONNECTING_BLE  8 /* disconnecting BLE */
-#define BTM_SEC_STATE_DISCONNECTING_BOTH 9 /* disconnecting BR/EDR and BLE */
-
-    UINT8       sec_state;              /* Operating state                    */
-    BOOLEAN     is_originator;          /* TRUE if device is originating connection */
-#if (L2CAP_UCD_INCLUDED == TRUE)
-    BOOLEAN     is_ucd;                 /* TRUE if device is sending or receiving UCD */
-                                        /* if incoming security failed, received UCD will be discarded */
-#endif
-    BOOLEAN     role_master;            /* TRUE if current mode is master     */
-    UINT16      security_required;      /* Security required for connection   */
-    BOOLEAN     link_key_not_sent;      /* link key notification has not been sent waiting for name */
-    UINT8       link_key_type;          /* Type of key used in pairing   */
-    BOOLEAN     link_key_changed;       /* Changed link key during current connection */
-
-#define BTM_MAX_PRE_SM4_LKEY_TYPE   BTM_LKEY_TYPE_REMOTE_UNIT /* the link key type used by legacy pairing */
-
-#define BTM_SM4_UNKNOWN     0x00
-#define BTM_SM4_KNOWN       0x10
-#define BTM_SM4_TRUE        0x11
-#define BTM_SM4_REQ_PEND    0x08        /* set this bit when getting remote features */
-#define BTM_SM4_UPGRADE     0x04        /* set this bit when upgrading link key */
-#define BTM_SM4_RETRY       0x02        /* set this bit to retry on HCI_ERR_KEY_MISSING or HCI_ERR_LMP_ERR_TRANS_COLLISION */
-#define BTM_SM4_DD_ACP      0x20        /* set this bit to indicate peer initiated dedicated bonding */
-#define BTM_SM4_CONN_PEND   0x40        /* set this bit to indicate accepting acl conn; to be cleared on btm_acl_created */
-    UINT8       sm4;                    /* BTM_SM4_TRUE, if the peer supports SM4 */
-    tBTM_IO_CAP rmt_io_caps;            /* IO capability of the peer device */
-    tBTM_AUTH_REQ rmt_auth_req;         /* the auth_req flag as in the IO caps rsp evt */
-    BOOLEAN     remote_supports_secure_connections;
-    BOOLEAN     remote_features_needed; /* set to true if the local device is in */
-                                        /* "Secure Connections Only" mode and it receives */
-                                        /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
-                                        /* it knows peer's support for Secure Connections */
-
-    UINT16              ble_hci_handle;         /* use in DUMO connection */
-    UINT8               enc_key_size;           /* current link encryption key size */
-    tBT_DEVICE_TYPE     device_type;
-    BOOLEAN             new_encryption_key_is_p256; /* Set to TRUE when the newly generated LK
-                                                    ** is generated from P-256.
-                                                    ** Link encrypted with such LK can be used
-                                                    ** for SM over BR/EDR.
-                                                    */
-    BOOLEAN no_smp_on_br;       /* if set to TRUE then SMP on BR/EDR doesn't */
-                                /* work, i.e. link keys crosspairing */
-                                /* SC BR/EDR->SC LE doesn't happen */
-    tBTM_BOND_TYPE bond_type;   /* peering bond type */
-
-#if BLE_INCLUDED == TRUE
-    tBTM_SEC_BLE        ble;
-    tBTM_LE_CONN_PRAMS  conn_params;
-#endif
-
-#if BTM_DISC_DURING_RS == TRUE
-#define BTM_SEC_RS_NOT_PENDING          0           /* Role Switch not in progress */
-#define BTM_SEC_RS_PENDING              1           /* Role Switch in progress */
-#define BTM_SEC_DISC_PENDING            2           /* Disconnect is pending */
-    UINT8           rs_disc_pending;
-#endif
-#define BTM_SEC_NO_LAST_SERVICE_ID      0
-    UINT8           last_author_service_id;         /* ID of last serviced authorized: Reset after each l2cap connection */
-
-#if (defined(BTM_SAFE_REATTEMPT_ROLE_SWITCH) && BTM_SAFE_REATTEMPT_ROLE_SWITCH == TRUE)
-#define BTM_MAX_BL_SW_ROLE_ATTEMPTS     1
-    UINT8           switch_role_attempts;
-#endif
-
-} tBTM_SEC_DEV_REC;
-
-#define BTM_SEC_IS_SM4(sm) ((BOOLEAN)(BTM_SM4_TRUE == ((sm)&BTM_SM4_TRUE)))
-#define BTM_SEC_IS_SM4_LEGACY(sm) ((BOOLEAN)(BTM_SM4_KNOWN == ((sm)&BTM_SM4_TRUE)))
-#define BTM_SEC_IS_SM4_UNKNOWN(sm) ((BOOLEAN)(BTM_SM4_UNKNOWN == ((sm)&BTM_SM4_TRUE)))
-
-#define BTM_SEC_LE_MASK    (BTM_SEC_LE_AUTHENTICATED|BTM_SEC_LE_ENCRYPTED|BTM_SEC_LE_LINK_KEY_KNOWN|BTM_SEC_LE_LINK_KEY_AUTHED)
-
-/*
-** Define device configuration structure
-*/
-typedef struct
-{
-#if BTM_MAX_LOC_BD_NAME_LEN > 0
-    tBTM_LOC_BD_NAME bd_name;                    /* local Bluetooth device name */
-#endif
-    BOOLEAN          pin_type;                   /* TRUE if PIN type is fixed */
-    UINT8            pin_code_len;               /* Bonding information */
-    PIN_CODE         pin_code;                   /* PIN CODE if pin type is fixed */
-    BOOLEAN          connectable;                /* If TRUE page scan should be enabled */
-    UINT8            def_inq_scan_mode;          /* ??? limited/general/none */
-} tBTM_CFG;
-
-enum
-{
-    BTM_PM_ST_ACTIVE  = BTM_PM_STS_ACTIVE,
-    BTM_PM_ST_HOLD    = BTM_PM_STS_HOLD,
-    BTM_PM_ST_SNIFF   = BTM_PM_STS_SNIFF,
-    BTM_PM_ST_PARK    = BTM_PM_STS_PARK,
-    BTM_PM_ST_PENDING = BTM_PM_STS_PENDING,
-    BTM_PM_ST_INVALID = 0xFF
-};
-typedef UINT8 tBTM_PM_STATE;
-
-enum
-{
-    BTM_PM_SET_MODE_EVT,    /* Set power mode API is called. */
-    BTM_PM_UPDATE_EVT,
-    BTM_PM_RD_MODE_EVT     /* Read power mode API is called. */
-};
-typedef UINT8 tBTM_PM_EVENT;
-
-typedef struct
-{
-    UINT16          event;
-    UINT16          len;
-    UINT8           link_ind;
-} tBTM_PM_MSG_DATA;
-
-typedef struct
-{
-    UINT8 hci_status;
-    UINT8 mode;
-    UINT16 interval;
-} tBTM_PM_MD_CHG_DATA;
-
-typedef struct
-{
-    UINT8          pm_id;      /* the entity that calls SetPowerMode API */
-    tBTM_PM_PWR_MD *p_pmd;
-} tBTM_PM_SET_MD_DATA;
-
-typedef struct
-{
-    void        *p_data;
-    UINT8        link_ind;
-} tBTM_PM_SM_DATA;
-
-typedef struct
-{
-    tBTM_PM_PWR_MD req_mode[BTM_MAX_PM_RECORDS+1]; /* the desired mode and parameters of the connection*/
-    tBTM_PM_PWR_MD set_mode;  /* the mode and parameters sent down to the host controller. */
-    UINT16         interval;  /* the interval from last mode change event. */
-#if (BTM_SSR_INCLUDED == TRUE)
-    UINT16         max_lat;   /* stored SSR maximum latency */
-    UINT16         min_rmt_to;/* stored SSR minimum remote timeout */
-    UINT16         min_loc_to;/* stored SSR minimum local timeout */
-#endif
-    tBTM_PM_STATE  state;     /* contains the current mode of the connection */
-    BOOLEAN        chg_ind;   /* a request change indication */
-} tBTM_PM_MCB;
-
-#define BTM_PM_REC_NOT_USED 0
-typedef struct
-{
-    tBTM_PM_STATUS_CBACK *cback;/* to notify the registered party of mode change event */
-    UINT8                 mask; /* registered request mask. 0, if this entry is not used */
-} tBTM_PM_RCB;
-
-enum
-{
-    BTM_BLI_ACL_UP_EVT,
-    BTM_BLI_ACL_DOWN_EVT,
-    BTM_BLI_PAGE_EVT,
-    BTM_BLI_PAGE_DONE_EVT,
-    BTM_BLI_INQ_EVT,
-    BTM_BLI_INQ_CANCEL_EVT,
-    BTM_BLI_INQ_DONE_EVT
-};
-typedef UINT8 tBTM_BLI_EVENT;
-
-/* Pairing State */
-enum
-{
-    BTM_PAIR_STATE_IDLE,                        /* Idle                                         */
-    BTM_PAIR_STATE_GET_REM_NAME,                /* Getting the remote name (to check for SM4)   */
-    BTM_PAIR_STATE_WAIT_PIN_REQ,                /* Started authentication, waiting for PIN req (PIN is pre-fetched) */
-    BTM_PAIR_STATE_WAIT_LOCAL_PIN,              /* Waiting for local PIN code                   */
-    BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM,        /* Waiting user 'yes' to numeric confirmation   */
-    BTM_PAIR_STATE_KEY_ENTRY,                   /* Key entry state (we are a keyboard)          */
-    BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP,          /* Waiting for local response to peer OOB data  */
-    BTM_PAIR_STATE_WAIT_LOCAL_IOCAPS,           /* Waiting for local IO capabilities and OOB data */
-    BTM_PAIR_STATE_INCOMING_SSP,                /* Incoming SSP (got peer IO caps when idle)    */
-    BTM_PAIR_STATE_WAIT_AUTH_COMPLETE,          /* All done, waiting authentication cpmplete    */
-    BTM_PAIR_STATE_WAIT_DISCONNECT              /* Waiting to disconnect the ACL                */
-};
-typedef UINT8 tBTM_PAIRING_STATE;
-
-#define BTM_PAIR_FLAGS_WE_STARTED_DD    0x01    /* We want to do dedicated bonding              */
-#define BTM_PAIR_FLAGS_PEER_STARTED_DD  0x02    /* Peer initiated dedicated bonding             */
-#define BTM_PAIR_FLAGS_DISC_WHEN_DONE   0x04    /* Disconnect when done     */
-#define BTM_PAIR_FLAGS_PIN_REQD         0x08    /* set this bit when pin_callback is called     */
-#define BTM_PAIR_FLAGS_PRE_FETCH_PIN    0x10    /* set this bit when pre-fetch pin     */
-#define BTM_PAIR_FLAGS_REJECTED_CONNECT 0x20    /* set this bit when rejected incoming connection  */
-#define BTM_PAIR_FLAGS_WE_CANCEL_DD     0x40    /* set this bit when cancelling a bonding procedure */
-#define BTM_PAIR_FLAGS_LE_ACTIVE        0x80    /* use this bit when SMP pairing is active */
-
-
-typedef struct
-{
-    BOOLEAN             is_mux;
-    BD_ADDR             bd_addr;
-    UINT16              psm;
-    BOOLEAN             is_orig;
-    tBTM_SEC_CALLBACK   *p_callback;
-    void                *p_ref_data;
-    UINT32              mx_proto_id;
-    UINT32              mx_chan_id;
-    tBT_TRANSPORT       transport;
-    tBTM_BLE_SEC_ACT    sec_act;
-} tBTM_SEC_QUEUE_ENTRY;
-
-#if (L2CAP_UCD_INCLUDED == TRUE)
-
-#define CONN_ORIENT_TERM                0x00    /* incoming connection oriented */
-#define CONN_ORIENT_ORIG                0x01    /* outgoing connection oriented */
-#define CONNLESS_TERM                   0x02    /* incoming connectionless      */
-#define CONNLESS_ORIG                   0x03    /* outgoing connectionless      */
-#define CONNECTION_TYPE_ORIG_MASK       0x01    /* mask for direction           */
-#define CONNECTION_TYPE_CONNLESS_MASK   0x02    /* mask for connectionless or not */
-typedef UINT8 CONNECTION_TYPE;
-
-#else
-
-#define CONN_ORIENT_TERM                FALSE
-#define CONN_ORIENT_ORIG                TRUE
-typedef BOOLEAN CONNECTION_TYPE;
-
-#endif /* (L2CAP_UCD_INCLUDED == TRUE) */
-
-/* Define a structure to hold all the BTM data
-*/
-
-#define BTM_STATE_BUFFER_SIZE  5                  /* size of state buffer */
-
-typedef struct
-{
-    tBTM_CFG    cfg;                        /* Device configuration */
-
-    /****************************************************
-    **      ACL Management
-    ****************************************************/
-    tACL_CONN   acl_db[MAX_L2CAP_LINKS];
-    UINT8       btm_scn[BTM_MAX_SCN];        /* current SCNs: TRUE if SCN is in use */
-    UINT16      btm_def_link_policy;
-    UINT16      btm_def_link_super_tout;
-
-    tBTM_BL_EVENT_MASK     bl_evt_mask;
-    tBTM_BL_CHANGE_CB     *p_bl_changed_cb;    /* Callback for when Busy Level changed */
-
-    /****************************************************
-    **      Power Management
-    ****************************************************/
-    tBTM_PM_MCB pm_mode_db[MAX_L2CAP_LINKS];   /* per ACL link */
-    tBTM_PM_RCB pm_reg_db[BTM_MAX_PM_RECORDS+1]; /* per application/module */
-    UINT8       pm_pend_link;  /* the index of acl_db, which has a pending PM cmd */
-    UINT8       pm_pend_id;    /* the id pf the module, which has a pending PM cmd */
-
-    /*****************************************************
-    **      Device control
-    *****************************************************/
-    tBTM_DEVCB  devcb;
-
-    /*****************************************************
-    **      BLE Device controllers
-    *****************************************************/
-#if (BLE_INCLUDED == TRUE)
-    tBTM_BLE_CB             ble_ctr_cb;
-
-    UINT16                  enc_handle;
-    BT_OCTET8               enc_rand;   /* received rand value from LTK request*/
-    UINT16                  ediv;       /* received ediv value from LTK request */
-    UINT8                   key_size;
-    tBTM_BLE_VSC_CB         cmn_ble_vsc_cb;
-#endif
-
-                                            /* Packet types supported by the local device */
-    UINT16      btm_acl_pkt_types_supported;
-    UINT16      btm_sco_pkt_types_supported;
-
-
-    /*****************************************************
-    **      Inquiry
-    *****************************************************/
-    tBTM_INQUIRY_VAR_ST     btm_inq_vars;
-
-    /*****************************************************
-    **      SCO Management
-    *****************************************************/
-#if BTM_SCO_INCLUDED == TRUE
-    tSCO_CB             sco_cb;
-#endif
-
-    /*****************************************************
-    **      Security Management
-    *****************************************************/
-    tBTM_APPL_INFO          api;
-
-#define BTM_SEC_MAX_RMT_NAME_CALLBACKS  2
-    tBTM_RMT_NAME_CALLBACK  *p_rmt_name_callback[BTM_SEC_MAX_RMT_NAME_CALLBACKS];
-
-    tBTM_SEC_DEV_REC        *p_collided_dev_rec;
-    alarm_t                 *sec_collision_timer;
-    tBTM_SEC_DEV_REC        *p_cc_retry_dev_rec;
-    UINT32                   collision_start_time;
-    UINT32                   max_collision_delay;
-    UINT32                   dev_rec_count;      /* Counter used for device record timestamp */
-    UINT8                    security_mode;
-    BOOLEAN                  pairing_disabled;
-    BOOLEAN                  connect_only_paired;
-    BOOLEAN                  security_mode_changed;  /* mode changed during bonding */
-    BOOLEAN                  pin_type_changed;       /* pin type changed during bonding */
-    BOOLEAN                  sec_req_pending;       /*   TRUE if a request is pending */
-
-    UINT8                    pin_code_len;  /* for legacy devices */
-    PIN_CODE                 pin_code;      /* for legacy devices */
-    tBTM_PAIRING_STATE       pairing_state; /* The current pairing state    */
-    UINT8                    pairing_flags; /* The current pairing flags    */
-    BD_ADDR                  pairing_bda;   /* The device currently pairing */
-    alarm_t                 *pairing_timer; /* Timer for pairing process    */
-    UINT16                   disc_handle;   /* for legacy devices */
-    UINT8                    disc_reason;   /* for legacy devices */
-    tBTM_SEC_SERV_REC        sec_serv_rec[BTM_SEC_MAX_SERVICE_RECORDS];
-    list_t                  *sec_dev_rec;   /* list of tBTM_SEC_DEV_REC */
-    tBTM_SEC_SERV_REC       *p_out_serv;
-    tBTM_MKEY_CALLBACK      *mkey_cback;
-
-    BD_ADDR                  connecting_bda;
-    DEV_CLASS                connecting_dc;
-
-    UINT8                   acl_disc_reason;
-    UINT8                   trace_level;
-    UINT8                   busy_level; /* the current busy level */
-    BOOLEAN                 is_paging;  /* TRUE, if paging is in progess */
-    BOOLEAN                 is_inquiry; /* TRUE, if inquiry is in progess */
-    fixed_queue_t          *page_queue;
-    BOOLEAN                 paging;
-    BOOLEAN                 discing;
-    fixed_queue_t          *sec_pending_q;  /* pending sequrity requests in tBTM_SEC_QUEUE_ENTRY format */
-
-#if  (!defined(BT_TRACE_VERBOSE) || (BT_TRACE_VERBOSE == FALSE))
-    char state_temp_buffer[BTM_STATE_BUFFER_SIZE];
-#endif
-} tBTM_CB;
-
-/* security action for L2CAP COC channels */
-#define BTM_SEC_OK                1
-#define BTM_SEC_ENCRYPT           2    /* encrypt the link with current key */
-#define BTM_SEC_ENCRYPT_NO_MITM   3    /* unauthenticated encryption or better */
-#define BTM_SEC_ENCRYPT_MITM      4    /* authenticated encryption */
-#define BTM_SEC_ENC_PENDING       5    /* wait for link encryption pending */
-
-typedef UINT8 tBTM_SEC_ACTION;
+#include "btm_int_types.h"
 
 #ifdef __cplusplus
 extern "C"
diff --git a/stack/btm/btm_int_types.h b/stack/btm/btm_int_types.h
new file mode 100644
index 000000000..30e763c23
--- /dev/null
+++ b/stack/btm/btm_int_types.h
@@ -0,0 +1,907 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef BTM_INT_TYPES_H
+#define BTM_INT_TYPES_H
+
+#include "btm_api_types.h"
+#include "btm_ble_api_types.h"
+#include "hcidefs.h"
+#include "btm_ble_int_types.h"
+#include "osi/include/alarm.h"
+#include "osi/include/list.h"
+#include "rfcdefs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if BTM_MAX_LOC_BD_NAME_LEN > 0
+typedef char tBTM_LOC_BD_NAME[BTM_MAX_LOC_BD_NAME_LEN + 1];
+#endif
+
+#define  BTM_ACL_IS_CONNECTED(bda)   (btm_bda_to_acl (bda, BT_TRANSPORT_BR_EDR) != NULL)
+
+/* Definitions for Server Channel Number (SCN) management
+*/
+#define BTM_MAX_SCN      PORT_MAX_RFC_PORTS
+
+/* Define masks for supported and exception 2.0 ACL packet types
+*/
+#define BTM_ACL_SUPPORTED_PKTS_MASK      (HCI_PKT_TYPES_MASK_DM1        | \
+                                          HCI_PKT_TYPES_MASK_DH1        | \
+                                          HCI_PKT_TYPES_MASK_DM3        | \
+                                          HCI_PKT_TYPES_MASK_DH3        | \
+                                          HCI_PKT_TYPES_MASK_DM5        | \
+                                          HCI_PKT_TYPES_MASK_DH5)
+
+#define BTM_ACL_EXCEPTION_PKTS_MASK      (HCI_PKT_TYPES_MASK_NO_2_DH1   | \
+                                          HCI_PKT_TYPES_MASK_NO_3_DH1   | \
+                                          HCI_PKT_TYPES_MASK_NO_2_DH3   | \
+                                          HCI_PKT_TYPES_MASK_NO_3_DH3   | \
+                                          HCI_PKT_TYPES_MASK_NO_2_DH5   | \
+                                          HCI_PKT_TYPES_MASK_NO_3_DH5)
+
+#define BTM_EPR_AVAILABLE(p) ((HCI_ATOMIC_ENCRYPT_SUPPORTED((p)->peer_lmp_features[HCI_EXT_FEATURES_PAGE_0]) && \
+                               HCI_ATOMIC_ENCRYPT_SUPPORTED(controller_get_interface()->get_features_classic(0)->as_array)) \
+                               ? TRUE : FALSE)
+
+#define BTM_IS_BRCM_CONTROLLER() (controller_get_interface()->get_bt_version()->manufacturer == LMP_COMPID_BROADCOM)
+
+/* Define the ACL Management control structure
+*/
+typedef struct
+{
+    UINT16          hci_handle;
+    UINT16          pkt_types_mask;
+    UINT16          clock_offset;
+    BD_ADDR         remote_addr;
+    DEV_CLASS       remote_dc;
+    BD_NAME         remote_name;
+
+    UINT16          manufacturer;
+    UINT16          lmp_subversion;
+    UINT16          link_super_tout;
+    BD_FEATURES     peer_lmp_features[HCI_EXT_FEATURES_PAGE_MAX + 1];    /* Peer LMP Extended features mask table for the device */
+    UINT8           num_read_pages;
+    UINT8           lmp_version;
+
+    BOOLEAN         in_use;
+    UINT8           link_role;
+    BOOLEAN         link_up_issued;     /* True if busy_level link up has been issued */
+
+#define BTM_ACL_SWKEY_STATE_IDLE                0
+#define BTM_ACL_SWKEY_STATE_MODE_CHANGE         1
+#define BTM_ACL_SWKEY_STATE_ENCRYPTION_OFF      2
+#define BTM_ACL_SWKEY_STATE_SWITCHING           3
+#define BTM_ACL_SWKEY_STATE_ENCRYPTION_ON       4
+#define BTM_ACL_SWKEY_STATE_IN_PROGRESS         5
+    UINT8           switch_role_state;
+#define BTM_MAX_SW_ROLE_FAILED_ATTEMPTS         3
+    UINT8           switch_role_failed_attempts;
+
+#define BTM_ACL_ENCRYPT_STATE_IDLE              0
+#define BTM_ACL_ENCRYPT_STATE_ENCRYPT_OFF       1   /* encryption turning off */
+#define BTM_ACL_ENCRYPT_STATE_TEMP_FUNC         2   /* temporarily off for change link key or role switch */
+#define BTM_ACL_ENCRYPT_STATE_ENCRYPT_ON        3   /* encryption turning on */
+    UINT8           encrypt_state;                  /* overall BTM encryption state */
+
+#if BLE_INCLUDED == TRUE
+    tBT_TRANSPORT   transport;
+    BD_ADDR         conn_addr;              /* local device address used for this connection */
+    UINT8           conn_addr_type;         /* local device address type for this connection */
+    BD_ADDR         active_remote_addr;     /* remote address used on this connection */
+    UINT8           active_remote_addr_type;         /* local device address type for this connection */
+    BD_FEATURES     peer_le_features;       /* Peer LE Used features mask for the device */
+
+#endif
+
+} tACL_CONN;
+
+/* Define the Device Management control structure
+*/
+typedef struct
+{
+    tBTM_DEV_STATUS_CB  *p_dev_status_cb;   /* Device status change callback        */
+    tBTM_VS_EVT_CB      *p_vend_spec_cb[BTM_MAX_VSE_CALLBACKS];     /* Register for vendor specific events  */
+
+    tBTM_CMPL_CB        *p_stored_link_key_cmpl_cb;   /* Read/Write/Delete stored link key    */
+
+    alarm_t             *read_local_name_timer; /* Read local name timer */
+    tBTM_CMPL_CB        *p_rln_cmpl_cb;     /* Callback function to be called when  */
+                                            /* read local name function complete    */
+    alarm_t             *read_rssi_timer;   /* Read RSSI timer */
+    tBTM_CMPL_CB        *p_rssi_cmpl_cb;    /* Callback function to be called when  */
+                                            /* read RSSI function completes */
+    alarm_t             *read_link_quality_timer;
+    tBTM_CMPL_CB        *p_link_qual_cmpl_cb; /* Callback function to be called when  */
+                                            /* read link quality function completes */
+
+    alarm_t             *read_inq_tx_power_timer;
+    tBTM_CMPL_CB        *p_inq_tx_power_cmpl_cb; /* Callback function to be called when  */
+                                            /* read inq tx power function completes  */
+
+    alarm_t             *qos_setup_timer;   /* QoS setup timer */
+    tBTM_CMPL_CB        *p_qos_setup_cmpl_cb; /* Callback function to be called when  */
+                                            /* qos setup function completes         */
+
+    tBTM_ROLE_SWITCH_CMPL switch_role_ref_data;
+    tBTM_CMPL_CB        *p_switch_role_cb;  /* Callback function to be called when  */
+                                            /* requested switch role is completed   */
+
+    alarm_t             *read_tx_power_timer; /* Read tx power timer */
+    tBTM_CMPL_CB        *p_tx_power_cmpl_cb;/* Callback function to be called       */
+
+    DEV_CLASS            dev_class;         /* Local device class                   */
+
+#if BLE_INCLUDED == TRUE
+
+    tBTM_CMPL_CB        *p_le_test_cmd_cmpl_cb;   /* Callback function to be called when
+                                                  LE test mode command has been sent successfully */
+
+    BD_ADDR                 read_tx_pwr_addr;   /* read TX power target address     */
+
+#define BTM_LE_SUPPORT_STATE_SIZE   8
+UINT8                   le_supported_states[BTM_LE_SUPPORT_STATE_SIZE];
+
+tBTM_BLE_LOCAL_ID_KEYS id_keys; /* local BLE ID keys */
+BT_OCTET16 ble_encryption_key_value; /* BLE encryption key */
+
+#if BTM_BLE_CONFORMANCE_TESTING == TRUE
+    BOOLEAN                 no_disc_if_pair_fail;
+    BOOLEAN                 enable_test_mac_val;
+    BT_OCTET8               test_mac;
+    BOOLEAN                 enable_test_local_sign_cntr;
+    UINT32                  test_local_sign_cntr;
+#endif
+
+#endif  /* BLE_INCLUDED */
+
+#if HCI_RAW_CMD_INCLUDED == TRUE
+    tBTM_RAW_CMPL_CB     *p_hci_evt_cb;       /* Callback function to be called when
+                                                HCI event is received successfully */
+#endif
+
+    tBTM_IO_CAP          loc_io_caps;       /* IO capability of the local device */
+    tBTM_AUTH_REQ        loc_auth_req;      /* the auth_req flag  */
+    BOOLEAN              secure_connections_only;    /* Rejects service level 0 connections if */
+                                                     /* itself or peer device doesn't support */
+                                                     /* secure connections */
+} tBTM_DEVCB;
+
+
+/* Define the structures and constants used for inquiry
+*/
+
+/* Definitions of limits for inquiries */
+#define BTM_PER_INQ_MIN_MAX_PERIOD      HCI_PER_INQ_MIN_MAX_PERIOD
+#define BTM_PER_INQ_MAX_MAX_PERIOD      HCI_PER_INQ_MAX_MAX_PERIOD
+#define BTM_PER_INQ_MIN_MIN_PERIOD      HCI_PER_INQ_MIN_MIN_PERIOD
+#define BTM_PER_INQ_MAX_MIN_PERIOD      HCI_PER_INQ_MAX_MIN_PERIOD
+#define BTM_MAX_INQUIRY_LENGTH          HCI_MAX_INQUIRY_LENGTH
+#define BTM_MIN_INQUIRY_LEN             0x01
+
+#define BTM_MIN_INQ_TX_POWER    -70
+#define BTM_MAX_INQ_TX_POWER    20
+
+typedef struct
+{
+    UINT32          inq_count;          /* Used for determining if a response has already been      */
+                                        /* received for the current inquiry operation. (We do not   */
+                                        /* want to flood the caller with multiple responses from    */
+                                        /* the same device.                                         */
+    BD_ADDR         bd_addr;
+} tINQ_BDADDR;
+
+typedef struct
+{
+    UINT32          time_of_resp;
+    UINT32          inq_count;          /* "timestamps" the entry with a particular inquiry count   */
+                                        /* Used for determining if a response has already been      */
+                                        /* received for the current inquiry operation. (We do not   */
+                                        /* want to flood the caller with multiple responses from    */
+                                        /* the same device.                                         */
+    tBTM_INQ_INFO   inq_info;
+    BOOLEAN         in_use;
+
+#if (BLE_INCLUDED == TRUE)
+    BOOLEAN         scan_rsp;
+#endif
+} tINQ_DB_ENT;
+
+
+enum
+{
+    INQ_NONE,
+    INQ_LE_OBSERVE,
+    INQ_GENERAL
+};
+typedef UINT8 tBTM_INQ_TYPE;
+
+typedef struct
+{
+    tBTM_CMPL_CB *p_remname_cmpl_cb;
+
+#define BTM_EXT_RMT_NAME_TIMEOUT_MS (40 * 1000) /* 40 seconds */
+
+
+    alarm_t         *remote_name_timer;
+
+    UINT16           discoverable_mode;
+    UINT16           connectable_mode;
+    UINT16           page_scan_window;
+    UINT16           page_scan_period;
+    UINT16           inq_scan_window;
+    UINT16           inq_scan_period;
+    UINT16           inq_scan_type;
+    UINT16           page_scan_type;        /* current page scan type */
+    tBTM_INQ_TYPE    scan_type;
+
+    BD_ADDR          remname_bda;           /* Name of bd addr for active remote name request */
+#define BTM_RMT_NAME_INACTIVE       0
+#define BTM_RMT_NAME_EXT            0x1     /* Initiated through API */
+#define BTM_RMT_NAME_SEC            0x2     /* Initiated internally by security manager */
+#define BTM_RMT_NAME_INQ            0x4     /* Remote name initiated internally by inquiry */
+    BOOLEAN          remname_active;        /* State of a remote name request by external API */
+
+    tBTM_CMPL_CB    *p_inq_cmpl_cb;
+    tBTM_INQ_RESULTS_CB *p_inq_results_cb;
+    tBTM_CMPL_CB    *p_inq_ble_cmpl_cb;     /*completion callback exclusively for LE Observe*/
+    tBTM_INQ_RESULTS_CB *p_inq_ble_results_cb;/*results callback exclusively for LE observe*/
+    tBTM_CMPL_CB    *p_inqfilter_cmpl_cb;   /* Called (if not NULL) after inquiry filter completed */
+    UINT32           inq_counter;           /* Counter incremented each time an inquiry completes */
+                                            /* Used for determining whether or not duplicate devices */
+                                            /* have responded to the same inquiry */
+    tINQ_BDADDR     *p_bd_db;               /* Pointer to memory that holds bdaddrs */
+    UINT16           num_bd_entries;        /* Number of entries in database */
+    UINT16           max_bd_entries;        /* Maximum number of entries that can be stored */
+    tINQ_DB_ENT      inq_db[BTM_INQ_DB_SIZE];
+    tBTM_INQ_PARMS   inqparms;              /* Contains the parameters for the current inquiry */
+    tBTM_INQUIRY_CMPL inq_cmpl_info;        /* Status and number of responses from the last inquiry */
+
+    UINT16           per_min_delay;         /* Current periodic minimum delay */
+    UINT16           per_max_delay;         /* Current periodic maximum delay */
+    BOOLEAN          inqfilt_active;
+    UINT8            pending_filt_complete_event; /* to take care of btm_event_filter_complete corresponding to */
+                                                  /* inquiry that has been cancelled*/
+    UINT8            inqfilt_type;          /* Contains the inquiry filter type (BD ADDR, COD, or Clear) */
+
+#define BTM_INQ_INACTIVE_STATE      0
+#define BTM_INQ_CLR_FILT_STATE      1   /* Currently clearing the inquiry filter preceeding the inquiry request */
+                                        /* (bypassed if filtering is not used)                                  */
+#define BTM_INQ_SET_FILT_STATE      2   /* Sets the new filter (or turns off filtering) in this state */
+#define BTM_INQ_ACTIVE_STATE        3   /* Actual inquiry or periodic inquiry is in progress */
+#define BTM_INQ_REMNAME_STATE       4   /* Remote name requests are active  */
+
+    UINT8            state;             /* Current state that the inquiry process is in */
+    UINT8            inq_active;        /* Bit Mask indicating type of inquiry is active */
+    BOOLEAN          no_inc_ssp;        /* TRUE, to stop inquiry on incoming SSP */
+#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
+    btm_inq_state    next_state;        /*interleaving state to determine next mode to be inquired*/
+#endif
+} tBTM_INQUIRY_VAR_ST;
+
+/* The MSB of the clock offset field indicates that the offset is valid if TRUE */
+#define BTM_CLOCK_OFFSET_VALID      0x8000
+
+/* Define the structures needed by security management
+*/
+
+#define BTM_SEC_INVALID_HANDLE  0xFFFF
+
+typedef UINT8 *BTM_BD_NAME_PTR;                        /* Pointer to Device name */
+
+/* Security callback is called by this unit when security
+**   procedures are completed.  Parameters are
+**              BD Address of remote
+**              Result of the operation
+*/
+typedef tBTM_SEC_CBACK tBTM_SEC_CALLBACK;
+
+typedef void (tBTM_SCO_IND_CBACK) (UINT16 sco_inx) ;
+
+/* MACROs to convert from SCO packet types mask to ESCO and back */
+#define BTM_SCO_PKT_TYPE_MASK   (   HCI_PKT_TYPES_MASK_HV1      \
+                                 |  HCI_PKT_TYPES_MASK_HV2      \
+                                 |  HCI_PKT_TYPES_MASK_HV3)
+
+/* Mask defining only the SCO types of an esco packet type */
+#define BTM_ESCO_PKT_TYPE_MASK  (   HCI_ESCO_PKT_TYPES_MASK_HV1 \
+                                 |  HCI_ESCO_PKT_TYPES_MASK_HV2 \
+                                 |  HCI_ESCO_PKT_TYPES_MASK_HV3)
+
+#define BTM_SCO_2_ESCO(scotype)  ((UINT16)(((scotype) & BTM_SCO_PKT_TYPE_MASK) >> 5))
+#define BTM_ESCO_2_SCO(escotype) ((UINT16)(((escotype) & BTM_ESCO_PKT_TYPE_MASK) << 5))
+
+/* Define masks for supported and exception 2.0 SCO packet types
+*/
+#define BTM_SCO_SUPPORTED_PKTS_MASK      (HCI_ESCO_PKT_TYPES_MASK_HV1       | \
+                                          HCI_ESCO_PKT_TYPES_MASK_HV2       | \
+                                          HCI_ESCO_PKT_TYPES_MASK_HV3       | \
+                                          HCI_ESCO_PKT_TYPES_MASK_EV3       | \
+                                          HCI_ESCO_PKT_TYPES_MASK_EV4       | \
+                                          HCI_ESCO_PKT_TYPES_MASK_EV5)
+
+#define BTM_SCO_EXCEPTION_PKTS_MASK      (HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3  | \
+                                          HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3  | \
+                                          HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5  | \
+                                          HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5)
+
+
+#define BTM_SCO_ROUTE_UNKNOWN       0xff
+
+/* Define the structure that contains (e)SCO data */
+typedef struct
+{
+    tBTM_ESCO_CBACK    *p_esco_cback;   /* Callback for eSCO events     */
+    tBTM_ESCO_PARAMS    setup;
+    tBTM_ESCO_DATA      data;           /* Connection complete information */
+    UINT8               hci_status;
+} tBTM_ESCO_INFO;
+
+/* Define the structure used for SCO Management
+*/
+typedef struct
+{
+    tBTM_ESCO_INFO   esco;              /* Current settings             */
+#if BTM_SCO_HCI_INCLUDED == TRUE
+    fixed_queue_t   *xmit_data_q;       /* SCO data transmitting queue  */
+#endif
+    tBTM_SCO_CB     *p_conn_cb;         /* Callback for when connected  */
+    tBTM_SCO_CB     *p_disc_cb;         /* Callback for when disconnect */
+    UINT16           state;             /* The state of the SCO link    */
+    UINT16           hci_handle;        /* HCI Handle                   */
+    BOOLEAN          is_orig;           /* TRUE if the originator       */
+    BOOLEAN          rem_bd_known;      /* TRUE if remote BD addr known */
+
+} tSCO_CONN;
+
+/* SCO Management control block */
+typedef struct
+{
+    tBTM_SCO_IND_CBACK  *app_sco_ind_cb;
+#if BTM_SCO_HCI_INCLUDED == TRUE
+    tBTM_SCO_DATA_CB     *p_data_cb;        /* Callback for SCO data over HCI */
+    UINT32               xmit_window_size; /* Total SCO window in bytes  */
+#endif
+    tSCO_CONN            sco_db[BTM_MAX_SCO_LINKS];
+    tBTM_ESCO_PARAMS     def_esco_parms;
+    BD_ADDR              xfer_addr;
+    UINT16               sco_disc_reason;
+    BOOLEAN              esco_supported;    /* TRUE if 1.2 cntlr AND supports eSCO links */
+    tBTM_SCO_TYPE        desired_sco_mode;
+    tBTM_SCO_TYPE        xfer_sco_type;
+    tBTM_SCO_PCM_PARAM   sco_pcm_param;
+    tBTM_SCO_CODEC_TYPE  codec_in_use;      /* None, CVSD, MSBC, etc. */
+#if BTM_SCO_HCI_INCLUDED == TRUE
+    tBTM_SCO_ROUTE_TYPE  sco_path;
+#endif
+
+} tSCO_CB;
+
+
+#if BTM_SCO_INCLUDED == TRUE
+extern void     btm_set_sco_ind_cback( tBTM_SCO_IND_CBACK *sco_ind_cb );
+extern void     btm_accept_sco_link(UINT16 sco_inx, tBTM_ESCO_PARAMS *p_setup,
+                                    tBTM_SCO_CB *p_conn_cb, tBTM_SCO_CB *p_disc_cb);
+extern void     btm_reject_sco_link(UINT16 sco_inx );
+extern void btm_sco_chk_pend_rolechange (UINT16 hci_handle);
+extern void btm_sco_disc_chk_pend_for_modechange (UINT16 hci_handle);
+
+#else
+#define btm_accept_sco_link(sco_inx, p_setup, p_conn_cb, p_disc_cb)
+#define btm_reject_sco_link(sco_inx)
+#define btm_set_sco_ind_cback(sco_ind_cb)
+#define btm_sco_chk_pend_rolechange(hci_handle)
+#endif  /* BTM_SCO_INCLUDED */
+
+/*
+** Define structure for Security Service Record.
+** A record exists for each service registered with the Security Manager
+*/
+#define BTM_SEC_OUT_FLAGS   (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHORIZE)
+#define BTM_SEC_IN_FLAGS    (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHORIZE)
+
+#define BTM_SEC_OUT_LEVEL4_FLAGS   (BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT | \
+                                    BTM_SEC_OUT_MITM | BTM_SEC_MODE4_LEVEL4)
+
+#define BTM_SEC_IN_LEVEL4_FLAGS    (BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_ENCRYPT | \
+                                    BTM_SEC_IN_MITM | BTM_SEC_MODE4_LEVEL4)
+typedef struct
+{
+    UINT32          mx_proto_id;        /* Service runs over this multiplexer protocol */
+    UINT32          orig_mx_chan_id;    /* Channel on the multiplexer protocol    */
+    UINT32          term_mx_chan_id;    /* Channel on the multiplexer protocol    */
+    UINT16          psm;                /* L2CAP PSM value */
+    UINT16          security_flags;     /* Bitmap of required security features */
+    UINT8           service_id;         /* Passed in authorization callback */
+#if (L2CAP_UCD_INCLUDED == TRUE)
+    UINT16          ucd_security_flags; /* Bitmap of required security features for UCD */
+#endif
+#if BTM_SEC_SERVICE_NAME_LEN > 0
+    UINT8           orig_service_name[BTM_SEC_SERVICE_NAME_LEN + 1];
+    UINT8           term_service_name[BTM_SEC_SERVICE_NAME_LEN + 1];
+#endif
+} tBTM_SEC_SERV_REC;
+
+#if BLE_INCLUDED == TRUE
+/* LE Security information of device in Slave Role */
+typedef struct
+{
+    BT_OCTET16          irk;            /* peer diverified identity root */
+    BT_OCTET16          pltk;           /* peer long term key */
+    BT_OCTET16          pcsrk;          /* peer SRK peer device used to secured sign local data  */
+
+    BT_OCTET16          lltk;           /* local long term key */
+    BT_OCTET16          lcsrk;          /* local SRK peer device used to secured sign local data  */
+
+    BT_OCTET8           rand;           /* random vector for LTK generation */
+    UINT16              ediv;           /* LTK diversifier of this slave device */
+    UINT16              div;            /* local DIV  to generate local LTK=d1(ER,DIV,0) and CSRK=d1(ER,DIV,1)  */
+    UINT8               sec_level;      /* local pairing security level */
+    UINT8               key_size;       /* key size of the LTK delivered to peer device */
+    UINT8               srk_sec_level;  /* security property of peer SRK for this device */
+    UINT8               local_csrk_sec_level;  /* security property of local CSRK for this device */
+
+    UINT32              counter;        /* peer sign counter for verifying rcv signed cmd */
+    UINT32              local_counter;  /* local sign counter for sending signed write cmd*/
+}tBTM_SEC_BLE_KEYS;
+
+typedef struct
+{
+    BD_ADDR pseudo_addr; /* LE pseudo address of the device if different from device address  */
+    tBLE_ADDR_TYPE      ble_addr_type;  /* LE device type: public or random address */
+    tBLE_ADDR_TYPE      static_addr_type;   /* static address type */
+    BD_ADDR             static_addr;    /* static address */
+
+#define BTM_WHITE_LIST_BIT          0x01
+#define BTM_RESOLVING_LIST_BIT      0x02
+    UINT8               in_controller_list;   /* in controller resolving list or not */
+    UINT8               resolving_list_index;
+#if BLE_PRIVACY_SPT == TRUE
+    BD_ADDR             cur_rand_addr;  /* current random address */
+
+#define BTM_BLE_ADDR_PSEUDO         0   /* address index device record */
+#define BTM_BLE_ADDR_RRA            1   /* cur_rand_addr */
+#define BTM_BLE_ADDR_STATIC         2   /* static_addr  */
+    UINT8               active_addr_type;
+#endif
+
+#if SMP_INCLUDED == TRUE
+    tBTM_LE_KEY_TYPE    key_type;       /* bit mask of valid key types in record */
+    tBTM_SEC_BLE_KEYS   keys;           /* LE device security info in slave rode */
+#endif
+} tBTM_SEC_BLE;
+
+
+#endif  /* BLE_INCLUDED */
+
+/* Peering bond type */
+enum
+{
+    BOND_TYPE_UNKNOWN,
+    BOND_TYPE_PERSISTENT,
+    BOND_TYPE_TEMPORARY
+};
+typedef UINT8 tBTM_BOND_TYPE;
+
+/*
+** Define structure for Security Device Record.
+** A record exists for each device authenticated with this device
+*/
+typedef struct
+{
+    tBTM_SEC_SERV_REC   *p_cur_service;
+    tBTM_SEC_CALLBACK   *p_callback;
+    void                *p_ref_data;
+    UINT32               timestamp;         /* Timestamp of the last connection   */
+    UINT32               trusted_mask[BTM_SEC_SERVICE_ARRAY_SIZE];  /* Bitwise OR of trusted services     */
+    UINT16               hci_handle;        /* Handle to connection when exists   */
+    UINT16               clock_offset;      /* Latest known clock offset          */
+    BD_ADDR              bd_addr;           /* BD_ADDR of the device              */
+    DEV_CLASS            dev_class;         /* DEV_CLASS of the device            */
+    LINK_KEY             link_key;          /* Device link key                    */
+    UINT8                pin_code_length;   /* Length of the pin_code used for paring */
+
+#define BTM_SEC_AUTHORIZED      BTM_SEC_FLAG_AUTHORIZED     /* 0x01 */
+#define BTM_SEC_AUTHENTICATED   BTM_SEC_FLAG_AUTHENTICATED  /* 0x02 */
+#define BTM_SEC_ENCRYPTED       BTM_SEC_FLAG_ENCRYPTED      /* 0x04 */
+#define BTM_SEC_NAME_KNOWN      0x08
+#define BTM_SEC_LINK_KEY_KNOWN  BTM_SEC_FLAG_LKEY_KNOWN /* 0x10 */
+#define BTM_SEC_LINK_KEY_AUTHED BTM_SEC_FLAG_LKEY_AUTHED    /* 0x20 */
+#define BTM_SEC_ROLE_SWITCHED   0x40
+#define BTM_SEC_IN_USE          0x80
+    /* LE link security flag */
+#define BTM_SEC_LE_AUTHENTICATED   0x0200   /* LE link is encrypted after pairing with MITM */
+#define BTM_SEC_LE_ENCRYPTED       0x0400   /* LE link is encrypted */
+#define BTM_SEC_LE_NAME_KNOWN      0x0800   /* not used */
+#define BTM_SEC_LE_LINK_KEY_KNOWN  0x1000   /* bonded with peer (peer LTK and/or SRK is saved) */
+#define BTM_SEC_LE_LINK_KEY_AUTHED 0x2000   /* pairing is done with MITM */
+#define BTM_SEC_16_DIGIT_PIN_AUTHED 0x4000   /* pairing is done with 16 digit pin */
+
+    UINT16           sec_flags;          /* Current device security state      */
+
+    tBTM_BD_NAME    sec_bd_name;        /* User friendly name of the device. (may be truncated to save space in dev_rec table) */
+    BD_FEATURES     features[HCI_EXT_FEATURES_PAGE_MAX + 1];           /* Features supported by the device */
+    UINT8           num_read_pages;
+    UINT8           rnr_retry_cnt;
+    UINT8           cc_retry_cnt;
+
+#define BTM_SEC_STATE_IDLE               0
+#define BTM_SEC_STATE_AUTHENTICATING     1
+#define BTM_SEC_STATE_ENCRYPTING         2
+#define BTM_SEC_STATE_GETTING_NAME       3
+#define BTM_SEC_STATE_AUTHORIZING        4
+#define BTM_SEC_STATE_SWITCHING_ROLE     5
+#define BTM_SEC_STATE_DISCONNECTING      6 /* disconnecting BR/EDR */
+#define BTM_SEC_STATE_DELAY_FOR_ENC      7 /* delay to check for encryption to work around */
+                                           /* controller problems */
+#define BTM_SEC_STATE_DISCONNECTING_BLE  8 /* disconnecting BLE */
+#define BTM_SEC_STATE_DISCONNECTING_BOTH 9 /* disconnecting BR/EDR and BLE */
+
+    UINT8       sec_state;              /* Operating state                    */
+    BOOLEAN     is_originator;          /* TRUE if device is originating connection */
+#if (L2CAP_UCD_INCLUDED == TRUE)
+    BOOLEAN     is_ucd;                 /* TRUE if device is sending or receiving UCD */
+                                        /* if incoming security failed, received UCD will be discarded */
+#endif
+    BOOLEAN     role_master;            /* TRUE if current mode is master     */
+    UINT16      security_required;      /* Security required for connection   */
+    BOOLEAN     link_key_not_sent;      /* link key notification has not been sent waiting for name */
+    UINT8       link_key_type;          /* Type of key used in pairing   */
+    BOOLEAN     link_key_changed;       /* Changed link key during current connection */
+
+#define BTM_MAX_PRE_SM4_LKEY_TYPE   BTM_LKEY_TYPE_REMOTE_UNIT /* the link key type used by legacy pairing */
+
+#define BTM_SM4_UNKNOWN     0x00
+#define BTM_SM4_KNOWN       0x10
+#define BTM_SM4_TRUE        0x11
+#define BTM_SM4_REQ_PEND    0x08        /* set this bit when getting remote features */
+#define BTM_SM4_UPGRADE     0x04        /* set this bit when upgrading link key */
+#define BTM_SM4_RETRY       0x02        /* set this bit to retry on HCI_ERR_KEY_MISSING or HCI_ERR_LMP_ERR_TRANS_COLLISION */
+#define BTM_SM4_DD_ACP      0x20        /* set this bit to indicate peer initiated dedicated bonding */
+#define BTM_SM4_CONN_PEND   0x40        /* set this bit to indicate accepting acl conn; to be cleared on btm_acl_created */
+    UINT8       sm4;                    /* BTM_SM4_TRUE, if the peer supports SM4 */
+    tBTM_IO_CAP rmt_io_caps;            /* IO capability of the peer device */
+    tBTM_AUTH_REQ rmt_auth_req;         /* the auth_req flag as in the IO caps rsp evt */
+    BOOLEAN     remote_supports_secure_connections;
+    BOOLEAN     remote_features_needed; /* set to true if the local device is in */
+                                        /* "Secure Connections Only" mode and it receives */
+                                        /* HCI_IO_CAPABILITY_REQUEST_EVT from the peer before */
+                                        /* it knows peer's support for Secure Connections */
+
+    UINT16              ble_hci_handle;         /* use in DUMO connection */
+    UINT8               enc_key_size;           /* current link encryption key size */
+    tBT_DEVICE_TYPE     device_type;
+    BOOLEAN             new_encryption_key_is_p256; /* Set to TRUE when the newly generated LK
+                                                    ** is generated from P-256.
+                                                    ** Link encrypted with such LK can be used
+                                                    ** for SM over BR/EDR.
+                                                    */
+    BOOLEAN no_smp_on_br;       /* if set to TRUE then SMP on BR/EDR doesn't */
+                                /* work, i.e. link keys crosspairing */
+                                /* SC BR/EDR->SC LE doesn't happen */
+    tBTM_BOND_TYPE bond_type;   /* peering bond type */
+
+#if BLE_INCLUDED == TRUE
+    tBTM_SEC_BLE        ble;
+    tBTM_LE_CONN_PRAMS  conn_params;
+#endif
+
+#if BTM_DISC_DURING_RS == TRUE
+#define BTM_SEC_RS_NOT_PENDING          0           /* Role Switch not in progress */
+#define BTM_SEC_RS_PENDING              1           /* Role Switch in progress */
+#define BTM_SEC_DISC_PENDING            2           /* Disconnect is pending */
+    UINT8           rs_disc_pending;
+#endif
+#define BTM_SEC_NO_LAST_SERVICE_ID      0
+    UINT8           last_author_service_id;         /* ID of last serviced authorized: Reset after each l2cap connection */
+
+#if (defined(BTM_SAFE_REATTEMPT_ROLE_SWITCH) && BTM_SAFE_REATTEMPT_ROLE_SWITCH == TRUE)
+#define BTM_MAX_BL_SW_ROLE_ATTEMPTS     1
+    UINT8           switch_role_attempts;
+#endif
+
+} tBTM_SEC_DEV_REC;
+
+#define BTM_SEC_IS_SM4(sm) ((BOOLEAN)(BTM_SM4_TRUE == ((sm)&BTM_SM4_TRUE)))
+#define BTM_SEC_IS_SM4_LEGACY(sm) ((BOOLEAN)(BTM_SM4_KNOWN == ((sm)&BTM_SM4_TRUE)))
+#define BTM_SEC_IS_SM4_UNKNOWN(sm) ((BOOLEAN)(BTM_SM4_UNKNOWN == ((sm)&BTM_SM4_TRUE)))
+
+#define BTM_SEC_LE_MASK    (BTM_SEC_LE_AUTHENTICATED|BTM_SEC_LE_ENCRYPTED|BTM_SEC_LE_LINK_KEY_KNOWN|BTM_SEC_LE_LINK_KEY_AUTHED)
+
+/*
+** Define device configuration structure
+*/
+typedef struct
+{
+#if BTM_MAX_LOC_BD_NAME_LEN > 0
+    tBTM_LOC_BD_NAME bd_name;                    /* local Bluetooth device name */
+#endif
+    BOOLEAN          pin_type;                   /* TRUE if PIN type is fixed */
+    UINT8            pin_code_len;               /* Bonding information */
+    PIN_CODE         pin_code;                   /* PIN CODE if pin type is fixed */
+    BOOLEAN          connectable;                /* If TRUE page scan should be enabled */
+    UINT8            def_inq_scan_mode;          /* ??? limited/general/none */
+} tBTM_CFG;
+
+enum
+{
+    BTM_PM_ST_ACTIVE  = BTM_PM_STS_ACTIVE,
+    BTM_PM_ST_HOLD    = BTM_PM_STS_HOLD,
+    BTM_PM_ST_SNIFF   = BTM_PM_STS_SNIFF,
+    BTM_PM_ST_PARK    = BTM_PM_STS_PARK,
+    BTM_PM_ST_PENDING = BTM_PM_STS_PENDING,
+    BTM_PM_ST_INVALID = 0xFF
+};
+typedef UINT8 tBTM_PM_STATE;
+
+enum
+{
+    BTM_PM_SET_MODE_EVT,    /* Set power mode API is called. */
+    BTM_PM_UPDATE_EVT,
+    BTM_PM_RD_MODE_EVT     /* Read power mode API is called. */
+};
+typedef UINT8 tBTM_PM_EVENT;
+
+typedef struct
+{
+    UINT16          event;
+    UINT16          len;
+    UINT8           link_ind;
+} tBTM_PM_MSG_DATA;
+
+typedef struct
+{
+    UINT8 hci_status;
+    UINT8 mode;
+    UINT16 interval;
+} tBTM_PM_MD_CHG_DATA;
+
+typedef struct
+{
+    UINT8          pm_id;      /* the entity that calls SetPowerMode API */
+    tBTM_PM_PWR_MD *p_pmd;
+} tBTM_PM_SET_MD_DATA;
+
+typedef struct
+{
+    void        *p_data;
+    UINT8        link_ind;
+} tBTM_PM_SM_DATA;
+
+typedef struct
+{
+    tBTM_PM_PWR_MD req_mode[BTM_MAX_PM_RECORDS+1]; /* the desired mode and parameters of the connection*/
+    tBTM_PM_PWR_MD set_mode;  /* the mode and parameters sent down to the host controller. */
+    UINT16         interval;  /* the interval from last mode change event. */
+#if (BTM_SSR_INCLUDED == TRUE)
+    UINT16         max_lat;   /* stored SSR maximum latency */
+    UINT16         min_rmt_to;/* stored SSR minimum remote timeout */
+    UINT16         min_loc_to;/* stored SSR minimum local timeout */
+#endif
+    tBTM_PM_STATE  state;     /* contains the current mode of the connection */
+    BOOLEAN        chg_ind;   /* a request change indication */
+} tBTM_PM_MCB;
+
+#define BTM_PM_REC_NOT_USED 0
+typedef struct
+{
+    tBTM_PM_STATUS_CBACK *cback;/* to notify the registered party of mode change event */
+    UINT8                 mask; /* registered request mask. 0, if this entry is not used */
+} tBTM_PM_RCB;
+
+enum
+{
+    BTM_BLI_ACL_UP_EVT,
+    BTM_BLI_ACL_DOWN_EVT,
+    BTM_BLI_PAGE_EVT,
+    BTM_BLI_PAGE_DONE_EVT,
+    BTM_BLI_INQ_EVT,
+    BTM_BLI_INQ_CANCEL_EVT,
+    BTM_BLI_INQ_DONE_EVT
+};
+typedef UINT8 tBTM_BLI_EVENT;
+
+/* Pairing State */
+enum
+{
+    BTM_PAIR_STATE_IDLE,                        /* Idle                                         */
+    BTM_PAIR_STATE_GET_REM_NAME,                /* Getting the remote name (to check for SM4)   */
+    BTM_PAIR_STATE_WAIT_PIN_REQ,                /* Started authentication, waiting for PIN req (PIN is pre-fetched) */
+    BTM_PAIR_STATE_WAIT_LOCAL_PIN,              /* Waiting for local PIN code                   */
+    BTM_PAIR_STATE_WAIT_NUMERIC_CONFIRM,        /* Waiting user 'yes' to numeric confirmation   */
+    BTM_PAIR_STATE_KEY_ENTRY,                   /* Key entry state (we are a keyboard)          */
+    BTM_PAIR_STATE_WAIT_LOCAL_OOB_RSP,          /* Waiting for local response to peer OOB data  */
+    BTM_PAIR_STATE_WAIT_LOCAL_IOCAPS,           /* Waiting for local IO capabilities and OOB data */
+    BTM_PAIR_STATE_INCOMING_SSP,                /* Incoming SSP (got peer IO caps when idle)    */
+    BTM_PAIR_STATE_WAIT_AUTH_COMPLETE,          /* All done, waiting authentication cpmplete    */
+    BTM_PAIR_STATE_WAIT_DISCONNECT              /* Waiting to disconnect the ACL                */
+};
+typedef UINT8 tBTM_PAIRING_STATE;
+
+#define BTM_PAIR_FLAGS_WE_STARTED_DD    0x01    /* We want to do dedicated bonding              */
+#define BTM_PAIR_FLAGS_PEER_STARTED_DD  0x02    /* Peer initiated dedicated bonding             */
+#define BTM_PAIR_FLAGS_DISC_WHEN_DONE   0x04    /* Disconnect when done     */
+#define BTM_PAIR_FLAGS_PIN_REQD         0x08    /* set this bit when pin_callback is called     */
+#define BTM_PAIR_FLAGS_PRE_FETCH_PIN    0x10    /* set this bit when pre-fetch pin     */
+#define BTM_PAIR_FLAGS_REJECTED_CONNECT 0x20    /* set this bit when rejected incoming connection  */
+#define BTM_PAIR_FLAGS_WE_CANCEL_DD     0x40    /* set this bit when cancelling a bonding procedure */
+#define BTM_PAIR_FLAGS_LE_ACTIVE        0x80    /* use this bit when SMP pairing is active */
+
+
+typedef struct
+{
+    BOOLEAN             is_mux;
+    BD_ADDR             bd_addr;
+    UINT16              psm;
+    BOOLEAN             is_orig;
+    tBTM_SEC_CALLBACK   *p_callback;
+    void                *p_ref_data;
+    UINT32              mx_proto_id;
+    UINT32              mx_chan_id;
+    tBT_TRANSPORT       transport;
+    tBTM_BLE_SEC_ACT    sec_act;
+} tBTM_SEC_QUEUE_ENTRY;
+
+#if (L2CAP_UCD_INCLUDED == TRUE)
+
+#define CONN_ORIENT_TERM                0x00    /* incoming connection oriented */
+#define CONN_ORIENT_ORIG                0x01    /* outgoing connection oriented */
+#define CONNLESS_TERM                   0x02    /* incoming connectionless      */
+#define CONNLESS_ORIG                   0x03    /* outgoing connectionless      */
+#define CONNECTION_TYPE_ORIG_MASK       0x01    /* mask for direction           */
+#define CONNECTION_TYPE_CONNLESS_MASK   0x02    /* mask for connectionless or not */
+typedef UINT8 CONNECTION_TYPE;
+
+#else
+
+#define CONN_ORIENT_TERM                FALSE
+#define CONN_ORIENT_ORIG                TRUE
+typedef BOOLEAN CONNECTION_TYPE;
+
+#endif /* (L2CAP_UCD_INCLUDED == TRUE) */
+
+/* Define a structure to hold all the BTM data
+*/
+
+#define BTM_STATE_BUFFER_SIZE  5                  /* size of state buffer */
+
+typedef struct
+{
+    tBTM_CFG    cfg;                        /* Device configuration */
+
+    /****************************************************
+    **      ACL Management
+    ****************************************************/
+    tACL_CONN   acl_db[MAX_L2CAP_LINKS];
+    UINT8       btm_scn[BTM_MAX_SCN];        /* current SCNs: TRUE if SCN is in use */
+    UINT16      btm_def_link_policy;
+    UINT16      btm_def_link_super_tout;
+
+    tBTM_BL_EVENT_MASK     bl_evt_mask;
+    tBTM_BL_CHANGE_CB     *p_bl_changed_cb;    /* Callback for when Busy Level changed */
+
+    /****************************************************
+    **      Power Management
+    ****************************************************/
+    tBTM_PM_MCB pm_mode_db[MAX_L2CAP_LINKS];   /* per ACL link */
+    tBTM_PM_RCB pm_reg_db[BTM_MAX_PM_RECORDS+1]; /* per application/module */
+    UINT8       pm_pend_link;  /* the index of acl_db, which has a pending PM cmd */
+    UINT8       pm_pend_id;    /* the id pf the module, which has a pending PM cmd */
+
+    /*****************************************************
+    **      Device control
+    *****************************************************/
+    tBTM_DEVCB  devcb;
+
+    /*****************************************************
+    **      BLE Device controllers
+    *****************************************************/
+#if (BLE_INCLUDED == TRUE)
+    tBTM_BLE_CB             ble_ctr_cb;
+
+    UINT16                  enc_handle;
+    BT_OCTET8               enc_rand;   /* received rand value from LTK request*/
+    UINT16                  ediv;       /* received ediv value from LTK request */
+    UINT8                   key_size;
+    tBTM_BLE_VSC_CB         cmn_ble_vsc_cb;
+#endif
+
+                                            /* Packet types supported by the local device */
+    UINT16      btm_acl_pkt_types_supported;
+    UINT16      btm_sco_pkt_types_supported;
+
+
+    /*****************************************************
+    **      Inquiry
+    *****************************************************/
+    tBTM_INQUIRY_VAR_ST     btm_inq_vars;
+
+    /*****************************************************
+    **      SCO Management
+    *****************************************************/
+#if BTM_SCO_INCLUDED == TRUE
+    tSCO_CB             sco_cb;
+#endif
+
+    /*****************************************************
+    **      Security Management
+    *****************************************************/
+    tBTM_APPL_INFO          api;
+
+#define BTM_SEC_MAX_RMT_NAME_CALLBACKS  2
+    tBTM_RMT_NAME_CALLBACK  *p_rmt_name_callback[BTM_SEC_MAX_RMT_NAME_CALLBACKS];
+
+    tBTM_SEC_DEV_REC        *p_collided_dev_rec;
+    alarm_t                 *sec_collision_timer;
+    tBTM_SEC_DEV_REC        *p_cc_retry_dev_rec;
+    UINT32                   collision_start_time;
+    UINT32                   max_collision_delay;
+    UINT32                   dev_rec_count;      /* Counter used for device record timestamp */
+    UINT8                    security_mode;
+    BOOLEAN                  pairing_disabled;
+    BOOLEAN                  connect_only_paired;
+    BOOLEAN                  security_mode_changed;  /* mode changed during bonding */
+    BOOLEAN                  pin_type_changed;       /* pin type changed during bonding */
+    BOOLEAN                  sec_req_pending;       /*   TRUE if a request is pending */
+
+    UINT8                    pin_code_len;  /* for legacy devices */
+    PIN_CODE                 pin_code;      /* for legacy devices */
+    tBTM_PAIRING_STATE       pairing_state; /* The current pairing state    */
+    UINT8                    pairing_flags; /* The current pairing flags    */
+    BD_ADDR                  pairing_bda;   /* The device currently pairing */
+    alarm_t                 *pairing_timer; /* Timer for pairing process    */
+    UINT16                   disc_handle;   /* for legacy devices */
+    UINT8                    disc_reason;   /* for legacy devices */
+    tBTM_SEC_SERV_REC        sec_serv_rec[BTM_SEC_MAX_SERVICE_RECORDS];
+    list_t                  *sec_dev_rec;   /* list of tBTM_SEC_DEV_REC */
+    tBTM_SEC_SERV_REC       *p_out_serv;
+    tBTM_MKEY_CALLBACK      *mkey_cback;
+
+    BD_ADDR                  connecting_bda;
+    DEV_CLASS                connecting_dc;
+
+    UINT8                   acl_disc_reason;
+    UINT8                   trace_level;
+    UINT8                   busy_level; /* the current busy level */
+    BOOLEAN                 is_paging;  /* TRUE, if paging is in progess */
+    BOOLEAN                 is_inquiry; /* TRUE, if inquiry is in progess */
+    fixed_queue_t          *page_queue;
+    BOOLEAN                 paging;
+    BOOLEAN                 discing;
+    fixed_queue_t          *sec_pending_q;  /* pending sequrity requests in tBTM_SEC_QUEUE_ENTRY format */
+
+#if  (!defined(BT_TRACE_VERBOSE) || (BT_TRACE_VERBOSE == FALSE))
+    char state_temp_buffer[BTM_STATE_BUFFER_SIZE];
+#endif
+} tBTM_CB;
+
+/* security action for L2CAP COC channels */
+#define BTM_SEC_OK                1
+#define BTM_SEC_ENCRYPT           2    /* encrypt the link with current key */
+#define BTM_SEC_ENCRYPT_NO_MITM   3    /* unauthenticated encryption or better */
+#define BTM_SEC_ENCRYPT_MITM      4    /* authenticated encryption */
+#define BTM_SEC_ENC_PENDING       5    /* wait for link encryption pending */
+
+typedef UINT8 tBTM_SEC_ACTION;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // BTM_INT_TYPES_H
diff --git a/stack/include/btm_api.h b/stack/include/btm_api.h
index f5e5d0215..29e4ea648 100644
--- a/stack/include/btm_api.h
+++ b/stack/include/btm_api.h
@@ -30,1885 +30,8 @@
 #include "hcidefs.h"
 
 #include "smp_api.h"
-/*****************************************************************************
-**  DEVICE CONTROL and COMMON
-*****************************************************************************/
-/*****************************
-**  Device Control Constants
-******************************/
-/* Maximum number of bytes allowed for vendor specific command parameters */
-#define BTM_MAX_VENDOR_SPECIFIC_LEN  HCI_COMMAND_SIZE
-
-/* BTM application return status codes */
-enum
-{
-    BTM_SUCCESS = 0,                    /* 0  Command succeeded                 */
-    BTM_CMD_STARTED,                    /* 1  Command started OK.               */
-    BTM_BUSY,                           /* 2  Device busy with another command  */
-    BTM_NO_RESOURCES,                   /* 3  No resources to issue command     */
-    BTM_MODE_UNSUPPORTED,               /* 4  Request for 1 or more unsupported modes */
-    BTM_ILLEGAL_VALUE,                  /* 5  Illegal parameter value           */
-    BTM_WRONG_MODE,                     /* 6  Device in wrong mode for request  */
-    BTM_UNKNOWN_ADDR,                   /* 7  Unknown remote BD address         */
-    BTM_DEVICE_TIMEOUT,                 /* 8  Device timeout                    */
-    BTM_BAD_VALUE_RET,                  /* 9  A bad value was received from HCI */
-    BTM_ERR_PROCESSING,                 /* 10 Generic error                     */
-    BTM_NOT_AUTHORIZED,                 /* 11 Authorization failed              */
-    BTM_DEV_RESET,                      /* 12 Device has been reset             */
-    BTM_CMD_STORED,                     /* 13 request is stored in control block */
-    BTM_ILLEGAL_ACTION,                 /* 14 state machine gets illegal command */
-    BTM_DELAY_CHECK,                    /* 15 delay the check on encryption */
-    BTM_SCO_BAD_LENGTH,                 /* 16 Bad SCO over HCI data length */
-    BTM_SUCCESS_NO_SECURITY,            /* 17 security passed, no security set  */
-    BTM_FAILED_ON_SECURITY,             /* 18 security failed                   */
-    BTM_REPEATED_ATTEMPTS,              /* 19 repeated attempts for LE security requests */
-    BTM_MODE4_LEVEL4_NOT_SUPPORTED      /* 20 Secure Connections Only Mode can't be supported */
-};
-
-typedef uint8_t tBTM_STATUS;
-
-#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
-typedef enum
-{
-    BTM_BR_ONE,                         /*0 First state or BR/EDR scan 1*/
-    BTM_BLE_ONE,                        /*1BLE scan 1*/
-    BTM_BR_TWO,                         /*2 BR/EDR scan 2*/
-    BTM_BLE_TWO,                        /*3 BLE scan 2*/
-    BTM_FINISH,                         /*4 End of Interleave Scan, or normal scan*/
-    BTM_NO_INTERLEAVING                 /*5 No Interleaving*/
-}btm_inq_state;
-#endif
-
-
-
-/*************************
-**  Device Control Types
-**************************/
-#define BTM_DEVICE_ROLE_BR      0x01
-#define BTM_DEVICE_ROLE_DUAL    0x02
-#define BTM_MAX_DEVICE_ROLE     BTM_DEVICE_ROLE_DUAL
-typedef UINT8 tBTM_DEVICE_ROLE;
-
-/* Device name of peer (may be truncated to save space in BTM database) */
-typedef UINT8 tBTM_BD_NAME[BTM_MAX_REM_BD_NAME_LEN + 1];
-
-/* Structure returned with local version information */
-typedef struct
-{
-    UINT8       hci_version;
-    UINT16      hci_revision;
-    UINT8       lmp_version;
-    UINT16      manufacturer;
-    UINT16      lmp_subversion;
-} tBTM_VERSION_INFO;
-
-/* Structure returned with Vendor Specific Command complete callback */
-typedef struct
-{
-    UINT16  opcode;
-    UINT16  param_len;
-    UINT8   *p_param_buf;
-} tBTM_VSC_CMPL;
-
-/* Structure returned with HCI Raw Command complete callback */
-typedef struct
-{
-    UINT8  event_code;
-    UINT8  param_len;
-    UINT8   *p_param_buf;
-} tBTM_RAW_CMPL;
-
-#define  BTM_VSC_CMPL_DATA_SIZE  (BTM_MAX_VENDOR_SPECIFIC_LEN + sizeof(tBTM_VSC_CMPL))
-/**************************************************
-**  Device Control and General Callback Functions
-***************************************************/
-/* Callback function for when device status changes. Appl must poll for
-** what the new state is (BTM_IsDeviceUp). The event occurs whenever the stack
-** has detected that the controller status has changed. This asynchronous event
-** is enabled/disabled by calling BTM_RegisterForDeviceStatusNotif().
-*/
-enum
-{
-    BTM_DEV_STATUS_UP,
-    BTM_DEV_STATUS_DOWN,
-    BTM_DEV_STATUS_CMD_TOUT
-};
-
-typedef UINT8 tBTM_DEV_STATUS;
-
-
-typedef void (tBTM_DEV_STATUS_CB) (tBTM_DEV_STATUS status);
-
-
-/* Callback function for when a vendor specific event occurs. The length and
-** array of returned parameter bytes are included. This asynchronous event
-** is enabled/disabled by calling BTM_RegisterForVSEvents().
-*/
-typedef void (tBTM_VS_EVT_CB) (UINT8 len, UINT8 *p);
-
-
-/* General callback function for notifying an application that a synchronous
-** BTM function is complete. The pointer contains the address of any returned data.
-*/
-typedef void (tBTM_CMPL_CB) (void *p1);
-
-/* VSC callback function for notifying an application that a synchronous
-** BTM function is complete. The pointer contains the address of any returned data.
-*/
-typedef void (tBTM_VSC_CMPL_CB) (tBTM_VSC_CMPL *p1);
-
-/* HCI RAW CMD callback function for notifying an application that a synchronous
-** BTM function is complete. The pointer contains the address of any returned data.
-*/
-typedef void (tBTM_RAW_CMPL_CB) (tBTM_RAW_CMPL *p1);
-
-/* Callback for apps to check connection and inquiry filters.
-** Parameters are the BD Address of remote and the Dev Class of remote.
-** If the app returns none zero, the connection or inquiry result will be dropped.
-*/
-typedef UINT8 (tBTM_FILTER_CB) (BD_ADDR bd_addr, DEV_CLASS dc);
-
-/*****************************************************************************
-**  DEVICE DISCOVERY - Inquiry, Remote Name, Discovery, Class of Device
-*****************************************************************************/
-/*******************************
-**  Device Discovery Constants
-********************************/
-/* Discoverable modes */
-#define BTM_NON_DISCOVERABLE        0
-#define BTM_LIMITED_DISCOVERABLE    1
-#define BTM_GENERAL_DISCOVERABLE    2
-#define BTM_DISCOVERABLE_MASK       (BTM_LIMITED_DISCOVERABLE|BTM_GENERAL_DISCOVERABLE)
-#define BTM_MAX_DISCOVERABLE        BTM_GENERAL_DISCOVERABLE
-/* high byte for BLE Discoverable modes */
-#define BTM_BLE_NON_DISCOVERABLE        0x0000
-#define BTM_BLE_LIMITED_DISCOVERABLE    0x0100
-#define BTM_BLE_GENERAL_DISCOVERABLE    0x0200
-#define BTM_BLE_MAX_DISCOVERABLE        BTM_BLE_GENERAL_DISCOVERABLE
-#define BTM_BLE_DISCOVERABLE_MASK       (BTM_BLE_NON_DISCOVERABLE|BTM_BLE_LIMITED_DISCOVERABLE|BTM_BLE_GENERAL_DISCOVERABLE)
-
-/* Connectable modes */
-#define BTM_NON_CONNECTABLE         0
-#define BTM_CONNECTABLE             1
-#define BTM_CONNECTABLE_MASK        (BTM_NON_CONNECTABLE | BTM_CONNECTABLE)
-/* high byte for BLE Connectable modes */
-#define BTM_BLE_NON_CONNECTABLE      0x0000
-#define BTM_BLE_CONNECTABLE          0x0100
-#define BTM_BLE_MAX_CONNECTABLE      BTM_BLE_CONNECTABLE
-#define BTM_BLE_CONNECTABLE_MASK    (BTM_BLE_NON_CONNECTABLE | BTM_BLE_CONNECTABLE)
-
-#define BTM_BLE_ADV_STOP            2
-/* Inquiry modes
- * Note: These modes are associated with the inquiry active values (BTM_*ACTIVE) */
-#define BTM_INQUIRY_NONE            0
-#define BTM_GENERAL_INQUIRY         0x01
-#define BTM_LIMITED_INQUIRY         0x02
-#define BTM_BR_INQUIRY_MASK         (BTM_GENERAL_INQUIRY | BTM_LIMITED_INQUIRY)
-
-/* high byte of inquiry mode for BLE inquiry mode */
-#define BTM_BLE_INQUIRY_NONE         0x00
-#define BTM_BLE_GENERAL_INQUIRY      0x10
-#define BTM_BLE_LIMITED_INQUIRY      0x20
-#define BTM_BLE_INQUIRY_MASK         (BTM_BLE_GENERAL_INQUIRY|BTM_BLE_LIMITED_INQUIRY)
-
-/* BTM_IsInquiryActive return values (Bit Mask)
- * Note: These bit masks are associated with the inquiry modes (BTM_*_INQUIRY) */
-#define BTM_INQUIRY_INACTIVE        0x0     /* no inquiry in progress */
-#define BTM_GENERAL_INQUIRY_ACTIVE  BTM_GENERAL_INQUIRY     /* a general inquiry is in progress */
-#define BTM_LIMITED_INQUIRY_ACTIVE  BTM_LIMITED_INQUIRY     /* a limited inquiry is in progress */
-#define BTM_PERIODIC_INQUIRY_ACTIVE 0x8     /* a periodic inquiry is active */
-#define BTM_SSP_INQUIRY_ACTIVE      0x4     /* SSP is active, so inquiry is disallowed (work around for FW bug) */
-#define BTM_LE_GENERAL_INQUIRY_ACTIVE  BTM_BLE_GENERAL_INQUIRY     /* a general inquiry is in progress */
-#define BTM_LE_LIMITED_INQUIRY_ACTIVE  BTM_BLE_LIMITED_INQUIRY      /* a limited inquiry is in progress */
-
-/* inquiry activity mask */
-#define BTM_BR_INQ_ACTIVE_MASK        (BTM_GENERAL_INQUIRY_ACTIVE|BTM_LIMITED_INQUIRY_ACTIVE|BTM_PERIODIC_INQUIRY_ACTIVE) /* BR/EDR inquiry activity mask */
-#define BTM_BLE_SCAN_ACTIVE_MASK      0xF0     /* LE scan activity mask */
-#define BTM_BLE_INQ_ACTIVE_MASK       (BTM_LE_GENERAL_INQUIRY_ACTIVE|BTM_LE_LIMITED_INQUIRY_ACTIVE) /* LE inquiry activity mask*/
-#define BTM_INQUIRY_ACTIVE_MASK       (BTM_BR_INQ_ACTIVE_MASK | BTM_BLE_INQ_ACTIVE_MASK) /* inquiry activity mask */
-
-/* Define scan types */
-#define BTM_SCAN_TYPE_STANDARD      0
-#define BTM_SCAN_TYPE_INTERLACED    1       /* 1.2 devices only */
-
-/* Define inquiry results mode */
-#define BTM_INQ_RESULT_STANDARD     0
-#define BTM_INQ_RESULT_WITH_RSSI    1
-#define BTM_INQ_RESULT_EXTENDED     2
-
-#define BTM_INQ_RES_IGNORE_RSSI     0x7f    /* RSSI value not supplied (ignore it) */
-
-/* Inquiry Filter Condition types (see tBTM_INQ_PARMS) */
-#define BTM_CLR_INQUIRY_FILTER          0                   /* Inquiry Filtering is turned off */
-#define BTM_FILTER_COND_DEVICE_CLASS    HCI_FILTER_COND_DEVICE_CLASS /* Filter on device class */
-#define BTM_FILTER_COND_BD_ADDR         HCI_FILTER_COND_BD_ADDR /* Filter on device addr */
-
-/* State of the remote name retrieval during inquiry operations.
-** Used in the tBTM_INQ_INFO structure, and returned in the
-** BTM_InqDbRead, BTM_InqDbFirst, and BTM_InqDbNext functions.
-** The name field is valid when the state returned is
-** BTM_INQ_RMT_NAME_DONE */
-#define BTM_INQ_RMT_NAME_EMPTY      0
-#define BTM_INQ_RMT_NAME_PENDING    1
-#define BTM_INQ_RMT_NAME_DONE       2
-#define BTM_INQ_RMT_NAME_FAILED     3
-
-/*********************************
- *** Class of Device constants ***
- *********************************/
-#define BTM_FORMAT_TYPE_1   0x00
-
-/****************************
-** minor device class field
-*****************************/
-
-/* 0x00 is used as unclassified for all minor device classes */
-#define BTM_COD_MINOR_UNCLASSIFIED          0x00
-
-/* minor device class field for Computer Major Class */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-#define BTM_COD_MINOR_DESKTOP_WORKSTATION   0x04
-#define BTM_COD_MINOR_SERVER_COMPUTER       0x08
-#define BTM_COD_MINOR_LAPTOP                0x0C
-#define BTM_COD_MINOR_HANDHELD_PC_PDA       0x10    /* clam shell */
-#define BTM_COD_MINOR_PALM_SIZE_PC_PDA      0x14
-#define BTM_COD_MINOR_WEARABLE_COMPUTER     0x18    /* watch sized */
-
-/* minor device class field for Phone Major Class */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-#define BTM_COD_MINOR_CELLULAR              0x04
-#define BTM_COD_MINOR_CORDLESS              0x08
-#define BTM_COD_MINOR_SMART_PHONE           0x0C
-#define BTM_COD_MINOR_WIRED_MDM_V_GTWY      0x10 /* wired modem or voice gatway */
-#define BTM_COD_MINOR_ISDN_ACCESS           0x14
-
-/* minor device class field for LAN Access Point Major Class */
-/* Load Factor Field bit 5-7 */
-#define BTM_COD_MINOR_FULLY_AVAILABLE       0x00
-#define BTM_COD_MINOR_1_17_UTILIZED         0x20
-#define BTM_COD_MINOR_17_33_UTILIZED        0x40
-#define BTM_COD_MINOR_33_50_UTILIZED        0x60
-#define BTM_COD_MINOR_50_67_UTILIZED        0x80
-#define BTM_COD_MINOR_67_83_UTILIZED        0xA0
-#define BTM_COD_MINOR_83_99_UTILIZED        0xC0
-#define BTM_COD_MINOR_NO_SERVICE_AVAILABLE  0xE0
-/* sub-Field bit 2-4 */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-
-/* minor device class field for Audio/Video Major Class */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-#define BTM_COD_MINOR_CONFM_HEADSET         0x04
-#define BTM_COD_MINOR_CONFM_HANDSFREE       0x08
-#define BTM_COD_MINOR_MICROPHONE            0x10
-#define BTM_COD_MINOR_LOUDSPEAKER           0x14
-#define BTM_COD_MINOR_HEADPHONES            0x18
-#define BTM_COD_MINOR_PORTABLE_AUDIO        0x1C
-#define BTM_COD_MINOR_CAR_AUDIO             0x20
-#define BTM_COD_MINOR_SET_TOP_BOX           0x24
-#define BTM_COD_MINOR_HIFI_AUDIO            0x28
-#define BTM_COD_MINOR_VCR                   0x2C
-#define BTM_COD_MINOR_VIDEO_CAMERA          0x30
-#define BTM_COD_MINOR_CAMCORDER             0x34
-#define BTM_COD_MINOR_VIDEO_MONITOR         0x38
-#define BTM_COD_MINOR_VIDDISP_LDSPKR        0x3C
-#define BTM_COD_MINOR_VIDEO_CONFERENCING    0x40
-#define BTM_COD_MINOR_GAMING_TOY            0x48
-
-/* minor device class field for Peripheral Major Class */
-/* Bits 6-7 independently specify mouse, keyboard, or combo mouse/keyboard */
-#define BTM_COD_MINOR_KEYBOARD              0x40
-#define BTM_COD_MINOR_POINTING              0x80
-#define BTM_COD_MINOR_COMBO                 0xC0
-/* Bits 2-5 OR'd with selection from bits 6-7 */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-#define BTM_COD_MINOR_JOYSTICK              0x04
-#define BTM_COD_MINOR_GAMEPAD               0x08
-#define BTM_COD_MINOR_REMOTE_CONTROL        0x0C
-#define BTM_COD_MINOR_SENSING_DEVICE        0x10
-#define BTM_COD_MINOR_DIGITIZING_TABLET     0x14
-#define BTM_COD_MINOR_CARD_READER           0x18    /* e.g. SIM card reader */
-#define BTM_COD_MINOR_DIGITAL_PAN           0x1C
-#define BTM_COD_MINOR_HAND_SCANNER          0x20
-#define BTM_COD_MINOR_HAND_GESTURAL_INPUT   0x24
-
-/* minor device class field for Imaging Major Class */
-/* Bits 5-7 independently specify display, camera, scanner, or printer */
-#define BTM_COD_MINOR_DISPLAY               0x10
-#define BTM_COD_MINOR_CAMERA                0x20
-#define BTM_COD_MINOR_SCANNER               0x40
-#define BTM_COD_MINOR_PRINTER               0x80
-/* Bits 2-3 Reserved */
-/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
-
-/* minor device class field for Wearable Major Class */
-/* Bits 2-7 meaningful    */
-#define BTM_COD_MINOR_WRIST_WATCH           0x04
-#define BTM_COD_MINOR_PAGER                 0x08
-#define BTM_COD_MINOR_JACKET                0x0C
-#define BTM_COD_MINOR_HELMET                0x10
-#define BTM_COD_MINOR_GLASSES               0x14
-
-/* minor device class field for Toy Major Class */
-/* Bits 2-7 meaningful    */
-#define BTM_COD_MINOR_ROBOT                 0x04
-#define BTM_COD_MINOR_VEHICLE               0x08
-#define BTM_COD_MINOR_DOLL_ACTION_FIGURE    0x0C
-#define BTM_COD_MINOR_CONTROLLER            0x10
-#define BTM_COD_MINOR_GAME                  0x14
-
-/* minor device class field for Health Major Class */
-/* Bits 2-7 meaningful    */
-#define BTM_COD_MINOR_BLOOD_MONITOR         0x04
-#define BTM_COD_MINOR_THERMOMETER           0x08
-#define BTM_COD_MINOR_WEIGHING_SCALE        0x0C
-#define BTM_COD_MINOR_GLUCOSE_METER         0x10
-#define BTM_COD_MINOR_PULSE_OXIMETER        0x14
-#define BTM_COD_MINOR_HEART_PULSE_MONITOR   0x18
-#define BTM_COD_MINOR_HEALTH_DATA_DISPLAY   0x1C
-#define BTM_COD_MINOR_STEP_COUNTER          0x20
-#define BTM_COD_MINOR_BODY_COM_ANALYZER     0x24
-#define BTM_COD_MINOR_PEAK_FLOW_MONITOR     0x28
-#define BTM_COD_MINOR_MEDICATION_MONITOR    0x2C
-#define BTM_COD_MINOR_KNEE_PROSTHESIS       0x30
-#define BTM_COD_MINOR_ANKLE_PROSTHESIS      0x34
-
-
-/***************************
-** major device class field
-****************************/
-#define BTM_COD_MAJOR_MISCELLANEOUS         0x00
-#define BTM_COD_MAJOR_COMPUTER              0x01
-#define BTM_COD_MAJOR_PHONE                 0x02
-#define BTM_COD_MAJOR_LAN_ACCESS_PT         0x03
-#define BTM_COD_MAJOR_AUDIO                 0x04
-#define BTM_COD_MAJOR_PERIPHERAL            0x05
-#define BTM_COD_MAJOR_IMAGING               0x06
-#define BTM_COD_MAJOR_WEARABLE              0x07
-#define BTM_COD_MAJOR_TOY                   0x08
-#define BTM_COD_MAJOR_HEALTH                0x09
-#define BTM_COD_MAJOR_UNCLASSIFIED          0x1F
-
-/***************************
-** service class fields
-****************************/
-#define BTM_COD_SERVICE_LMTD_DISCOVER       0x0020
-#define BTM_COD_SERVICE_POSITIONING         0x0100
-#define BTM_COD_SERVICE_NETWORKING          0x0200
-#define BTM_COD_SERVICE_RENDERING           0x0400
-#define BTM_COD_SERVICE_CAPTURING           0x0800
-#define BTM_COD_SERVICE_OBJ_TRANSFER        0x1000
-#define BTM_COD_SERVICE_AUDIO               0x2000
-#define BTM_COD_SERVICE_TELEPHONY           0x4000
-#define BTM_COD_SERVICE_INFORMATION         0x8000
-
-/* class of device field macros */
-#define BTM_COD_FORMAT_TYPE(u8, pd)         {u8  = pd[2]&0x03;}
-#define BTM_COD_MINOR_CLASS(u8, pd)         {u8  = pd[2]&0xFC;}
-#define BTM_COD_MAJOR_CLASS(u8, pd)         {u8  = pd[1]&0x1F;}
-#define BTM_COD_SERVICE_CLASS(u16, pd)      {u16 = pd[0]; u16<<=8; u16 += pd[1]&0xE0;}
-
-/* to set the fields (assumes that format type is always 0) */
-#define FIELDS_TO_COD(pd, mn, mj, sv) {pd[2] = mn; pd[1] =              \
-                                       mj+ ((sv)&BTM_COD_SERVICE_CLASS_LO_B); \
-                                       pd[0] = (sv) >> 8;}
-
-/* the COD masks */
-#define BTM_COD_FORMAT_TYPE_MASK      0x03
-#define BTM_COD_MINOR_CLASS_MASK      0xFC
-#define BTM_COD_MAJOR_CLASS_MASK      0x1F
-#define BTM_COD_SERVICE_CLASS_LO_B    0x00E0
-#define BTM_COD_SERVICE_CLASS_MASK    0xFFE0
-
-
-/* BTM service definitions
-** Used for storing EIR data to bit mask
-*/
-enum
-{
-    BTM_EIR_UUID_SERVCLASS_SERVICE_DISCOVERY_SERVER,
-/*    BTM_EIR_UUID_SERVCLASS_BROWSE_GROUP_DESCRIPTOR,   */
-/*    BTM_EIR_UUID_SERVCLASS_PUBLIC_BROWSE_GROUP,       */
-    BTM_EIR_UUID_SERVCLASS_SERIAL_PORT,
-    BTM_EIR_UUID_SERVCLASS_LAN_ACCESS_USING_PPP,
-    BTM_EIR_UUID_SERVCLASS_DIALUP_NETWORKING,
-    BTM_EIR_UUID_SERVCLASS_IRMC_SYNC,
-    BTM_EIR_UUID_SERVCLASS_OBEX_OBJECT_PUSH,
-    BTM_EIR_UUID_SERVCLASS_OBEX_FILE_TRANSFER,
-    BTM_EIR_UUID_SERVCLASS_IRMC_SYNC_COMMAND,
-    BTM_EIR_UUID_SERVCLASS_HEADSET,
-    BTM_EIR_UUID_SERVCLASS_CORDLESS_TELEPHONY,
-    BTM_EIR_UUID_SERVCLASS_AUDIO_SOURCE,
-    BTM_EIR_UUID_SERVCLASS_AUDIO_SINK,
-    BTM_EIR_UUID_SERVCLASS_AV_REM_CTRL_TARGET,
-/*    BTM_EIR_UUID_SERVCLASS_ADV_AUDIO_DISTRIBUTION,    */
-    BTM_EIR_UUID_SERVCLASS_AV_REMOTE_CONTROL,
-/*    BTM_EIR_UUID_SERVCLASS_VIDEO_CONFERENCING,        */
-    BTM_EIR_UUID_SERVCLASS_INTERCOM,
-    BTM_EIR_UUID_SERVCLASS_FAX,
-    BTM_EIR_UUID_SERVCLASS_HEADSET_AUDIO_GATEWAY,
-/*    BTM_EIR_UUID_SERVCLASS_WAP,                       */
-/*    BTM_EIR_UUID_SERVCLASS_WAP_CLIENT,                */
-    BTM_EIR_UUID_SERVCLASS_PANU,
-    BTM_EIR_UUID_SERVCLASS_NAP,
-    BTM_EIR_UUID_SERVCLASS_GN,
-    BTM_EIR_UUID_SERVCLASS_DIRECT_PRINTING,
-/*    BTM_EIR_UUID_SERVCLASS_REFERENCE_PRINTING,        */
-    BTM_EIR_UUID_SERVCLASS_IMAGING,
-    BTM_EIR_UUID_SERVCLASS_IMAGING_RESPONDER,
-    BTM_EIR_UUID_SERVCLASS_IMAGING_AUTO_ARCHIVE,
-    BTM_EIR_UUID_SERVCLASS_IMAGING_REF_OBJECTS,
-    BTM_EIR_UUID_SERVCLASS_HF_HANDSFREE,
-    BTM_EIR_UUID_SERVCLASS_AG_HANDSFREE,
-    BTM_EIR_UUID_SERVCLASS_DIR_PRT_REF_OBJ_SERVICE,
-/*    BTM_EIR_UUID_SERVCLASS_REFLECTED_UI,              */
-    BTM_EIR_UUID_SERVCLASS_BASIC_PRINTING,
-    BTM_EIR_UUID_SERVCLASS_PRINTING_STATUS,
-    BTM_EIR_UUID_SERVCLASS_HUMAN_INTERFACE,
-    BTM_EIR_UUID_SERVCLASS_CABLE_REPLACEMENT,
-    BTM_EIR_UUID_SERVCLASS_HCRP_PRINT,
-    BTM_EIR_UUID_SERVCLASS_HCRP_SCAN,
-/*    BTM_EIR_UUID_SERVCLASS_COMMON_ISDN_ACCESS,        */
-/*    BTM_EIR_UUID_SERVCLASS_VIDEO_CONFERENCING_GW,     */
-/*    BTM_EIR_UUID_SERVCLASS_UDI_MT,                    */
-/*    BTM_EIR_UUID_SERVCLASS_UDI_TA,                    */
-/*    BTM_EIR_UUID_SERVCLASS_VCP,                       */
-    BTM_EIR_UUID_SERVCLASS_SAP,
-    BTM_EIR_UUID_SERVCLASS_PBAP_PCE,
-    BTM_EIR_UUID_SERVCLASS_PBAP_PSE,
-/*    BTM_EIR_UUID_SERVCLASS_TE_PHONE_ACCESS,           */
-/*    BTM_EIR_UUID_SERVCLASS_ME_PHONE_ACCESS,           */
-    BTM_EIR_UUID_SERVCLASS_PHONE_ACCESS,
-    BTM_EIR_UUID_SERVCLASS_HEADSET_HS,
-    BTM_EIR_UUID_SERVCLASS_PNP_INFORMATION,
-/*    BTM_EIR_UUID_SERVCLASS_GENERIC_NETWORKING,        */
-/*    BTM_EIR_UUID_SERVCLASS_GENERIC_FILETRANSFER,      */
-/*    BTM_EIR_UUID_SERVCLASS_GENERIC_AUDIO,             */
-/*    BTM_EIR_UUID_SERVCLASS_GENERIC_TELEPHONY,         */
-/*    BTM_EIR_UUID_SERVCLASS_UPNP_SERVICE,              */
-/*    BTM_EIR_UUID_SERVCLASS_UPNP_IP_SERVICE,           */
-/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_PAN,          */
-/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_LAP,          */
-/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_L2CAP,        */
-    BTM_EIR_UUID_SERVCLASS_VIDEO_SOURCE,
-    BTM_EIR_UUID_SERVCLASS_VIDEO_SINK,
-/*    BTM_EIR_UUID_SERVCLASS_VIDEO_DISTRIBUTION         */
-/*    BTM_EIR_UUID_SERVCLASS_HDP_PROFILE                */
-    BTM_EIR_UUID_SERVCLASS_MESSAGE_ACCESS,
-    BTM_EIR_UUID_SERVCLASS_MESSAGE_NOTIFICATION,
-    BTM_EIR_UUID_SERVCLASS_HDP_SOURCE,
-    BTM_EIR_UUID_SERVCLASS_HDP_SINK,
-    BTM_EIR_MAX_SERVICES
-};
-
-/* search result in EIR of inquiry database */
-#define BTM_EIR_FOUND           0
-#define BTM_EIR_NOT_FOUND       1
-#define BTM_EIR_UNKNOWN         2
-
-typedef UINT8 tBTM_EIR_SEARCH_RESULT;
-
-#define BTM_EIR_FLAGS_TYPE                  HCI_EIR_FLAGS_TYPE                  /* 0x01 */
-#define BTM_EIR_MORE_16BITS_UUID_TYPE       HCI_EIR_MORE_16BITS_UUID_TYPE       /* 0x02 */
-#define BTM_EIR_COMPLETE_16BITS_UUID_TYPE   HCI_EIR_COMPLETE_16BITS_UUID_TYPE   /* 0x03 */
-#define BTM_EIR_MORE_32BITS_UUID_TYPE       HCI_EIR_MORE_32BITS_UUID_TYPE       /* 0x04 */
-#define BTM_EIR_COMPLETE_32BITS_UUID_TYPE   HCI_EIR_COMPLETE_32BITS_UUID_TYPE   /* 0x05 */
-#define BTM_EIR_MORE_128BITS_UUID_TYPE      HCI_EIR_MORE_128BITS_UUID_TYPE      /* 0x06 */
-#define BTM_EIR_COMPLETE_128BITS_UUID_TYPE  HCI_EIR_COMPLETE_128BITS_UUID_TYPE  /* 0x07 */
-#define BTM_EIR_SHORTENED_LOCAL_NAME_TYPE   HCI_EIR_SHORTENED_LOCAL_NAME_TYPE   /* 0x08 */
-#define BTM_EIR_COMPLETE_LOCAL_NAME_TYPE    HCI_EIR_COMPLETE_LOCAL_NAME_TYPE    /* 0x09 */
-#define BTM_EIR_TX_POWER_LEVEL_TYPE         HCI_EIR_TX_POWER_LEVEL_TYPE         /* 0x0A */
-#define BTM_EIR_MANUFACTURER_SPECIFIC_TYPE  HCI_EIR_MANUFACTURER_SPECIFIC_TYPE  /* 0xFF */
-
-/* the following EIR tags are defined to OOB, not regular EIR data */
-#define BTM_EIR_OOB_BD_ADDR_TYPE            HCI_EIR_OOB_BD_ADDR_TYPE    /* 6 bytes */
-#define BTM_EIR_OOB_COD_TYPE                HCI_EIR_OOB_COD_TYPE        /* 3 bytes */
-#define BTM_EIR_OOB_SSP_HASH_C_TYPE         HCI_EIR_OOB_SSP_HASH_C_TYPE /* 16 bytes */
-#define BTM_EIR_OOB_SSP_RAND_R_TYPE         HCI_EIR_OOB_SSP_RAND_R_TYPE /* 16 bytes */
-
-#define BTM_OOB_MANDATORY_SIZE      8   /* include 2 bytes length & 6 bytes bd_addr */
-#define BTM_OOB_DATA_LEN_SIZE       2
-#define BTM_OOB_BD_ADDR_SIZE        6
-#define BTM_OOB_COD_SIZE            BT_OOB_COD_SIZE
-#define BTM_OOB_HASH_C_SIZE         BT_OOB_HASH_C_SIZE
-#define BTM_OOB_RAND_R_SIZE         BT_OOB_RAND_R_SIZE
-
-#define BTM_BLE_SEC_NONE                0
-#define BTM_BLE_SEC_ENCRYPT             1 /* encrypt the link using current key */
-#define BTM_BLE_SEC_ENCRYPT_NO_MITM     2
-#define BTM_BLE_SEC_ENCRYPT_MITM        3
-typedef UINT8   tBTM_BLE_SEC_ACT;
-
-/************************************************************************************************
-** BTM Services MACROS handle array of UINT32 bits for more than 32 services
-*************************************************************************************************/
-/* Determine the number of UINT32's necessary for services */
-#define BTM_EIR_ARRAY_BITS          32          /* Number of bits in each array element */
-#define BTM_EIR_SERVICE_ARRAY_SIZE  (((UINT32)BTM_EIR_MAX_SERVICES / BTM_EIR_ARRAY_BITS) + \
-                                    (((UINT32)BTM_EIR_MAX_SERVICES % BTM_EIR_ARRAY_BITS) ? 1 : 0))
-
-/* MACRO to set the service bit mask in a bit stream */
-#define BTM_EIR_SET_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] |=  \
-                                    ((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS)))
-
-
-/* MACRO to clear the service bit mask in a bit stream */
-#define BTM_EIR_CLR_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] &=  \
-                                    ~((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS)))
-
-/* MACRO to check the service bit mask in a bit stream */
-#define BTM_EIR_HAS_SERVICE(p, service)  ((((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] &  \
-                                    ((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS))) >> (((UINT32)(service)) % BTM_EIR_ARRAY_BITS))
-
-/* start of EIR in HCI buffer, 4 bytes = HCI Command(2) + Length(1) + FEC_Req(1) */
-#define BTM_HCI_EIR_OFFSET          (BT_HDR_SIZE + 4)
-
-/***************************
-**  Device Discovery Types
-****************************/
-/* Definitions of the parameters passed to BTM_StartInquiry and
-** BTM_SetPeriodicInquiryMode.
-*/
-typedef struct              /* contains the two device class condition fields */
-{
-    DEV_CLASS       dev_class;
-    DEV_CLASS       dev_class_mask;
-} tBTM_COD_COND;
-
-
-typedef union               /* contains the inquiry filter condition */
-{
-    BD_ADDR         bdaddr_cond;
-    tBTM_COD_COND   cod_cond;
-} tBTM_INQ_FILT_COND;
-
-
-typedef struct              /* contains the parameters passed to the inquiry functions */
-{
-    UINT8   mode;                       /* general or limited */
-    UINT8   duration;                   /* duration of the inquiry (1.28 sec increments) */
-    UINT8   max_resps;                  /* maximum number of responses to return */
-    BOOLEAN report_dup;                 /* report duplicated inquiry response with higher RSSI value */
-    UINT8   filter_cond_type;           /* new devices, BD ADDR, COD, or No filtering */
-    tBTM_INQ_FILT_COND  filter_cond;    /* filter value based on filter cond type */
-#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
-    UINT8   intl_duration[4];              /*duration array storing the interleave scan's time portions*/
-#endif
-} tBTM_INQ_PARMS;
-
-#define BTM_INQ_RESULT_BR       0x01
-#define BTM_INQ_RESULT_BLE      0x02
-
-#if (BLE_INCLUDED == TRUE)
-#define BTM_BLE_EVT_CONN_ADV        0x00
-#define BTM_BLE_EVT_CONN_DIR_ADV    0x01
-#define BTM_BLE_EVT_DISC_ADV        0x02
-#define BTM_BLE_EVT_NON_CONN_ADV    0x03
-#define BTM_BLE_EVT_SCAN_RSP        0x04
-typedef UINT8 tBTM_BLE_EVT_TYPE;
-#endif
-
-/* These are the fields returned in each device's response to the inquiry.  It
-** is returned in the results callback if registered.
-*/
-typedef struct
-{
-    UINT16      clock_offset;
-    BD_ADDR     remote_bd_addr;
-    DEV_CLASS   dev_class;
-    UINT8       page_scan_rep_mode;
-    UINT8       page_scan_per_mode;
-    UINT8       page_scan_mode;
-    INT8        rssi;       /* Set to BTM_INQ_RES_IGNORE_RSSI if  not valid */
-    UINT32      eir_uuid[BTM_EIR_SERVICE_ARRAY_SIZE];
-    BOOLEAN     eir_complete_list;
-#if (BLE_INCLUDED == TRUE)
-    tBT_DEVICE_TYPE         device_type;
-    UINT8       inq_result_type;
-    UINT8       ble_addr_type;
-    tBTM_BLE_EVT_TYPE       ble_evt_type;
-    UINT8                   flag;
-#endif
-} tBTM_INQ_RESULTS;
-
-
-/* This is the inquiry response information held in its database by BTM, and available
-** to applications via BTM_InqDbRead, BTM_InqDbFirst, and BTM_InqDbNext.
-*/
-typedef struct
-{
-    tBTM_INQ_RESULTS    results;
-
-    BOOLEAN             appl_knows_rem_name;    /* set by application if it knows the remote name of the peer device.
-                                                   This is later used by application to determine if remote name request is
-                                                   required to be done. Having the flag here avoid duplicate store of inquiry results */
-#if ( BLE_INCLUDED == TRUE)
-    UINT16          remote_name_len;
-    tBTM_BD_NAME    remote_name;
-    UINT8           remote_name_state;
-    UINT8           remote_name_type;
-#endif
-
-} tBTM_INQ_INFO;
-
-
-/* Structure returned with inquiry complete callback */
-typedef struct
-{
-    tBTM_STATUS status;
-    UINT8       num_resp;       /* Number of results from the current inquiry */
-} tBTM_INQUIRY_CMPL;
-
-
-/* Structure returned with remote name  request */
-typedef struct
-{
-    UINT16      status;
-    BD_ADDR     bd_addr;
-    UINT16      length;
-    BD_NAME     remote_bd_name;
-} tBTM_REMOTE_DEV_NAME;
-
-typedef struct
-{
-    UINT8   pcm_intf_rate;  /* PCM interface rate: 0: 128kbps, 1: 256 kbps;
-                                2:512 bps; 3: 1024kbps; 4: 2048kbps */
-    UINT8   frame_type;     /* frame type: 0: short; 1: long */
-    UINT8   sync_mode;      /* sync mode: 0: slave; 1: master */
-    UINT8   clock_mode;     /* clock mode: 0: slave; 1: master */
-
-}tBTM_SCO_PCM_PARAM;
-
-/****************************************
-**  Device Discovery Callback Functions
-*****************************************/
-/* Callback function for asynchronous notifications when the BTM inquiry DB
-** changes. First param is inquiry database, second is if added to or removed
-** from the inquiry database.
-*/
-typedef void (tBTM_INQ_DB_CHANGE_CB) (void *p1, BOOLEAN is_new);
-
-/* Callback function for notifications when the BTM gets inquiry response.
-** First param is inquiry results database, second is pointer of EIR.
-*/
-typedef void (tBTM_INQ_RESULTS_CB) (tBTM_INQ_RESULTS *p_inq_results, UINT8 *p_eir);
 
-/*****************************************************************************
-**  ACL CHANNEL MANAGEMENT
-*****************************************************************************/
-/******************
-**  ACL Constants
-*******************/
-
-/* ACL modes */
-#define BTM_ACL_MODE_NORMAL     HCI_MODE_ACTIVE
-#define BTM_ACL_MODE_HOLD       HCI_MODE_HOLD
-#define BTM_ACL_MODE_SNIFF      HCI_MODE_SNIFF
-#define BTM_ACL_MODE_PARK       HCI_MODE_PARK
-
-/* Returned with structure in role switch callback (tBTM_ROLE_SWITCH_CMPL) */
-#define BTM_ROLE_MASTER         HCI_ROLE_MASTER
-#define BTM_ROLE_SLAVE          HCI_ROLE_SLAVE
-#define BTM_ROLE_UNDEFINED      0xff     /* undefined value (error status) */
-
-/* ACL Packet Types */
-#define BTM_ACL_PKT_TYPES_MASK_DM1      HCI_PKT_TYPES_MASK_DM1
-#define BTM_ACL_PKT_TYPES_MASK_DH1      HCI_PKT_TYPES_MASK_DH1
-#define BTM_ACL_PKT_TYPES_MASK_DM3      HCI_PKT_TYPES_MASK_DM3
-#define BTM_ACL_PKT_TYPES_MASK_DH3      HCI_PKT_TYPES_MASK_DH3
-#define BTM_ACL_PKT_TYPES_MASK_DM5      HCI_PKT_TYPES_MASK_DM5
-#define BTM_ACL_PKT_TYPES_MASK_DH5      HCI_PKT_TYPES_MASK_DH5
-#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH1 HCI_PKT_TYPES_MASK_NO_2_DH1
-#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH1 HCI_PKT_TYPES_MASK_NO_3_DH1
-#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH3 HCI_PKT_TYPES_MASK_NO_2_DH3
-#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH3 HCI_PKT_TYPES_MASK_NO_3_DH3
-#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH5 HCI_PKT_TYPES_MASK_NO_2_DH5
-#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH5 HCI_PKT_TYPES_MASK_NO_3_DH5
-
-/***************
-**  ACL Types
-****************/
-
-/* Structure returned with Role Switch information (in tBTM_CMPL_CB callback function)
-** in response to BTM_SwitchRole call.
-*/
-typedef struct
-{
-    UINT8   hci_status;     /* HCI status returned with the event */
-    UINT8   role;           /* BTM_ROLE_MASTER or BTM_ROLE_SLAVE */
-    BD_ADDR remote_bd_addr; /* Remote BD addr involved with the switch */
-} tBTM_ROLE_SWITCH_CMPL;
-
-/* Structure returned with QoS information (in tBTM_CMPL_CB callback function)
-** in response to BTM_SetQoS call.
-*/
-typedef struct
-{
-    FLOW_SPEC flow;
-    UINT16 handle;
-    UINT8 status;
-} tBTM_QOS_SETUP_CMPL;
-
-
-/* Structure returned with read RSSI event (in tBTM_CMPL_CB callback function)
-** in response to BTM_ReadRSSI call.
-*/
-typedef struct
-{
-    tBTM_STATUS status;
-    UINT8       hci_status;
-    INT8        rssi;
-    BD_ADDR     rem_bda;
-} tBTM_RSSI_RESULTS;
-
-/* Structure returned with read current TX power event (in tBTM_CMPL_CB callback function)
-** in response to BTM_ReadTxPower call.
-*/
-typedef struct
-{
-    tBTM_STATUS status;
-    UINT8       hci_status;
-    INT8        tx_power;
-    BD_ADDR     rem_bda;
-} tBTM_TX_POWER_RESULTS;
-
-/* Structure returned with read link quality event (in tBTM_CMPL_CB callback function)
-** in response to BTM_ReadLinkQuality call.
-*/
-typedef struct
-{
-    tBTM_STATUS status;
-    UINT8       hci_status;
-    UINT8       link_quality;
-    BD_ADDR     rem_bda;
-} tBTM_LINK_QUALITY_RESULTS;
-
-/* Structure returned with read inq tx power quality event (in tBTM_CMPL_CB callback function)
-** in response to BTM_ReadInquiryRspTxPower call.
-*/
-typedef struct
-{
-    tBTM_STATUS status;
-    UINT8       hci_status;
-    INT8        tx_power;
-} tBTM_INQ_TXPWR_RESULTS;
-
-enum
-{
-    BTM_BL_CONN_EVT,
-    BTM_BL_DISCN_EVT,
-    BTM_BL_UPDATE_EVT,
-    BTM_BL_ROLE_CHG_EVT,
-    BTM_BL_COLLISION_EVT
-};
-typedef UINT8 tBTM_BL_EVENT;
-typedef UINT16 tBTM_BL_EVENT_MASK;
-
-#define BTM_BL_CONN_MASK        0x0001
-#define BTM_BL_DISCN_MASK       0x0002
-#define BTM_BL_UPDATE_MASK      0x0004
-#define BTM_BL_ROLE_CHG_MASK    0x0008
-
-/* Device features mask definitions */
-#define BTM_FEATURE_BYTES_PER_PAGE  HCI_FEATURE_BYTES_PER_PAGE
-#define BTM_EXT_FEATURES_PAGE_MAX   HCI_EXT_FEATURES_PAGE_MAX
-
-/* the data type associated with BTM_BL_CONN_EVT */
-typedef struct
-{
-    tBTM_BL_EVENT   event;      /* The event reported. */
-    BD_ADDR_PTR     p_bda;      /* The address of the newly connected device */
-    DEV_CLASS_PTR   p_dc;       /* The device class */
-    BD_NAME_PTR     p_bdn;      /* The device name */
-    UINT8          *p_features; /* pointer to the remote device's features page[0] (supported features page) */
-#if BLE_INCLUDED == TRUE
-    UINT16          handle;     /* connection handle */
-    tBT_TRANSPORT   transport; /* link is LE or not */
-#endif
-} tBTM_BL_CONN_DATA;
-
-/* the data type associated with BTM_BL_DISCN_EVT */
-typedef struct
-{
-    tBTM_BL_EVENT   event;  /* The event reported. */
-    BD_ADDR_PTR     p_bda;  /* The address of the disconnected device */
-#if BLE_INCLUDED == TRUE
-    UINT16          handle; /* disconnected connection handle */
-    tBT_TRANSPORT   transport; /* link is LE link or not */
-#endif
-} tBTM_BL_DISCN_DATA;
-
-/* Busy-Level shall have the inquiry_paging mask set when
- * inquiry/paging is in progress, Else the number of ACL links */
-#define BTM_BL_INQUIRY_PAGING_MASK 0x10
-#define BTM_BL_INQUIRY_STARTED   (BTM_BL_INQUIRY_PAGING_MASK | 0x1)
-#define BTM_BL_INQUIRY_CANCELLED (BTM_BL_INQUIRY_PAGING_MASK | 0x2)
-#define BTM_BL_INQUIRY_COMPLETE  (BTM_BL_INQUIRY_PAGING_MASK | 0x3)
-#define BTM_BL_PAGING_STARTED    (BTM_BL_INQUIRY_PAGING_MASK | 0x4)
-#define BTM_BL_PAGING_COMPLETE   (BTM_BL_INQUIRY_PAGING_MASK | 0x5)
-/* the data type associated with BTM_BL_UPDATE_EVT */
-typedef struct
-{
-    tBTM_BL_EVENT   event;  /* The event reported. */
-    UINT8           busy_level;/* when paging or inquiring, level is between
-                                  17 to 21 as the max links can be 16.
-                                * Otherwise, the number of ACL links. */
-    UINT8           busy_level_flags; /* Notifies actual inquiry/page activities */
-} tBTM_BL_UPDATE_DATA;
-
-/* the data type associated with BTM_BL_ROLE_CHG_EVT */
-typedef struct
-{
-    tBTM_BL_EVENT   event;      /* The event reported. */
-    BD_ADDR_PTR     p_bda;      /* The address of the peer connected device */
-    UINT8           new_role;
-    UINT8           hci_status; /* HCI status returned with the event */
-} tBTM_BL_ROLE_CHG_DATA;
-
-typedef union
-{
-    tBTM_BL_EVENT           event;  /* The event reported. */
-    tBTM_BL_CONN_DATA       conn;   /* The data associated with BTM_BL_CONN_EVT */
-    tBTM_BL_DISCN_DATA      discn;  /* The data associated with BTM_BL_DISCN_EVT */
-    tBTM_BL_UPDATE_DATA     update; /* The data associated with BTM_BL_UPDATE_EVT */
-    tBTM_BL_ROLE_CHG_DATA   role_chg;/*The data associated with BTM_BL_ROLE_CHG_EVT */
-} tBTM_BL_EVENT_DATA;
-
-/* Callback function for notifications when the BTM busy level
-** changes.
-*/
-typedef void (tBTM_BL_CHANGE_CB) (tBTM_BL_EVENT_DATA *p_data);
-
-/***************************
-**  ACL Callback Functions
-****************************/
-/* Callback function for notifications when the BTM ACL connection DB
-** changes. First param is BD address, second is if added or removed.
-** Registered through BTM_AclRegisterForChanges call.
-*/
-#if BLE_INCLUDED == TRUE
-typedef void (tBTM_ACL_DB_CHANGE_CB) (BD_ADDR p_bda, DEV_CLASS p_dc,
-                                      BD_NAME p_bdn, UINT8 *features,
-                                      BOOLEAN is_new, UINT16 handle,
-                                      tBT_TRANSPORT transport);
-#else
-typedef void (tBTM_ACL_DB_CHANGE_CB) (BD_ADDR p_bda, DEV_CLASS p_dc,
-                                      BD_NAME p_bdn, UINT8 *features,
-                                      BOOLEAN is_new);
-#endif
-/*****************************************************************************
-**  SCO CHANNEL MANAGEMENT
-*****************************************************************************/
-/******************
-**  SCO Constants
-*******************/
-
-/* Define an invalid SCO index and an invalid HCI handle */
-#define BTM_INVALID_SCO_INDEX       0xFFFF
-#define BTM_INVALID_HCI_HANDLE      0xFFFF
-
-/* Define an invalid SCO disconnect reason */
-#define BTM_INVALID_SCO_DISC_REASON 0xFFFF
-
-/* Define first active SCO index */
-#define BTM_FIRST_ACTIVE_SCO_INDEX  BTM_MAX_SCO_LINKS
-
-/* Define SCO packet types used in APIs */
-#define BTM_SCO_PKT_TYPES_MASK_HV1  HCI_ESCO_PKT_TYPES_MASK_HV1
-#define BTM_SCO_PKT_TYPES_MASK_HV2  HCI_ESCO_PKT_TYPES_MASK_HV2
-#define BTM_SCO_PKT_TYPES_MASK_HV3  HCI_ESCO_PKT_TYPES_MASK_HV3
-#define BTM_SCO_PKT_TYPES_MASK_EV3  HCI_ESCO_PKT_TYPES_MASK_EV3
-#define BTM_SCO_PKT_TYPES_MASK_EV4  HCI_ESCO_PKT_TYPES_MASK_EV4
-#define BTM_SCO_PKT_TYPES_MASK_EV5  HCI_ESCO_PKT_TYPES_MASK_EV5
-#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV3  HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3
-#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV3  HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3
-#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV5  HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5
-#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV5  HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5
-
-#define BTM_SCO_LINK_ONLY_MASK  (BTM_SCO_PKT_TYPES_MASK_HV1 | \
-                                 BTM_SCO_PKT_TYPES_MASK_HV2 | \
-                                 BTM_SCO_PKT_TYPES_MASK_HV3)
-
-#define BTM_ESCO_LINK_ONLY_MASK (BTM_SCO_PKT_TYPES_MASK_EV3 | \
-                                 BTM_SCO_PKT_TYPES_MASK_EV4 | \
-                                 BTM_SCO_PKT_TYPES_MASK_EV5)
-
-#define BTM_SCO_LINK_ALL_PKT_MASK   (BTM_SCO_LINK_ONLY_MASK     | \
-                                     BTM_ESCO_LINK_ONLY_MASK)
-
-#define BTM_VALID_SCO_ALL_PKT_TYPE HCI_VALID_SCO_ALL_PKT_TYPE
-
-/* Passed in BTM_CreateSco if the packet type parameter should be ignored */
-#define BTM_IGNORE_SCO_PKT_TYPE     0
-
-/***************
-**  SCO Types
-****************/
-#define BTM_LINK_TYPE_SCO           HCI_LINK_TYPE_SCO
-#define BTM_LINK_TYPE_ESCO          HCI_LINK_TYPE_ESCO
-typedef UINT8 tBTM_SCO_TYPE;
-
-
-/*******************
-** SCO Routing Path
-********************/
-#define BTM_SCO_ROUTE_PCM           HCI_BRCM_SCO_ROUTE_PCM
-#define BTM_SCO_ROUTE_HCI           HCI_BRCM_SCO_ROUTE_HCI
-typedef UINT8 tBTM_SCO_ROUTE_TYPE;
-
-
-/*******************
-** SCO Codec Types
-********************/
-// TODO(google) This should use common definitions
-// in hci/include/hci_audio.h
-#define BTM_SCO_CODEC_NONE          0x0000
-#define BTM_SCO_CODEC_CVSD          0x0001
-#define BTM_SCO_CODEC_MSBC          0x0002
-typedef UINT16 tBTM_SCO_CODEC_TYPE;
-
-
-
-/*******************
-** SCO Air Mode Types
-********************/
-#define BTM_SCO_AIR_MODE_U_LAW          0
-#define BTM_SCO_AIR_MODE_A_LAW          1
-#define BTM_SCO_AIR_MODE_CVSD           2
-#define BTM_SCO_AIR_MODE_TRANSPNT       3
-typedef UINT8 tBTM_SCO_AIR_MODE_TYPE;
-
-/*******************
-** SCO Voice Settings
-********************/
-#define BTM_VOICE_SETTING_CVSD  ((UINT16)  (HCI_INP_CODING_LINEAR          |   \
-                                            HCI_INP_DATA_FMT_2S_COMPLEMENT |   \
-                                            HCI_INP_SAMPLE_SIZE_16BIT      |   \
-                                            HCI_AIR_CODING_FORMAT_CVSD))
-
-#define BTM_VOICE_SETTING_TRANS ((UINT16)  (HCI_INP_CODING_LINEAR          |   \
-                                            HCI_INP_DATA_FMT_2S_COMPLEMENT |   \
-                                            HCI_INP_SAMPLE_SIZE_16BIT      |   \
-                                            HCI_AIR_CODING_FORMAT_TRANSPNT))
-
-/*******************
-** SCO Data Status
-********************/
-enum
-{
-    BTM_SCO_DATA_CORRECT,
-    BTM_SCO_DATA_PAR_ERR,
-    BTM_SCO_DATA_NONE,
-    BTM_SCO_DATA_PAR_LOST
-};
-typedef UINT8 tBTM_SCO_DATA_FLAG;
-
-/***************************
-**  SCO Callback Functions
-****************************/
-typedef void (tBTM_SCO_CB) (UINT16 sco_inx);
-typedef void (tBTM_SCO_DATA_CB) (UINT16 sco_inx, BT_HDR *p_data, tBTM_SCO_DATA_FLAG status);
-
-/******************
-**  eSCO Constants
-*******************/
-#define BTM_64KBITS_RATE            0x00001f40  /* 64 kbits/sec data rate */
-
-/* Retransmission effort */
-#define BTM_ESCO_RETRANS_OFF        0
-#define BTM_ESCO_RETRANS_POWER      1
-#define BTM_ESCO_RETRANS_QUALITY    2
-#define BTM_ESCO_RETRANS_DONTCARE   0xff
-
-/* Max Latency Don't Care */
-#define BTM_ESCO_MAX_LAT_DONTCARE   0xffff
-
-/***************
-**  eSCO Types
-****************/
-/* tBTM_ESCO_CBACK event types */
-#define BTM_ESCO_CHG_EVT        1
-#define BTM_ESCO_CONN_REQ_EVT   2
-typedef UINT8 tBTM_ESCO_EVT;
-
-/* Passed into BTM_SetEScoMode() */
-typedef struct
-{
-    UINT32 tx_bw;
-    UINT32 rx_bw;
-    UINT16 max_latency;
-    UINT16 voice_contfmt;  /* Voice Settings or Content Format */
-    UINT16 packet_types;
-    UINT8  retrans_effort;
-} tBTM_ESCO_PARAMS;
-
-typedef struct
-{
-    UINT16 max_latency;
-    UINT16 packet_types;
-    UINT8  retrans_effort;
-} tBTM_CHG_ESCO_PARAMS;
-
-/* Returned by BTM_ReadEScoLinkParms() */
-typedef struct
-{
-    UINT16  rx_pkt_len;
-    UINT16  tx_pkt_len;
-    BD_ADDR bd_addr;
-    UINT8   link_type;  /* BTM_LINK_TYPE_SCO or BTM_LINK_TYPE_ESCO */
-    UINT8   tx_interval;
-    UINT8   retrans_window;
-    UINT8   air_mode;
-} tBTM_ESCO_DATA;
-
-typedef struct
-{
-    UINT16  sco_inx;
-    UINT16  rx_pkt_len;
-    UINT16  tx_pkt_len;
-    BD_ADDR bd_addr;
-    UINT8   hci_status;
-    UINT8   tx_interval;
-    UINT8   retrans_window;
-} tBTM_CHG_ESCO_EVT_DATA;
-
-typedef struct
-{
-    UINT16        sco_inx;
-    BD_ADDR       bd_addr;
-    DEV_CLASS     dev_class;
-    tBTM_SCO_TYPE link_type;
-} tBTM_ESCO_CONN_REQ_EVT_DATA;
-
-typedef union
-{
-    tBTM_CHG_ESCO_EVT_DATA      chg_evt;
-    tBTM_ESCO_CONN_REQ_EVT_DATA conn_evt;
-} tBTM_ESCO_EVT_DATA;
-
-/***************************
-**  eSCO Callback Functions
-****************************/
-typedef void (tBTM_ESCO_CBACK) (tBTM_ESCO_EVT event, tBTM_ESCO_EVT_DATA *p_data);
-
-
-/*****************************************************************************
-**  SECURITY MANAGEMENT
-*****************************************************************************/
-/*******************************
-**  Security Manager Constants
-********************************/
-
-/* Security Mode (BTM_SetSecurityMode) */
-#define BTM_SEC_MODE_UNDEFINED      0
-#define BTM_SEC_MODE_NONE           1
-#define BTM_SEC_MODE_SERVICE        2
-#define BTM_SEC_MODE_LINK           3
-#define BTM_SEC_MODE_SP             4
-#define BTM_SEC_MODE_SP_DEBUG       5
-#define BTM_SEC_MODE_SC             6
-
-/* Maximum Number of BTM Security Modes */
-#define BTM_SEC_MODES_MAX           7
-
-/* Security Service Levels [bit mask] (BTM_SetSecurityLevel)
-** Encryption should not be used without authentication
-*/
-#define BTM_SEC_NONE               0x0000 /* Nothing required */
-#define BTM_SEC_IN_AUTHORIZE       0x0001 /* Inbound call requires authorization */
-#define BTM_SEC_IN_AUTHENTICATE    0x0002 /* Inbound call requires authentication */
-#define BTM_SEC_IN_ENCRYPT         0x0004 /* Inbound call requires encryption */
-#define BTM_SEC_OUT_AUTHORIZE      0x0008 /* Outbound call requires authorization */
-#define BTM_SEC_OUT_AUTHENTICATE   0x0010 /* Outbound call requires authentication */
-#define BTM_SEC_OUT_ENCRYPT        0x0020 /* Outbound call requires encryption */
-#define BTM_SEC_MODE4_LEVEL4       0x0040 /* Secure Connections Only Mode */
-#define BTM_SEC_FORCE_MASTER       0x0100 /* Need to switch connection to be master */
-#define BTM_SEC_ATTEMPT_MASTER     0x0200 /* Try to switch connection to be master */
-#define BTM_SEC_FORCE_SLAVE        0x0400 /* Need to switch connection to be master */
-#define BTM_SEC_ATTEMPT_SLAVE      0x0800 /* Try to switch connection to be slave */
-#define BTM_SEC_IN_MITM            0x1000 /* inbound Do man in the middle protection */
-#define BTM_SEC_OUT_MITM           0x2000 /* outbound Do man in the middle protection */
-#define BTM_SEC_IN_MIN_16_DIGIT_PIN 0x4000 /* enforce a minimum of 16 digit for sec mode 2 */
-
-/* Security Flags [bit mask] (BTM_GetSecurityFlags)
-*/
-#define BTM_SEC_FLAG_AUTHORIZED     0x01
-#define BTM_SEC_FLAG_AUTHENTICATED  0x02
-#define BTM_SEC_FLAG_ENCRYPTED      0x04
-#define BTM_SEC_FLAG_LKEY_KNOWN     0x10
-#define BTM_SEC_FLAG_LKEY_AUTHED    0x20
-
-/* PIN types */
-#define BTM_PIN_TYPE_VARIABLE       HCI_PIN_TYPE_VARIABLE
-#define BTM_PIN_TYPE_FIXED          HCI_PIN_TYPE_FIXED
-
-/* Link Key types used to generate the new link key.
-** returned in link key notification callback function
-*/
-#define BTM_LKEY_TYPE_COMBINATION   HCI_LKEY_TYPE_COMBINATION
-#define BTM_LKEY_TYPE_LOCAL_UNIT    HCI_LKEY_TYPE_LOCAL_UNIT
-#define BTM_LKEY_TYPE_REMOTE_UNIT   HCI_LKEY_TYPE_REMOTE_UNIT
-#define BTM_LKEY_TYPE_DEBUG_COMB    HCI_LKEY_TYPE_DEBUG_COMB
-#define BTM_LKEY_TYPE_UNAUTH_COMB   HCI_LKEY_TYPE_UNAUTH_COMB
-#define BTM_LKEY_TYPE_AUTH_COMB     HCI_LKEY_TYPE_AUTH_COMB
-#define BTM_LKEY_TYPE_CHANGED_COMB  HCI_LKEY_TYPE_CHANGED_COMB
-
-#define BTM_LKEY_TYPE_UNAUTH_COMB_P_256 HCI_LKEY_TYPE_UNAUTH_COMB_P_256
-#define BTM_LKEY_TYPE_AUTH_COMB_P_256   HCI_LKEY_TYPE_AUTH_COMB_P_256
-
-#define BTM_LTK_DERIVED_LKEY_OFFSET 0x20    /* "easy" requirements for LK derived from LTK */
-#define BTM_LKEY_TYPE_IGNORE        0xff    /* used when event is response from
-                                               hci return link keys request */
-
-typedef UINT8 tBTM_LINK_KEY_TYPE;
-
-/* Protocol level security (BTM_SetSecurityLevel) */
-#define BTM_SEC_PROTO_L2CAP         0
-#define BTM_SEC_PROTO_SDP           1
-#define BTM_SEC_PROTO_TCS           2
-#define BTM_SEC_PROTO_RFCOMM        3
-#define BTM_SEC_PROTO_OBEX          4
-#define BTM_SEC_PROTO_BNEP          5
-#define BTM_SEC_PROTO_HID           6   /* HID      */
-#define BTM_SEC_PROTO_AVDT          7
-#define BTM_SEC_PROTO_MCA           8
-
-/* Determine the number of UINT32's necessary for security services */
-#define BTM_SEC_ARRAY_BITS          32          /* Number of bits in each array element */
-#define BTM_SEC_SERVICE_ARRAY_SIZE  (((UINT32)BTM_SEC_MAX_SERVICES / BTM_SEC_ARRAY_BITS) + \
-                                    (((UINT32)BTM_SEC_MAX_SERVICES % BTM_SEC_ARRAY_BITS) ? 1 : 0))
-
-/* Security service definitions (BTM_SetSecurityLevel)
-** Used for Authorization APIs
-*/
-#define BTM_SEC_SERVICE_SDP_SERVER      0
-#define BTM_SEC_SERVICE_SERIAL_PORT     1
-#define BTM_SEC_SERVICE_LAN_ACCESS      2
-#define BTM_SEC_SERVICE_DUN             3
-#define BTM_SEC_SERVICE_IRMC_SYNC       4
-#define BTM_SEC_SERVICE_IRMC_SYNC_CMD   5
-#define BTM_SEC_SERVICE_OBEX            6
-#define BTM_SEC_SERVICE_OBEX_FTP        7
-#define BTM_SEC_SERVICE_HEADSET         8
-#define BTM_SEC_SERVICE_CORDLESS        9
-#define BTM_SEC_SERVICE_INTERCOM        10
-#define BTM_SEC_SERVICE_FAX             11
-#define BTM_SEC_SERVICE_HEADSET_AG      12
-#define BTM_SEC_SERVICE_PNP_INFO        13
-#define BTM_SEC_SERVICE_GEN_NET         14
-#define BTM_SEC_SERVICE_GEN_FILE        15
-#define BTM_SEC_SERVICE_GEN_AUDIO       16
-#define BTM_SEC_SERVICE_GEN_TEL         17
-#define BTM_SEC_SERVICE_CTP_DATA        18
-#define BTM_SEC_SERVICE_HCRP_CTRL       19
-#define BTM_SEC_SERVICE_HCRP_DATA       20
-#define BTM_SEC_SERVICE_HCRP_NOTIF      21
-#define BTM_SEC_SERVICE_BPP_JOB         22
-#define BTM_SEC_SERVICE_BPP_STATUS      23
-#define BTM_SEC_SERVICE_BPP_REF         24
-#define BTM_SEC_SERVICE_BNEP_PANU       25
-#define BTM_SEC_SERVICE_BNEP_GN         26
-#define BTM_SEC_SERVICE_BNEP_NAP        27
-#define BTM_SEC_SERVICE_HF_HANDSFREE    28
-#define BTM_SEC_SERVICE_AG_HANDSFREE    29
-#define BTM_SEC_SERVICE_TE_PHONE_ACCESS 30
-#define BTM_SEC_SERVICE_ME_PHONE_ACCESS 31
-
-#define BTM_SEC_SERVICE_HIDH_SEC_CTRL   32
-#define BTM_SEC_SERVICE_HIDH_NOSEC_CTRL 33
-#define BTM_SEC_SERVICE_HIDH_INTR       34
-#define BTM_SEC_SERVICE_BIP             35
-#define BTM_SEC_SERVICE_BIP_REF         36
-#define BTM_SEC_SERVICE_AVDTP           37
-#define BTM_SEC_SERVICE_AVDTP_NOSEC     38
-#define BTM_SEC_SERVICE_AVCTP           39
-#define BTM_SEC_SERVICE_SAP             40
-#define BTM_SEC_SERVICE_PBAP            41
-#define BTM_SEC_SERVICE_RFC_MUX         42
-#define BTM_SEC_SERVICE_AVCTP_BROWSE    43
-#define BTM_SEC_SERVICE_MAP             44
-#define BTM_SEC_SERVICE_MAP_NOTIF       45
-#define BTM_SEC_SERVICE_MCAP_CTRL       46
-#define BTM_SEC_SERVICE_MCAP_DATA       47
-#define BTM_SEC_SERVICE_HDP_SNK         48
-#define BTM_SEC_SERVICE_HDP_SRC         49
-#define BTM_SEC_SERVICE_ATT             50
-
-/* Update these as services are added */
-#define BTM_SEC_SERVICE_FIRST_EMPTY     51
-
-#ifndef BTM_SEC_MAX_SERVICES
-#define BTM_SEC_MAX_SERVICES            75
-#endif
-
-/************************************************************************************************
-** Security Services MACROS handle array of UINT32 bits for more than 32 trusted services
-*************************************************************************************************/
-/* MACRO to set the security service bit mask in a bit stream */
-#define BTM_SEC_SET_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)] |=  \
-                                    ((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))
-
-
-/* MACRO to clear the security service bit mask in a bit stream */
-#define BTM_SEC_CLR_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)] &=  \
-                                    ~((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))
-
-/* MACRO to check the security service bit mask in a bit stream (Returns TRUE or FALSE) */
-#define BTM_SEC_IS_SERVICE_TRUSTED(p, service)    (((((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)]) &   \
-                                        (UINT32)(((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))) ? TRUE : FALSE)
-
-/* MACRO to copy two trusted device bitmask */
-#define BTM_SEC_COPY_TRUSTED_DEVICE(p_src, p_dst)   {UINT32 trst; for (trst = 0; trst < BTM_SEC_SERVICE_ARRAY_SIZE; trst++) \
-                                                        ((UINT32 *)(p_dst))[trst] = ((UINT32 *)(p_src))[trst];}
-
-/* MACRO to clear two trusted device bitmask */
-#define BTM_SEC_CLR_TRUSTED_DEVICE(p_dst)   {UINT32 trst; for (trst = 0; trst < BTM_SEC_SERVICE_ARRAY_SIZE; trst++) \
-                                                        ((UINT32 *)(p_dst))[trst] = 0;}
-
-/* Following bits can be provided by host in the trusted_mask array */
-/* 0..31 bits of mask[0] (Least Significant Word) */
-#define BTM_SEC_TRUST_SDP_SERVER        (1 << BTM_SEC_SERVICE_SDP_SERVER)
-#define BTM_SEC_TRUST_SERIAL_PORT       (1 << BTM_SEC_SERVICE_SERIAL_PORT)
-#define BTM_SEC_TRUST_LAN_ACCESS        (1 << BTM_SEC_SERVICE_LAN_ACCESS)
-#define BTM_SEC_TRUST_DUN               (1 << BTM_SEC_SERVICE_DUN)
-#define BTM_SEC_TRUST_IRMC_SYNC         (1 << BTM_SEC_SERVICE_IRMC_SYNC)
-#define BTM_SEC_TRUST_IRMC_SYNC_CMD     (1 << BTM_SEC_SERVICE_IRMC_SYNC_CMD)
-#define BTM_SEC_TRUST_OBEX              (1 << BTM_SEC_SERVICE_OBEX)
-#define BTM_SEC_TRUST_OBEX_FTP          (1 << BTM_SEC_SERVICE_OBEX_FTP)
-#define BTM_SEC_TRUST_HEADSET           (1 << BTM_SEC_SERVICE_HEADSET)
-#define BTM_SEC_TRUST_CORDLESS          (1 << BTM_SEC_SERVICE_CORDLESS)
-#define BTM_SEC_TRUST_INTERCOM          (1 << BTM_SEC_SERVICE_INTERCOM)
-#define BTM_SEC_TRUST_FAX               (1 << BTM_SEC_SERVICE_FAX)
-#define BTM_SEC_TRUST_HEADSET_AG        (1 << BTM_SEC_SERVICE_HEADSET_AG)
-#define BTM_SEC_TRUST_PNP_INFO          (1 << BTM_SEC_SERVICE_PNP_INFO)
-#define BTM_SEC_TRUST_GEN_NET           (1 << BTM_SEC_SERVICE_GEN_NET)
-#define BTM_SEC_TRUST_GEN_FILE          (1 << BTM_SEC_SERVICE_GEN_FILE)
-#define BTM_SEC_TRUST_GEN_AUDIO         (1 << BTM_SEC_SERVICE_GEN_AUDIO)
-#define BTM_SEC_TRUST_GEN_TEL           (1 << BTM_SEC_SERVICE_GEN_TEL)
-#define BTM_SEC_TRUST_CTP_DATA          (1 << BTM_SEC_SERVICE_CTP_DATA)
-#define BTM_SEC_TRUST_HCRP_CTRL         (1 << BTM_SEC_SERVICE_HCRP_CTRL)
-#define BTM_SEC_TRUST_HCRP_DATA         (1 << BTM_SEC_SERVICE_HCRP_DATA)
-#define BTM_SEC_TRUST_HCRP_NOTIF        (1 << BTM_SEC_SERVICE_HCRP_NOTIF)
-#define BTM_SEC_TRUST_BPP_JOB           (1 << BTM_SEC_SERVICE_JOB)
-#define BTM_SEC_TRUST_BPP_STATUS        (1 << BTM_SEC_SERVICE_STATUS)
-#define BTM_SEC_TRUST_BPP_REF           (1 << BTM_SEC_SERVICE_REF)
-#define BTM_SEC_TRUST_BNEP_PANU         (1 << BTM_SEC_SERVICE_BNEP_PANU)
-#define BTM_SEC_TRUST_BNEP_GN           (1 << BTM_SEC_SERVICE_BNEP_GN)
-#define BTM_SEC_TRUST_BNEP_NAP          (1 << BTM_SEC_SERVICE_BNEP_NAP)
-#define BTM_SEC_TRUST_HFP_HF            (1 << BTM_SEC_SERVICE_HF_HANDSFREE)
-#define BTM_SEC_TRUST_HFP_AG            (1 << BTM_SEC_SERVICE_AG_HANDSFREE)
-#define BTM_SEC_TRUST_TE_PHONE_ACCESS   (1 << BTM_SEC_SERVICE_TE_PHONE_ACCESS)
-#define BTM_SEC_TRUST_ME_PHONE_ACCESS   (1 << BTM_SEC_SERVICE_ME_PHONE_ACCESS)
-
-/* 0..31 bits of mask[1] (Most Significant Word) */
-#define BTM_SEC_TRUST_HIDH_CTRL         (1 << (BTM_SEC_SERVICE_HIDH_SEC_CTRL - 32))
-#define BTM_SEC_TRUST_HIDH_NOSEC_CTRL   (1 << (BTM_SEC_SERVICE_HIDH_NOSEC_CTRL - 32))
-#define BTM_SEC_TRUST_HIDH_INTR         (1 << (BTM_SEC_SERVICE_HIDH_INTR - 32))
-#define BTM_SEC_TRUST_BIP               (1 << (BTM_SEC_SERVICE_BIP - 32))
-#define BTM_SEC_TRUST_BIP_REF           (1 << (BTM_SEC_SERVICE_BIP_REF - 32))
-#define BTM_SEC_TRUST_AVDTP             (1 << (BTM_SEC_SERVICE_AVDTP - 32))
-#define BTM_SEC_TRUST_AVDTP_NOSEC       (1 << (BTM_SEC_SERVICE_AVDTP_NOSEC - 32))
-#define BTM_SEC_TRUST_AVCTP             (1 << (BTM_SEC_SERVICE_AVCTP - 32))
-#define BTM_SEC_TRUST_SAP               (1 << (BTM_SEC_SERVICE_SAP - 32))
-#define BTM_SEC_TRUST_PBAP              (1 << (BTM_SEC_SERVICE_PBAP - 32))
-#define BTM_SEC_TRUST_RFC_MUX           (1 << (BTM_SEC_SERVICE_RFC_MUX - 32))
-#define BTM_SEC_TRUST_AVCTP_BROWSE      (1 << (BTM_SEC_SERVICE_AVCTP_BROWSE - 32))
-#define BTM_SEC_TRUST_MAP               (1 << (BTM_SEC_SERVICE_MAP - 32))
-#define BTM_SEC_TRUST_MAP_NOTIF         (1 << (BTM_SEC_SERVICE_MAP_NOTIF - 32))
-#define BTM_SEC_TRUST_MCAP_CTRL         (1 << (BTM_SEC_SERVICE_MCAP_CTRL - 32))
-#define BTM_SEC_TRUST_MCAP_DATA         (1 << (BTM_SEC_SERVICE_MCAP_DATA - 32))
-#define BTM_SEC_TRUST_HDP_SNK           (1 << (BTM_SEC_SERVICE_HDP_SNK - 32))
-#define BTM_SEC_TRUST_HDP_SRC           (1 << (BTM_SEC_SERVICE_HDP_SRC - 32))
-
-#define BTM_SEC_TRUST_ALL               0xFFFFFFFF  /* for each array element */
-
-/****************************************
-**  Security Manager Callback Functions
-*****************************************/
-/* Authorize device for service.  Parameters are
-**              BD Address of remote
-**              Device Class of remote
-**              BD Name of remote
-**              Service name
-**              Service Id (NULL - unknown service or unused
-**                                 [BTM_SEC_SERVICE_NAME_LEN set to 0])
-**              Is originator of the connection
-**              Result of the operation
-*/
-typedef UINT8 (tBTM_AUTHORIZE_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
-                                         tBTM_BD_NAME bd_name, UINT8 *service_name,
-                                         UINT8 service_id, BOOLEAN is_originator);
-
-/* Get PIN for the connection.  Parameters are
-**              BD Address of remote
-**              Device Class of remote
-**              BD Name of remote
-**              Flag indicating the minimum pin code length to be 16 digits
-*/
-typedef UINT8 (tBTM_PIN_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
-                                   tBTM_BD_NAME bd_name, BOOLEAN min_16_digit);
-
-/* New Link Key for the connection.  Parameters are
-**              BD Address of remote
-**              Link Key
-**              Key Type: Combination, Local Unit, or Remote Unit
-*/
-typedef UINT8 (tBTM_LINK_KEY_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
-                                        tBTM_BD_NAME bd_name, UINT8 *key,
-                                        UINT8 key_type);
-
-
-/* Remote Name Resolved.  Parameters are
-**              BD Address of remote
-**              BD Name of remote
-*/
-typedef void (tBTM_RMT_NAME_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dc,
-                                       tBTM_BD_NAME bd_name);
-
-
-/* Authentication complete for the connection.  Parameters are
-**              BD Address of remote
-**              Device Class of remote
-**              BD Name of remote
-**
-*/
-typedef UINT8 (tBTM_AUTH_COMPLETE_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
-                                             tBTM_BD_NAME bd_name, int result);
-
-enum
-{
-    BTM_SP_IO_REQ_EVT,      /* received IO_CAPABILITY_REQUEST event */
-    BTM_SP_IO_RSP_EVT,      /* received IO_CAPABILITY_RESPONSE event */
-    BTM_SP_CFM_REQ_EVT,     /* received USER_CONFIRMATION_REQUEST event */
-    BTM_SP_KEY_NOTIF_EVT,   /* received USER_PASSKEY_NOTIFY event */
-    BTM_SP_KEY_REQ_EVT,     /* received USER_PASSKEY_REQUEST event */
-    BTM_SP_KEYPRESS_EVT,    /* received KEYPRESS_NOTIFY event */
-    BTM_SP_LOC_OOB_EVT,     /* received result for READ_LOCAL_OOB_DATA command */
-    BTM_SP_RMT_OOB_EVT,     /* received REMOTE_OOB_DATA_REQUEST event */
-    BTM_SP_COMPLT_EVT,      /* received SIMPLE_PAIRING_COMPLETE event */
-    BTM_SP_UPGRADE_EVT      /* check if the application wants to upgrade the link key */
-};
-typedef UINT8 tBTM_SP_EVT;
-
-#define BTM_IO_CAP_OUT      0   /* DisplayOnly */
-#define BTM_IO_CAP_IO       1   /* DisplayYesNo */
-#define BTM_IO_CAP_IN       2   /* KeyboardOnly */
-#define BTM_IO_CAP_NONE     3   /* NoInputNoOutput */
-#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
-#define BTM_IO_CAP_KBDISP   4   /* Keyboard display */
-#define BTM_IO_CAP_MAX      5
-#else
-#define BTM_IO_CAP_MAX      4
-#endif
-
-typedef UINT8 tBTM_IO_CAP;
-
-#define BTM_MAX_PASSKEY_VAL (999999)
-#define BTM_MIN_PASSKEY_VAL (0)
-
-#define BTM_AUTH_SP_NO      0   /* MITM Protection Not Required - Single Profile/non-bonding
-                                Numeric comparison with automatic accept allowed */
-#define BTM_AUTH_SP_YES     1   /* MITM Protection Required - Single Profile/non-bonding
-                                Use IO Capabilities to determine authentication procedure */
-#define BTM_AUTH_AP_NO      2   /* MITM Protection Not Required - All Profiles/dedicated bonding
-                                Numeric comparison with automatic accept allowed */
-#define BTM_AUTH_AP_YES     3   /* MITM Protection Required - All Profiles/dedicated bonding
-                                Use IO Capabilities to determine authentication procedure */
-#define BTM_AUTH_SPGB_NO    4   /* MITM Protection Not Required - Single Profiles/general bonding
-                                Numeric comparison with automatic accept allowed */
-#define BTM_AUTH_SPGB_YES   5   /* MITM Protection Required - Single Profiles/general bonding
-                                Use IO Capabilities to determine authentication procedure */
-#define BTM_AUTH_DD_BOND    2   /* this bit is ORed to the BTM_AUTH_SP_* when IO exchange for dedicated bonding */
-#define BTM_AUTH_GB_BIT     4   /* the genernal bonding bit */
-#define BTM_AUTH_BONDS      6   /* the general/dedicated bonding bits  */
-#define BTM_AUTH_YN_BIT     1   /* this is the Yes or No bit  */
-
-#define BTM_BLE_INITIATOR_KEY_SIZE 15
-#define BTM_BLE_RESPONDER_KEY_SIZE 15
-#define BTM_BLE_MAX_KEY_SIZE       16
-
-typedef UINT8 tBTM_AUTH_REQ;
-
-enum
-{
-    BTM_OOB_NONE,
-    BTM_OOB_PRESENT,
-    BTM_OOB_UNKNOWN
-};
-typedef UINT8 tBTM_OOB_DATA;
-
-/* data type for BTM_SP_IO_REQ_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    tBTM_IO_CAP     io_cap;         /* local IO capabilities */
-    tBTM_OOB_DATA   oob_data;       /* OOB data present (locally) for the peer device */
-    tBTM_AUTH_REQ   auth_req;       /* Authentication required (for local device) */
-    BOOLEAN         is_orig;        /* TRUE, if local device initiated the SP process */
-} tBTM_SP_IO_REQ;
-
-/* data type for BTM_SP_IO_RSP_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    tBTM_IO_CAP     io_cap;         /* peer IO capabilities */
-    tBTM_OOB_DATA   oob_data;       /* OOB data present at peer device for the local device */
-    tBTM_AUTH_REQ   auth_req;       /* Authentication required for peer device */
-} tBTM_SP_IO_RSP;
-
-/* data type for BTM_SP_CFM_REQ_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    DEV_CLASS       dev_class;      /* peer CoD */
-    tBTM_BD_NAME    bd_name;        /* peer device name */
-    UINT32          num_val;        /* the numeric value for comparison. If just_works, do not show this number to UI */
-    BOOLEAN         just_works;     /* TRUE, if "Just Works" association model */
-    tBTM_AUTH_REQ   loc_auth_req;   /* Authentication required for local device */
-    tBTM_AUTH_REQ   rmt_auth_req;   /* Authentication required for peer device */
-    tBTM_IO_CAP     loc_io_caps;    /* IO Capabilities of the local device */
-    tBTM_IO_CAP     rmt_io_caps;    /* IO Capabilities of the remot device */
-} tBTM_SP_CFM_REQ;
-
-/* data type for BTM_SP_KEY_REQ_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    DEV_CLASS       dev_class;      /* peer CoD */
-    tBTM_BD_NAME    bd_name;        /* peer device name */
-} tBTM_SP_KEY_REQ;
-
-/* data type for BTM_SP_KEY_NOTIF_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    DEV_CLASS       dev_class;      /* peer CoD */
-    tBTM_BD_NAME    bd_name;        /* peer device name */
-    UINT32          passkey;        /* passkey */
-} tBTM_SP_KEY_NOTIF;
-
-enum
-{
-    BTM_SP_KEY_STARTED,         /* 0 - passkey entry started */
-    BTM_SP_KEY_ENTERED,         /* 1 - passkey digit entered */
-    BTM_SP_KEY_ERASED,          /* 2 - passkey digit erased */
-    BTM_SP_KEY_CLEARED,         /* 3 - passkey cleared */
-    BTM_SP_KEY_COMPLT,          /* 4 - passkey entry completed */
-    BTM_SP_KEY_OUT_OF_RANGE     /* 5 - out of range */
-};
-typedef UINT8   tBTM_SP_KEY_TYPE;
-
-/* data type for BTM_SP_KEYPRESS_EVT */
-typedef struct
-{
-    BD_ADDR             bd_addr;        /* peer address */
-    tBTM_SP_KEY_TYPE   notif_type;
-} tBTM_SP_KEYPRESS;
-
-/* data type for BTM_SP_LOC_OOB_EVT */
-typedef struct
-{
-    tBTM_STATUS     status;         /* */
-    BT_OCTET16      c;              /* Simple Pairing Hash C */
-    BT_OCTET16      r;              /* Simple Pairing Randomnizer R */
-} tBTM_SP_LOC_OOB;
-
-/* data type for BTM_SP_RMT_OOB_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    DEV_CLASS       dev_class;      /* peer CoD */
-    tBTM_BD_NAME    bd_name;        /* peer device name */
-} tBTM_SP_RMT_OOB;
-
-
-/* data type for BTM_SP_COMPLT_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    DEV_CLASS       dev_class;      /* peer CoD */
-    tBTM_BD_NAME    bd_name;        /* peer device name */
-    tBTM_STATUS     status;         /* status of the simple pairing process */
-} tBTM_SP_COMPLT;
-
-/* data type for BTM_SP_UPGRADE_EVT */
-typedef struct
-{
-    BD_ADDR         bd_addr;        /* peer address */
-    BOOLEAN         upgrade;        /* TRUE, to upgrade the link key */
-} tBTM_SP_UPGRADE;
-
-typedef union
-{
-    tBTM_SP_IO_REQ      io_req;     /* BTM_SP_IO_REQ_EVT      */
-    tBTM_SP_IO_RSP      io_rsp;     /* BTM_SP_IO_RSP_EVT      */
-    tBTM_SP_CFM_REQ     cfm_req;    /* BTM_SP_CFM_REQ_EVT     */
-    tBTM_SP_KEY_NOTIF   key_notif;  /* BTM_SP_KEY_NOTIF_EVT   */
-    tBTM_SP_KEY_REQ     key_req;    /* BTM_SP_KEY_REQ_EVT     */
-    tBTM_SP_KEYPRESS    key_press;  /* BTM_SP_KEYPRESS_EVT    */
-    tBTM_SP_LOC_OOB     loc_oob;    /* BTM_SP_LOC_OOB_EVT     */
-    tBTM_SP_RMT_OOB     rmt_oob;    /* BTM_SP_RMT_OOB_EVT     */
-    tBTM_SP_COMPLT      complt;     /* BTM_SP_COMPLT_EVT      */
-    tBTM_SP_UPGRADE     upgrade;    /* BTM_SP_UPGRADE_EVT      */
-} tBTM_SP_EVT_DATA;
-
-/* Simple Pairing Events.  Called by the stack when Simple Pairing related
-** events occur.
-*/
-typedef UINT8 (tBTM_SP_CALLBACK) (tBTM_SP_EVT event, tBTM_SP_EVT_DATA *p_data);
-
-
-typedef void (tBTM_MKEY_CALLBACK) (BD_ADDR bd_addr, UINT8 status, UINT8 key_flag) ;
-
-/* Encryption enabled/disabled complete: Optionally passed with BTM_SetEncryption.
-** Parameters are
-**              BD Address of remote
-**              optional data passed in by BTM_SetEncryption
-**              tBTM_STATUS - result of the operation
-*/
-typedef void (tBTM_SEC_CBACK) (BD_ADDR bd_addr, tBT_TRANSPORT trasnport,
-                                void *p_ref_data, tBTM_STATUS result);
-
-/* Bond Cancel complete. Parameters are
-**              Result of the cancel operation
-**
-*/
-typedef void (tBTM_BOND_CANCEL_CMPL_CALLBACK) (tBTM_STATUS result);
-
-/* LE related event and data structure
-*/
-#define BTM_LE_IO_REQ_EVT       SMP_IO_CAP_REQ_EVT     /* received IO_CAPABILITY_REQUEST event */
-#define BTM_LE_SEC_REQUEST_EVT  SMP_SEC_REQUEST_EVT    /* security request event */
-#define BTM_LE_KEY_NOTIF_EVT    SMP_PASSKEY_NOTIF_EVT  /* received USER_PASSKEY_NOTIFY event */
-#define BTM_LE_KEY_REQ_EVT      SMP_PASSKEY_REQ_EVT    /* received USER_PASSKEY_REQUEST event */
-#define BTM_LE_OOB_REQ_EVT      SMP_OOB_REQ_EVT        /* OOB data request event */
-#define BTM_LE_NC_REQ_EVT       SMP_NC_REQ_EVT          /* Numeric Comparison request event */
-#define BTM_LE_PR_KEYPR_NOT_EVT SMP_PEER_KEYPR_NOT_EVT /* Peer keypress notification recd event */
-/* SC OOB request event (both local and peer OOB data) can be expected in response */
-#define BTM_LE_SC_OOB_REQ_EVT   SMP_SC_OOB_REQ_EVT
-/* SC OOB local data set is created (as result of SMP_CrLocScOobData(...)) */
-#define BTM_LE_SC_LOC_OOB_EVT   SMP_SC_LOC_OOB_DATA_UP_EVT
-#define BTM_LE_BR_KEYS_REQ_EVT  SMP_BR_KEYS_REQ_EVT     /* SMP over BR keys request event */
-#define BTM_LE_COMPLT_EVT       SMP_COMPLT_EVT         /* SMP complete event */
-#define BTM_LE_LAST_FROM_SMP    BTM_LE_BR_KEYS_REQ_EVT
-#define BTM_LE_KEY_EVT          BTM_LE_LAST_FROM_SMP + 1 /* KEY update event */
-#define BTM_LE_CONSENT_REQ_EVT  SMP_CONSENT_REQ_EVT
-typedef UINT8 tBTM_LE_EVT;
-
-#define BTM_LE_KEY_NONE           0
-#define BTM_LE_KEY_PENC      SMP_SEC_KEY_TYPE_ENC        /* encryption information of peer device */
-#define BTM_LE_KEY_PID       SMP_SEC_KEY_TYPE_ID         /* identity key of the peer device */
-#define BTM_LE_KEY_PCSRK     SMP_SEC_KEY_TYPE_CSRK      /* peer SRK */
-#define BTM_LE_KEY_PLK       SMP_SEC_KEY_TYPE_LK
-#define BTM_LE_KEY_LLK       (SMP_SEC_KEY_TYPE_LK << 4)
-#define BTM_LE_KEY_LENC      (SMP_SEC_KEY_TYPE_ENC << 4)  /* master role security information:div */
-#define BTM_LE_KEY_LID       (SMP_SEC_KEY_TYPE_ID << 4)   /* master device ID key */
-#define BTM_LE_KEY_LCSRK     (SMP_SEC_KEY_TYPE_CSRK << 4) /* local CSRK has been deliver to peer */
-typedef UINT8 tBTM_LE_KEY_TYPE;
-
-#define BTM_LE_AUTH_REQ_NO_BOND SMP_AUTH_NO_BOND   /* 0 */
-#define BTM_LE_AUTH_REQ_BOND    SMP_AUTH_GEN_BOND  /* 1 << 0 */
-#define BTM_LE_AUTH_REQ_MITM    SMP_AUTH_YN_BIT    /* 1 << 2 */
-typedef UINT8 tBTM_LE_AUTH_REQ;
-#define BTM_LE_SC_SUPPORT_BIT           SMP_SC_SUPPORT_BIT     /* (1 << 3) */
-#define BTM_LE_KP_SUPPORT_BIT           SMP_KP_SUPPORT_BIT     /* (1 << 4) */
-
-#define BTM_LE_AUTH_REQ_SC_ONLY         SMP_AUTH_SC_ENC_ONLY    /* 1 << 3 */
-#define BTM_LE_AUTH_REQ_SC_BOND         SMP_AUTH_SC_GB          /* 1001 */
-#define BTM_LE_AUTH_REQ_SC_MITM         SMP_AUTH_SC_MITM_NB     /* 1100 */
-#define BTM_LE_AUTH_REQ_SC_MITM_BOND    SMP_AUTH_SC_MITM_GB     /* 1101 */
-#define BTM_LE_AUTH_REQ_MASK            SMP_AUTH_MASK           /* 0x1D */
-
-/* LE security level */
-#define BTM_LE_SEC_NONE             SMP_SEC_NONE
-#define BTM_LE_SEC_UNAUTHENTICATE   SMP_SEC_UNAUTHENTICATE      /* 1 */
-#define BTM_LE_SEC_AUTHENTICATED    SMP_SEC_AUTHENTICATED       /* 4 */
-typedef UINT8 tBTM_LE_SEC;
-
-
-typedef struct
-{
-    tBTM_IO_CAP         io_cap;         /* local IO capabilities */
-    UINT8               oob_data;       /* OOB data present (locally) for the peer device */
-    tBTM_LE_AUTH_REQ    auth_req;       /* Authentication request (for local device) contain bonding and MITM info */
-    UINT8               max_key_size;   /* max encryption key size */
-    tBTM_LE_KEY_TYPE    init_keys;      /* keys to be distributed, bit mask */
-    tBTM_LE_KEY_TYPE    resp_keys;      /* keys to be distributed, bit mask */
-} tBTM_LE_IO_REQ;
-
-#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
-/* data type for tBTM_LE_COMPLT */
-typedef struct
-{
-    UINT8 reason;
-    UINT8 sec_level;
-    BOOLEAN is_pair_cancel;
-    BOOLEAN smp_over_br;
-}tBTM_LE_COMPLT;
-#endif
-
-/* BLE encryption keys */
-typedef struct
-{
-    BT_OCTET16  ltk;
-    BT_OCTET8   rand;
-    UINT16      ediv;
-    UINT8       sec_level;
-    UINT8       key_size;
-}tBTM_LE_PENC_KEYS;
-
-/* BLE CSRK keys */
-typedef struct
-{
-    UINT32          counter;
-    BT_OCTET16      csrk;
-    UINT8           sec_level;
-}tBTM_LE_PCSRK_KEYS;
-
-/* BLE Encryption reproduction keys */
-typedef struct
-{
-    BT_OCTET16  ltk;
-    UINT16      div;
-    UINT8       key_size;
-    UINT8       sec_level;
-}tBTM_LE_LENC_KEYS;
-
-/* BLE SRK keys */
-typedef struct
-{
-    UINT32          counter;
-    UINT16          div;
-    UINT8           sec_level;
-    BT_OCTET16      csrk;
-}tBTM_LE_LCSRK_KEYS;
-
-typedef struct
-{
-    BT_OCTET16          irk;
-    tBLE_ADDR_TYPE      addr_type;
-    BD_ADDR             static_addr;
-}tBTM_LE_PID_KEYS;
-
-typedef union
-{
-    tBTM_LE_PENC_KEYS   penc_key;       /* received peer encryption key */
-    tBTM_LE_PCSRK_KEYS  pcsrk_key;      /* received peer device SRK */
-    tBTM_LE_PID_KEYS    pid_key;        /* peer device ID key */
-    tBTM_LE_LENC_KEYS   lenc_key;       /* local encryption reproduction keys LTK = = d1(ER,DIV,0)*/
-    tBTM_LE_LCSRK_KEYS   lcsrk_key;     /* local device CSRK = d1(ER,DIV,1)*/
-}tBTM_LE_KEY_VALUE;
-
-typedef struct
-{
-    tBTM_LE_KEY_TYPE        key_type;
-    tBTM_LE_KEY_VALUE       *p_key_value;
-}tBTM_LE_KEY;
-
-typedef union
-{
-    tBTM_LE_IO_REQ      io_req;     /* BTM_LE_IO_REQ_EVT      */
-    UINT32              key_notif;  /* BTM_LE_KEY_NOTIF_EVT   */
-                                    /* BTM_LE_NC_REQ_EVT */
-                                    /* no callback data for BTM_LE_KEY_REQ_EVT */
-                                    /* and BTM_LE_OOB_REQ_EVT  */
-#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
-    tBTM_LE_COMPLT      complt;     /* BTM_LE_COMPLT_EVT      */
-    tSMP_OOB_DATA_TYPE  req_oob_type;
-#endif
-    tBTM_LE_KEY         key;
-} tBTM_LE_EVT_DATA;
-
-/* Simple Pairing Events.  Called by the stack when Simple Pairing related
-** events occur.
-*/
-typedef UINT8 (tBTM_LE_CALLBACK) (tBTM_LE_EVT event, BD_ADDR bda, tBTM_LE_EVT_DATA *p_data);
-
-#define BTM_BLE_KEY_TYPE_ID         1
-#define BTM_BLE_KEY_TYPE_ER         2
-#define BTM_BLE_KEY_TYPE_COUNTER    3  //tobe obsolete
-
-typedef struct
-{
-    BT_OCTET16       ir;
-    BT_OCTET16       irk;
-    BT_OCTET16       dhk;
-
-}tBTM_BLE_LOCAL_ID_KEYS;
-
-typedef union
-{
-    tBTM_BLE_LOCAL_ID_KEYS  id_keys;
-    BT_OCTET16              er;
-}tBTM_BLE_LOCAL_KEYS;
-
-
-/* New LE identity key for local device.
-*/
-typedef void (tBTM_LE_KEY_CALLBACK) (UINT8 key_type, tBTM_BLE_LOCAL_KEYS *p_key);
-
-
-/***************************
-**  Security Manager Types
-****************************/
-/* Structure that applications use to register with BTM_SecRegister */
-typedef struct
-{
-    tBTM_AUTHORIZE_CALLBACK     *p_authorize_callback;
-    tBTM_PIN_CALLBACK           *p_pin_callback;
-    tBTM_LINK_KEY_CALLBACK      *p_link_key_callback;
-    tBTM_AUTH_COMPLETE_CALLBACK *p_auth_complete_callback;
-    tBTM_BOND_CANCEL_CMPL_CALLBACK *p_bond_cancel_cmpl_callback;
-    tBTM_SP_CALLBACK            *p_sp_callback;
-#if BLE_INCLUDED == TRUE
-#if SMP_INCLUDED == TRUE
-    tBTM_LE_CALLBACK            *p_le_callback;
-#endif
-    tBTM_LE_KEY_CALLBACK        *p_le_key_callback;
-#endif
-} tBTM_APPL_INFO;
-
-/* Callback function for when a link supervision timeout event occurs.
-** This asynchronous event is enabled/disabled by calling BTM_RegForLstoEvt().
-*/
-typedef void (tBTM_LSTO_CBACK) (BD_ADDR remote_bda, UINT16 timeout);
-
-/*****************************************************************************
-**  POWER MANAGEMENT
-*****************************************************************************/
-/****************************
-**  Power Manager Constants
-*****************************/
-/* BTM Power manager status codes */
-enum
-{
-    BTM_PM_STS_ACTIVE = HCI_MODE_ACTIVE,
-    BTM_PM_STS_HOLD   = HCI_MODE_HOLD,
-    BTM_PM_STS_SNIFF  = HCI_MODE_SNIFF,
-    BTM_PM_STS_PARK   = HCI_MODE_PARK,
-    BTM_PM_STS_SSR,     /* report the SSR parameters in HCI_SNIFF_SUB_RATE_EVT */
-    BTM_PM_STS_PENDING,   /* when waiting for status from controller */
-    BTM_PM_STS_ERROR   /* when HCI command status returns error */
-};
-typedef UINT8 tBTM_PM_STATUS;
-
-/* BTM Power manager modes */
-enum
-{
-    BTM_PM_MD_ACTIVE = BTM_PM_STS_ACTIVE,
-    BTM_PM_MD_HOLD   = BTM_PM_STS_HOLD,
-    BTM_PM_MD_SNIFF  = BTM_PM_STS_SNIFF,
-    BTM_PM_MD_PARK   = BTM_PM_STS_PARK,
-    BTM_PM_MD_FORCE  = 0x10 /* OR this to force ACL link to a certain mode */
-};
-typedef UINT8 tBTM_PM_MODE;
-
-#define BTM_PM_SET_ONLY_ID  0x80
-
-/* Operation codes */
-#define BTM_PM_REG_SET      1 /* The module wants to set the desired power mode */
-#define BTM_PM_REG_NOTIF    2 /* The module wants to receive mode change event */
-#define BTM_PM_DEREG        4 /* The module does not want to involve with PM anymore */
-
-/************************
-**  Power Manager Types
-*************************/
-typedef struct
-{
-    UINT16          max;
-    UINT16          min;
-    UINT16          attempt;
-    UINT16          timeout;
-    tBTM_PM_MODE    mode;
-} tBTM_PM_PWR_MD;
-
-/*************************************
-**  Power Manager Callback Functions
-**************************************/
-typedef void (tBTM_PM_STATUS_CBACK) (BD_ADDR p_bda, tBTM_PM_STATUS status,
-                                     UINT16 value, UINT8 hci_status);
-
-
-/************************
-**  Stored Linkkey Types
-*************************/
-#define BTM_CB_EVT_DELETE_STORED_LINK_KEYS  4
-
-typedef struct
-{
-    UINT8          event;
-    UINT8          status;
-    UINT16         num_keys;
-
-} tBTM_DELETE_STORED_LINK_KEY_COMPLETE;
-
-/* MIP evnets, callbacks    */
-enum
-{
-    BTM_MIP_MODE_CHG_EVT,
-    BTM_MIP_DISCONNECT_EVT,
-    BTM_MIP_PKTS_COMPL_EVT,
-    BTM_MIP_RXDATA_EVT
-};
-typedef UINT8 tBTM_MIP_EVT;
-
-typedef struct
-{
-    tBTM_MIP_EVT    event;
-    BD_ADDR         bd_addr;
-    UINT16          mip_id;
-} tBTM_MIP_MODE_CHANGE;
-
-typedef struct
-{
-    tBTM_MIP_EVT    event;
-    UINT16          mip_id;
-    UINT8           disc_reason;
-} tBTM_MIP_CONN_TIMEOUT;
-
-#define BTM_MIP_MAX_RX_LEN  17
-
-typedef struct
-{
-    tBTM_MIP_EVT    event;
-    UINT16          mip_id;
-    UINT8           rx_len;
-    UINT8           rx_data[BTM_MIP_MAX_RX_LEN];
-} tBTM_MIP_RXDATA;
-
-typedef struct
-{
-    tBTM_MIP_EVT    event;
-    BD_ADDR         bd_addr;
-    UINT8           data[11];       /* data[0] shows Vender-specific device type */
-} tBTM_MIP_EIR_HANDSHAKE;
-
-typedef struct
-{
-    tBTM_MIP_EVT    event;
-    UINT16          num_sent;       /* Number of packets completed at the controller */
-} tBTM_MIP_PKTS_COMPL;
-
-typedef union
-{
-    tBTM_MIP_EVT            event;
-    tBTM_MIP_MODE_CHANGE    mod_chg;
-    tBTM_MIP_CONN_TIMEOUT   conn_tmo;
-    tBTM_MIP_EIR_HANDSHAKE  eir;
-    tBTM_MIP_PKTS_COMPL     completed;
-    tBTM_MIP_RXDATA         rxdata;
-} tBTM_MIP_EVENT_DATA;
-
-/* MIP event callback function  */
-typedef void (tBTM_MIP_EVENTS_CB) (tBTM_MIP_EVT event, tBTM_MIP_EVENT_DATA data);
-
-/* MIP Device query callback function  */
-typedef BOOLEAN (tBTM_MIP_QUERY_CB) (BD_ADDR dev_addr, UINT8 *p_mode, LINK_KEY link_key);
-
-#define BTM_CONTRL_ACTIVE  1       /* ACL link on, SCO link ongoing, sniff mode */
-#define BTM_CONTRL_SCAN    2       /* Scan state - paging/inquiry/trying to connect*/
-#define BTM_CONTRL_IDLE    3       /* Idle state - page scan, LE advt, inquiry scan */
-
-typedef UINT8 tBTM_CONTRL_STATE;
+#include "btm_api_types.h"
 
 /*****************************************************************************
 **  EXTERNAL FUNCTION DECLARATIONS
diff --git a/stack/include/btm_api_types.h b/stack/include/btm_api_types.h
new file mode 100644
index 000000000..dfbb75216
--- /dev/null
+++ b/stack/include/btm_api_types.h
@@ -0,0 +1,1900 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef BTM_API_TYPES_H
+#define BTM_API_TYPES_H
+
+#include "bt_target.h"
+#include "smp_api_types.h"
+#include "hcidefs.h"
+
+/* Maximum number of bytes allowed for vendor specific command parameters */
+#define BTM_MAX_VENDOR_SPECIFIC_LEN  HCI_COMMAND_SIZE
+
+/* BTM application return status codes */
+enum
+{
+    BTM_SUCCESS = 0,                    /* 0  Command succeeded                 */
+    BTM_CMD_STARTED,                    /* 1  Command started OK.               */
+    BTM_BUSY,                           /* 2  Device busy with another command  */
+    BTM_NO_RESOURCES,                   /* 3  No resources to issue command     */
+    BTM_MODE_UNSUPPORTED,               /* 4  Request for 1 or more unsupported modes */
+    BTM_ILLEGAL_VALUE,                  /* 5  Illegal parameter value           */
+    BTM_WRONG_MODE,                     /* 6  Device in wrong mode for request  */
+    BTM_UNKNOWN_ADDR,                   /* 7  Unknown remote BD address         */
+    BTM_DEVICE_TIMEOUT,                 /* 8  Device timeout                    */
+    BTM_BAD_VALUE_RET,                  /* 9  A bad value was received from HCI */
+    BTM_ERR_PROCESSING,                 /* 10 Generic error                     */
+    BTM_NOT_AUTHORIZED,                 /* 11 Authorization failed              */
+    BTM_DEV_RESET,                      /* 12 Device has been reset             */
+    BTM_CMD_STORED,                     /* 13 request is stored in control block */
+    BTM_ILLEGAL_ACTION,                 /* 14 state machine gets illegal command */
+    BTM_DELAY_CHECK,                    /* 15 delay the check on encryption */
+    BTM_SCO_BAD_LENGTH,                 /* 16 Bad SCO over HCI data length */
+    BTM_SUCCESS_NO_SECURITY,            /* 17 security passed, no security set  */
+    BTM_FAILED_ON_SECURITY,             /* 18 security failed                   */
+    BTM_REPEATED_ATTEMPTS,              /* 19 repeated attempts for LE security requests */
+    BTM_MODE4_LEVEL4_NOT_SUPPORTED      /* 20 Secure Connections Only Mode can't be supported */
+};
+
+typedef uint8_t tBTM_STATUS;
+
+#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
+typedef enum
+{
+    BTM_BR_ONE,                         /*0 First state or BR/EDR scan 1*/
+    BTM_BLE_ONE,                        /*1BLE scan 1*/
+    BTM_BR_TWO,                         /*2 BR/EDR scan 2*/
+    BTM_BLE_TWO,                        /*3 BLE scan 2*/
+    BTM_FINISH,                         /*4 End of Interleave Scan, or normal scan*/
+    BTM_NO_INTERLEAVING                 /*5 No Interleaving*/
+}btm_inq_state;
+#endif
+
+
+
+/*************************
+**  Device Control Types
+**************************/
+#define BTM_DEVICE_ROLE_BR      0x01
+#define BTM_DEVICE_ROLE_DUAL    0x02
+#define BTM_MAX_DEVICE_ROLE     BTM_DEVICE_ROLE_DUAL
+typedef UINT8 tBTM_DEVICE_ROLE;
+
+/* Device name of peer (may be truncated to save space in BTM database) */
+typedef UINT8 tBTM_BD_NAME[BTM_MAX_REM_BD_NAME_LEN + 1];
+
+/* Structure returned with local version information */
+typedef struct
+{
+    UINT8       hci_version;
+    UINT16      hci_revision;
+    UINT8       lmp_version;
+    UINT16      manufacturer;
+    UINT16      lmp_subversion;
+} tBTM_VERSION_INFO;
+
+/* Structure returned with Vendor Specific Command complete callback */
+typedef struct
+{
+    UINT16  opcode;
+    UINT16  param_len;
+    UINT8   *p_param_buf;
+} tBTM_VSC_CMPL;
+
+/* Structure returned with HCI Raw Command complete callback */
+typedef struct
+{
+    UINT8  event_code;
+    UINT8  param_len;
+    UINT8   *p_param_buf;
+} tBTM_RAW_CMPL;
+
+#define  BTM_VSC_CMPL_DATA_SIZE  (BTM_MAX_VENDOR_SPECIFIC_LEN + sizeof(tBTM_VSC_CMPL))
+/**************************************************
+**  Device Control and General Callback Functions
+***************************************************/
+/* Callback function for when device status changes. Appl must poll for
+** what the new state is (BTM_IsDeviceUp). The event occurs whenever the stack
+** has detected that the controller status has changed. This asynchronous event
+** is enabled/disabled by calling BTM_RegisterForDeviceStatusNotif().
+*/
+enum
+{
+    BTM_DEV_STATUS_UP,
+    BTM_DEV_STATUS_DOWN,
+    BTM_DEV_STATUS_CMD_TOUT
+};
+
+typedef UINT8 tBTM_DEV_STATUS;
+
+
+typedef void (tBTM_DEV_STATUS_CB) (tBTM_DEV_STATUS status);
+
+
+/* Callback function for when a vendor specific event occurs. The length and
+** array of returned parameter bytes are included. This asynchronous event
+** is enabled/disabled by calling BTM_RegisterForVSEvents().
+*/
+typedef void (tBTM_VS_EVT_CB) (UINT8 len, UINT8 *p);
+
+
+/* General callback function for notifying an application that a synchronous
+** BTM function is complete. The pointer contains the address of any returned data.
+*/
+typedef void (tBTM_CMPL_CB) (void *p1);
+
+/* VSC callback function for notifying an application that a synchronous
+** BTM function is complete. The pointer contains the address of any returned data.
+*/
+typedef void (tBTM_VSC_CMPL_CB) (tBTM_VSC_CMPL *p1);
+
+/* HCI RAW CMD callback function for notifying an application that a synchronous
+** BTM function is complete. The pointer contains the address of any returned data.
+*/
+typedef void (tBTM_RAW_CMPL_CB) (tBTM_RAW_CMPL *p1);
+
+/* Callback for apps to check connection and inquiry filters.
+** Parameters are the BD Address of remote and the Dev Class of remote.
+** If the app returns none zero, the connection or inquiry result will be dropped.
+*/
+typedef UINT8 (tBTM_FILTER_CB) (BD_ADDR bd_addr, DEV_CLASS dc);
+
+/*****************************************************************************
+**  DEVICE DISCOVERY - Inquiry, Remote Name, Discovery, Class of Device
+*****************************************************************************/
+/*******************************
+**  Device Discovery Constants
+********************************/
+/* Discoverable modes */
+#define BTM_NON_DISCOVERABLE        0
+#define BTM_LIMITED_DISCOVERABLE    1
+#define BTM_GENERAL_DISCOVERABLE    2
+#define BTM_DISCOVERABLE_MASK       (BTM_LIMITED_DISCOVERABLE|BTM_GENERAL_DISCOVERABLE)
+#define BTM_MAX_DISCOVERABLE        BTM_GENERAL_DISCOVERABLE
+/* high byte for BLE Discoverable modes */
+#define BTM_BLE_NON_DISCOVERABLE        0x0000
+#define BTM_BLE_LIMITED_DISCOVERABLE    0x0100
+#define BTM_BLE_GENERAL_DISCOVERABLE    0x0200
+#define BTM_BLE_MAX_DISCOVERABLE        BTM_BLE_GENERAL_DISCOVERABLE
+#define BTM_BLE_DISCOVERABLE_MASK       (BTM_BLE_NON_DISCOVERABLE|BTM_BLE_LIMITED_DISCOVERABLE|BTM_BLE_GENERAL_DISCOVERABLE)
+
+/* Connectable modes */
+#define BTM_NON_CONNECTABLE         0
+#define BTM_CONNECTABLE             1
+#define BTM_CONNECTABLE_MASK        (BTM_NON_CONNECTABLE | BTM_CONNECTABLE)
+/* high byte for BLE Connectable modes */
+#define BTM_BLE_NON_CONNECTABLE      0x0000
+#define BTM_BLE_CONNECTABLE          0x0100
+#define BTM_BLE_MAX_CONNECTABLE      BTM_BLE_CONNECTABLE
+#define BTM_BLE_CONNECTABLE_MASK    (BTM_BLE_NON_CONNECTABLE | BTM_BLE_CONNECTABLE)
+
+#define BTM_BLE_ADV_STOP            2
+/* Inquiry modes
+ * Note: These modes are associated with the inquiry active values (BTM_*ACTIVE) */
+#define BTM_INQUIRY_NONE            0
+#define BTM_GENERAL_INQUIRY         0x01
+#define BTM_LIMITED_INQUIRY         0x02
+#define BTM_BR_INQUIRY_MASK         (BTM_GENERAL_INQUIRY | BTM_LIMITED_INQUIRY)
+
+/* high byte of inquiry mode for BLE inquiry mode */
+#define BTM_BLE_INQUIRY_NONE         0x00
+#define BTM_BLE_GENERAL_INQUIRY      0x10
+#define BTM_BLE_LIMITED_INQUIRY      0x20
+#define BTM_BLE_INQUIRY_MASK         (BTM_BLE_GENERAL_INQUIRY|BTM_BLE_LIMITED_INQUIRY)
+
+/* BTM_IsInquiryActive return values (Bit Mask)
+ * Note: These bit masks are associated with the inquiry modes (BTM_*_INQUIRY) */
+#define BTM_INQUIRY_INACTIVE        0x0     /* no inquiry in progress */
+#define BTM_GENERAL_INQUIRY_ACTIVE  BTM_GENERAL_INQUIRY     /* a general inquiry is in progress */
+#define BTM_LIMITED_INQUIRY_ACTIVE  BTM_LIMITED_INQUIRY     /* a limited inquiry is in progress */
+#define BTM_PERIODIC_INQUIRY_ACTIVE 0x8     /* a periodic inquiry is active */
+#define BTM_SSP_INQUIRY_ACTIVE      0x4     /* SSP is active, so inquiry is disallowed (work around for FW bug) */
+#define BTM_LE_GENERAL_INQUIRY_ACTIVE  BTM_BLE_GENERAL_INQUIRY     /* a general inquiry is in progress */
+#define BTM_LE_LIMITED_INQUIRY_ACTIVE  BTM_BLE_LIMITED_INQUIRY      /* a limited inquiry is in progress */
+
+/* inquiry activity mask */
+#define BTM_BR_INQ_ACTIVE_MASK        (BTM_GENERAL_INQUIRY_ACTIVE|BTM_LIMITED_INQUIRY_ACTIVE|BTM_PERIODIC_INQUIRY_ACTIVE) /* BR/EDR inquiry activity mask */
+#define BTM_BLE_SCAN_ACTIVE_MASK      0xF0     /* LE scan activity mask */
+#define BTM_BLE_INQ_ACTIVE_MASK       (BTM_LE_GENERAL_INQUIRY_ACTIVE|BTM_LE_LIMITED_INQUIRY_ACTIVE) /* LE inquiry activity mask*/
+#define BTM_INQUIRY_ACTIVE_MASK       (BTM_BR_INQ_ACTIVE_MASK | BTM_BLE_INQ_ACTIVE_MASK) /* inquiry activity mask */
+
+/* Define scan types */
+#define BTM_SCAN_TYPE_STANDARD      0
+#define BTM_SCAN_TYPE_INTERLACED    1       /* 1.2 devices only */
+
+/* Define inquiry results mode */
+#define BTM_INQ_RESULT_STANDARD     0
+#define BTM_INQ_RESULT_WITH_RSSI    1
+#define BTM_INQ_RESULT_EXTENDED     2
+
+#define BTM_INQ_RES_IGNORE_RSSI     0x7f    /* RSSI value not supplied (ignore it) */
+
+/* Inquiry Filter Condition types (see tBTM_INQ_PARMS) */
+#define BTM_CLR_INQUIRY_FILTER          0                   /* Inquiry Filtering is turned off */
+#define BTM_FILTER_COND_DEVICE_CLASS    HCI_FILTER_COND_DEVICE_CLASS /* Filter on device class */
+#define BTM_FILTER_COND_BD_ADDR         HCI_FILTER_COND_BD_ADDR /* Filter on device addr */
+
+/* State of the remote name retrieval during inquiry operations.
+** Used in the tBTM_INQ_INFO structure, and returned in the
+** BTM_InqDbRead, BTM_InqDbFirst, and BTM_InqDbNext functions.
+** The name field is valid when the state returned is
+** BTM_INQ_RMT_NAME_DONE */
+#define BTM_INQ_RMT_NAME_EMPTY      0
+#define BTM_INQ_RMT_NAME_PENDING    1
+#define BTM_INQ_RMT_NAME_DONE       2
+#define BTM_INQ_RMT_NAME_FAILED     3
+
+/*********************************
+ *** Class of Device constants ***
+ *********************************/
+#define BTM_FORMAT_TYPE_1   0x00
+
+/****************************
+** minor device class field
+*****************************/
+
+/* 0x00 is used as unclassified for all minor device classes */
+#define BTM_COD_MINOR_UNCLASSIFIED          0x00
+
+/* minor device class field for Computer Major Class */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+#define BTM_COD_MINOR_DESKTOP_WORKSTATION   0x04
+#define BTM_COD_MINOR_SERVER_COMPUTER       0x08
+#define BTM_COD_MINOR_LAPTOP                0x0C
+#define BTM_COD_MINOR_HANDHELD_PC_PDA       0x10    /* clam shell */
+#define BTM_COD_MINOR_PALM_SIZE_PC_PDA      0x14
+#define BTM_COD_MINOR_WEARABLE_COMPUTER     0x18    /* watch sized */
+
+/* minor device class field for Phone Major Class */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+#define BTM_COD_MINOR_CELLULAR              0x04
+#define BTM_COD_MINOR_CORDLESS              0x08
+#define BTM_COD_MINOR_SMART_PHONE           0x0C
+#define BTM_COD_MINOR_WIRED_MDM_V_GTWY      0x10 /* wired modem or voice gatway */
+#define BTM_COD_MINOR_ISDN_ACCESS           0x14
+
+/* minor device class field for LAN Access Point Major Class */
+/* Load Factor Field bit 5-7 */
+#define BTM_COD_MINOR_FULLY_AVAILABLE       0x00
+#define BTM_COD_MINOR_1_17_UTILIZED         0x20
+#define BTM_COD_MINOR_17_33_UTILIZED        0x40
+#define BTM_COD_MINOR_33_50_UTILIZED        0x60
+#define BTM_COD_MINOR_50_67_UTILIZED        0x80
+#define BTM_COD_MINOR_67_83_UTILIZED        0xA0
+#define BTM_COD_MINOR_83_99_UTILIZED        0xC0
+#define BTM_COD_MINOR_NO_SERVICE_AVAILABLE  0xE0
+/* sub-Field bit 2-4 */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+
+/* minor device class field for Audio/Video Major Class */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+#define BTM_COD_MINOR_CONFM_HEADSET         0x04
+#define BTM_COD_MINOR_CONFM_HANDSFREE       0x08
+#define BTM_COD_MINOR_MICROPHONE            0x10
+#define BTM_COD_MINOR_LOUDSPEAKER           0x14
+#define BTM_COD_MINOR_HEADPHONES            0x18
+#define BTM_COD_MINOR_PORTABLE_AUDIO        0x1C
+#define BTM_COD_MINOR_CAR_AUDIO             0x20
+#define BTM_COD_MINOR_SET_TOP_BOX           0x24
+#define BTM_COD_MINOR_HIFI_AUDIO            0x28
+#define BTM_COD_MINOR_VCR                   0x2C
+#define BTM_COD_MINOR_VIDEO_CAMERA          0x30
+#define BTM_COD_MINOR_CAMCORDER             0x34
+#define BTM_COD_MINOR_VIDEO_MONITOR         0x38
+#define BTM_COD_MINOR_VIDDISP_LDSPKR        0x3C
+#define BTM_COD_MINOR_VIDEO_CONFERENCING    0x40
+#define BTM_COD_MINOR_GAMING_TOY            0x48
+
+/* minor device class field for Peripheral Major Class */
+/* Bits 6-7 independently specify mouse, keyboard, or combo mouse/keyboard */
+#define BTM_COD_MINOR_KEYBOARD              0x40
+#define BTM_COD_MINOR_POINTING              0x80
+#define BTM_COD_MINOR_COMBO                 0xC0
+/* Bits 2-5 OR'd with selection from bits 6-7 */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+#define BTM_COD_MINOR_JOYSTICK              0x04
+#define BTM_COD_MINOR_GAMEPAD               0x08
+#define BTM_COD_MINOR_REMOTE_CONTROL        0x0C
+#define BTM_COD_MINOR_SENSING_DEVICE        0x10
+#define BTM_COD_MINOR_DIGITIZING_TABLET     0x14
+#define BTM_COD_MINOR_CARD_READER           0x18    /* e.g. SIM card reader */
+#define BTM_COD_MINOR_DIGITAL_PAN           0x1C
+#define BTM_COD_MINOR_HAND_SCANNER          0x20
+#define BTM_COD_MINOR_HAND_GESTURAL_INPUT   0x24
+
+/* minor device class field for Imaging Major Class */
+/* Bits 5-7 independently specify display, camera, scanner, or printer */
+#define BTM_COD_MINOR_DISPLAY               0x10
+#define BTM_COD_MINOR_CAMERA                0x20
+#define BTM_COD_MINOR_SCANNER               0x40
+#define BTM_COD_MINOR_PRINTER               0x80
+/* Bits 2-3 Reserved */
+/* #define BTM_COD_MINOR_UNCLASSIFIED       0x00    */
+
+/* minor device class field for Wearable Major Class */
+/* Bits 2-7 meaningful    */
+#define BTM_COD_MINOR_WRIST_WATCH           0x04
+#define BTM_COD_MINOR_PAGER                 0x08
+#define BTM_COD_MINOR_JACKET                0x0C
+#define BTM_COD_MINOR_HELMET                0x10
+#define BTM_COD_MINOR_GLASSES               0x14
+
+/* minor device class field for Toy Major Class */
+/* Bits 2-7 meaningful    */
+#define BTM_COD_MINOR_ROBOT                 0x04
+#define BTM_COD_MINOR_VEHICLE               0x08
+#define BTM_COD_MINOR_DOLL_ACTION_FIGURE    0x0C
+#define BTM_COD_MINOR_CONTROLLER            0x10
+#define BTM_COD_MINOR_GAME                  0x14
+
+/* minor device class field for Health Major Class */
+/* Bits 2-7 meaningful    */
+#define BTM_COD_MINOR_BLOOD_MONITOR         0x04
+#define BTM_COD_MINOR_THERMOMETER           0x08
+#define BTM_COD_MINOR_WEIGHING_SCALE        0x0C
+#define BTM_COD_MINOR_GLUCOSE_METER         0x10
+#define BTM_COD_MINOR_PULSE_OXIMETER        0x14
+#define BTM_COD_MINOR_HEART_PULSE_MONITOR   0x18
+#define BTM_COD_MINOR_HEALTH_DATA_DISPLAY   0x1C
+#define BTM_COD_MINOR_STEP_COUNTER          0x20
+#define BTM_COD_MINOR_BODY_COM_ANALYZER     0x24
+#define BTM_COD_MINOR_PEAK_FLOW_MONITOR     0x28
+#define BTM_COD_MINOR_MEDICATION_MONITOR    0x2C
+#define BTM_COD_MINOR_KNEE_PROSTHESIS       0x30
+#define BTM_COD_MINOR_ANKLE_PROSTHESIS      0x34
+
+
+/***************************
+** major device class field
+****************************/
+#define BTM_COD_MAJOR_MISCELLANEOUS         0x00
+#define BTM_COD_MAJOR_COMPUTER              0x01
+#define BTM_COD_MAJOR_PHONE                 0x02
+#define BTM_COD_MAJOR_LAN_ACCESS_PT         0x03
+#define BTM_COD_MAJOR_AUDIO                 0x04
+#define BTM_COD_MAJOR_PERIPHERAL            0x05
+#define BTM_COD_MAJOR_IMAGING               0x06
+#define BTM_COD_MAJOR_WEARABLE              0x07
+#define BTM_COD_MAJOR_TOY                   0x08
+#define BTM_COD_MAJOR_HEALTH                0x09
+#define BTM_COD_MAJOR_UNCLASSIFIED          0x1F
+
+/***************************
+** service class fields
+****************************/
+#define BTM_COD_SERVICE_LMTD_DISCOVER       0x0020
+#define BTM_COD_SERVICE_POSITIONING         0x0100
+#define BTM_COD_SERVICE_NETWORKING          0x0200
+#define BTM_COD_SERVICE_RENDERING           0x0400
+#define BTM_COD_SERVICE_CAPTURING           0x0800
+#define BTM_COD_SERVICE_OBJ_TRANSFER        0x1000
+#define BTM_COD_SERVICE_AUDIO               0x2000
+#define BTM_COD_SERVICE_TELEPHONY           0x4000
+#define BTM_COD_SERVICE_INFORMATION         0x8000
+
+/* class of device field macros */
+#define BTM_COD_FORMAT_TYPE(u8, pd)         {u8  = pd[2]&0x03;}
+#define BTM_COD_MINOR_CLASS(u8, pd)         {u8  = pd[2]&0xFC;}
+#define BTM_COD_MAJOR_CLASS(u8, pd)         {u8  = pd[1]&0x1F;}
+#define BTM_COD_SERVICE_CLASS(u16, pd)      {u16 = pd[0]; u16<<=8; u16 += pd[1]&0xE0;}
+
+/* to set the fields (assumes that format type is always 0) */
+#define FIELDS_TO_COD(pd, mn, mj, sv) {pd[2] = mn; pd[1] =              \
+                                       mj+ ((sv)&BTM_COD_SERVICE_CLASS_LO_B); \
+                                       pd[0] = (sv) >> 8;}
+
+/* the COD masks */
+#define BTM_COD_FORMAT_TYPE_MASK      0x03
+#define BTM_COD_MINOR_CLASS_MASK      0xFC
+#define BTM_COD_MAJOR_CLASS_MASK      0x1F
+#define BTM_COD_SERVICE_CLASS_LO_B    0x00E0
+#define BTM_COD_SERVICE_CLASS_MASK    0xFFE0
+
+
+/* BTM service definitions
+** Used for storing EIR data to bit mask
+*/
+enum
+{
+    BTM_EIR_UUID_SERVCLASS_SERVICE_DISCOVERY_SERVER,
+/*    BTM_EIR_UUID_SERVCLASS_BROWSE_GROUP_DESCRIPTOR,   */
+/*    BTM_EIR_UUID_SERVCLASS_PUBLIC_BROWSE_GROUP,       */
+    BTM_EIR_UUID_SERVCLASS_SERIAL_PORT,
+    BTM_EIR_UUID_SERVCLASS_LAN_ACCESS_USING_PPP,
+    BTM_EIR_UUID_SERVCLASS_DIALUP_NETWORKING,
+    BTM_EIR_UUID_SERVCLASS_IRMC_SYNC,
+    BTM_EIR_UUID_SERVCLASS_OBEX_OBJECT_PUSH,
+    BTM_EIR_UUID_SERVCLASS_OBEX_FILE_TRANSFER,
+    BTM_EIR_UUID_SERVCLASS_IRMC_SYNC_COMMAND,
+    BTM_EIR_UUID_SERVCLASS_HEADSET,
+    BTM_EIR_UUID_SERVCLASS_CORDLESS_TELEPHONY,
+    BTM_EIR_UUID_SERVCLASS_AUDIO_SOURCE,
+    BTM_EIR_UUID_SERVCLASS_AUDIO_SINK,
+    BTM_EIR_UUID_SERVCLASS_AV_REM_CTRL_TARGET,
+/*    BTM_EIR_UUID_SERVCLASS_ADV_AUDIO_DISTRIBUTION,    */
+    BTM_EIR_UUID_SERVCLASS_AV_REMOTE_CONTROL,
+/*    BTM_EIR_UUID_SERVCLASS_VIDEO_CONFERENCING,        */
+    BTM_EIR_UUID_SERVCLASS_INTERCOM,
+    BTM_EIR_UUID_SERVCLASS_FAX,
+    BTM_EIR_UUID_SERVCLASS_HEADSET_AUDIO_GATEWAY,
+/*    BTM_EIR_UUID_SERVCLASS_WAP,                       */
+/*    BTM_EIR_UUID_SERVCLASS_WAP_CLIENT,                */
+    BTM_EIR_UUID_SERVCLASS_PANU,
+    BTM_EIR_UUID_SERVCLASS_NAP,
+    BTM_EIR_UUID_SERVCLASS_GN,
+    BTM_EIR_UUID_SERVCLASS_DIRECT_PRINTING,
+/*    BTM_EIR_UUID_SERVCLASS_REFERENCE_PRINTING,        */
+    BTM_EIR_UUID_SERVCLASS_IMAGING,
+    BTM_EIR_UUID_SERVCLASS_IMAGING_RESPONDER,
+    BTM_EIR_UUID_SERVCLASS_IMAGING_AUTO_ARCHIVE,
+    BTM_EIR_UUID_SERVCLASS_IMAGING_REF_OBJECTS,
+    BTM_EIR_UUID_SERVCLASS_HF_HANDSFREE,
+    BTM_EIR_UUID_SERVCLASS_AG_HANDSFREE,
+    BTM_EIR_UUID_SERVCLASS_DIR_PRT_REF_OBJ_SERVICE,
+/*    BTM_EIR_UUID_SERVCLASS_REFLECTED_UI,              */
+    BTM_EIR_UUID_SERVCLASS_BASIC_PRINTING,
+    BTM_EIR_UUID_SERVCLASS_PRINTING_STATUS,
+    BTM_EIR_UUID_SERVCLASS_HUMAN_INTERFACE,
+    BTM_EIR_UUID_SERVCLASS_CABLE_REPLACEMENT,
+    BTM_EIR_UUID_SERVCLASS_HCRP_PRINT,
+    BTM_EIR_UUID_SERVCLASS_HCRP_SCAN,
+/*    BTM_EIR_UUID_SERVCLASS_COMMON_ISDN_ACCESS,        */
+/*    BTM_EIR_UUID_SERVCLASS_VIDEO_CONFERENCING_GW,     */
+/*    BTM_EIR_UUID_SERVCLASS_UDI_MT,                    */
+/*    BTM_EIR_UUID_SERVCLASS_UDI_TA,                    */
+/*    BTM_EIR_UUID_SERVCLASS_VCP,                       */
+    BTM_EIR_UUID_SERVCLASS_SAP,
+    BTM_EIR_UUID_SERVCLASS_PBAP_PCE,
+    BTM_EIR_UUID_SERVCLASS_PBAP_PSE,
+/*    BTM_EIR_UUID_SERVCLASS_TE_PHONE_ACCESS,           */
+/*    BTM_EIR_UUID_SERVCLASS_ME_PHONE_ACCESS,           */
+    BTM_EIR_UUID_SERVCLASS_PHONE_ACCESS,
+    BTM_EIR_UUID_SERVCLASS_HEADSET_HS,
+    BTM_EIR_UUID_SERVCLASS_PNP_INFORMATION,
+/*    BTM_EIR_UUID_SERVCLASS_GENERIC_NETWORKING,        */
+/*    BTM_EIR_UUID_SERVCLASS_GENERIC_FILETRANSFER,      */
+/*    BTM_EIR_UUID_SERVCLASS_GENERIC_AUDIO,             */
+/*    BTM_EIR_UUID_SERVCLASS_GENERIC_TELEPHONY,         */
+/*    BTM_EIR_UUID_SERVCLASS_UPNP_SERVICE,              */
+/*    BTM_EIR_UUID_SERVCLASS_UPNP_IP_SERVICE,           */
+/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_PAN,          */
+/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_LAP,          */
+/*    BTM_EIR_UUID_SERVCLASS_ESDP_UPNP_IP_L2CAP,        */
+    BTM_EIR_UUID_SERVCLASS_VIDEO_SOURCE,
+    BTM_EIR_UUID_SERVCLASS_VIDEO_SINK,
+/*    BTM_EIR_UUID_SERVCLASS_VIDEO_DISTRIBUTION         */
+/*    BTM_EIR_UUID_SERVCLASS_HDP_PROFILE                */
+    BTM_EIR_UUID_SERVCLASS_MESSAGE_ACCESS,
+    BTM_EIR_UUID_SERVCLASS_MESSAGE_NOTIFICATION,
+    BTM_EIR_UUID_SERVCLASS_HDP_SOURCE,
+    BTM_EIR_UUID_SERVCLASS_HDP_SINK,
+    BTM_EIR_MAX_SERVICES
+};
+
+/* search result in EIR of inquiry database */
+#define BTM_EIR_FOUND           0
+#define BTM_EIR_NOT_FOUND       1
+#define BTM_EIR_UNKNOWN         2
+
+typedef UINT8 tBTM_EIR_SEARCH_RESULT;
+
+#define BTM_EIR_FLAGS_TYPE                  HCI_EIR_FLAGS_TYPE                  /* 0x01 */
+#define BTM_EIR_MORE_16BITS_UUID_TYPE       HCI_EIR_MORE_16BITS_UUID_TYPE       /* 0x02 */
+#define BTM_EIR_COMPLETE_16BITS_UUID_TYPE   HCI_EIR_COMPLETE_16BITS_UUID_TYPE   /* 0x03 */
+#define BTM_EIR_MORE_32BITS_UUID_TYPE       HCI_EIR_MORE_32BITS_UUID_TYPE       /* 0x04 */
+#define BTM_EIR_COMPLETE_32BITS_UUID_TYPE   HCI_EIR_COMPLETE_32BITS_UUID_TYPE   /* 0x05 */
+#define BTM_EIR_MORE_128BITS_UUID_TYPE      HCI_EIR_MORE_128BITS_UUID_TYPE      /* 0x06 */
+#define BTM_EIR_COMPLETE_128BITS_UUID_TYPE  HCI_EIR_COMPLETE_128BITS_UUID_TYPE  /* 0x07 */
+#define BTM_EIR_SHORTENED_LOCAL_NAME_TYPE   HCI_EIR_SHORTENED_LOCAL_NAME_TYPE   /* 0x08 */
+#define BTM_EIR_COMPLETE_LOCAL_NAME_TYPE    HCI_EIR_COMPLETE_LOCAL_NAME_TYPE    /* 0x09 */
+#define BTM_EIR_TX_POWER_LEVEL_TYPE         HCI_EIR_TX_POWER_LEVEL_TYPE         /* 0x0A */
+#define BTM_EIR_MANUFACTURER_SPECIFIC_TYPE  HCI_EIR_MANUFACTURER_SPECIFIC_TYPE  /* 0xFF */
+
+/* the following EIR tags are defined to OOB, not regular EIR data */
+#define BTM_EIR_OOB_BD_ADDR_TYPE            HCI_EIR_OOB_BD_ADDR_TYPE    /* 6 bytes */
+#define BTM_EIR_OOB_COD_TYPE                HCI_EIR_OOB_COD_TYPE        /* 3 bytes */
+#define BTM_EIR_OOB_SSP_HASH_C_TYPE         HCI_EIR_OOB_SSP_HASH_C_TYPE /* 16 bytes */
+#define BTM_EIR_OOB_SSP_RAND_R_TYPE         HCI_EIR_OOB_SSP_RAND_R_TYPE /* 16 bytes */
+
+#define BTM_OOB_MANDATORY_SIZE      8   /* include 2 bytes length & 6 bytes bd_addr */
+#define BTM_OOB_DATA_LEN_SIZE       2
+#define BTM_OOB_BD_ADDR_SIZE        6
+#define BTM_OOB_COD_SIZE            BT_OOB_COD_SIZE
+#define BTM_OOB_HASH_C_SIZE         BT_OOB_HASH_C_SIZE
+#define BTM_OOB_RAND_R_SIZE         BT_OOB_RAND_R_SIZE
+
+#define BTM_BLE_SEC_NONE                0
+#define BTM_BLE_SEC_ENCRYPT             1 /* encrypt the link using current key */
+#define BTM_BLE_SEC_ENCRYPT_NO_MITM     2
+#define BTM_BLE_SEC_ENCRYPT_MITM        3
+typedef UINT8   tBTM_BLE_SEC_ACT;
+
+/************************************************************************************************
+** BTM Services MACROS handle array of UINT32 bits for more than 32 services
+*************************************************************************************************/
+/* Determine the number of UINT32's necessary for services */
+#define BTM_EIR_ARRAY_BITS          32          /* Number of bits in each array element */
+#define BTM_EIR_SERVICE_ARRAY_SIZE  (((UINT32)BTM_EIR_MAX_SERVICES / BTM_EIR_ARRAY_BITS) + \
+                                    (((UINT32)BTM_EIR_MAX_SERVICES % BTM_EIR_ARRAY_BITS) ? 1 : 0))
+
+/* MACRO to set the service bit mask in a bit stream */
+#define BTM_EIR_SET_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] |=  \
+                                    ((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS)))
+
+
+/* MACRO to clear the service bit mask in a bit stream */
+#define BTM_EIR_CLR_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] &=  \
+                                    ~((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS)))
+
+/* MACRO to check the service bit mask in a bit stream */
+#define BTM_EIR_HAS_SERVICE(p, service)  ((((UINT32 *)(p))[(((UINT32)(service)) / BTM_EIR_ARRAY_BITS)] &  \
+                                    ((UINT32)1 << (((UINT32)(service)) % BTM_EIR_ARRAY_BITS))) >> (((UINT32)(service)) % BTM_EIR_ARRAY_BITS))
+
+/* start of EIR in HCI buffer, 4 bytes = HCI Command(2) + Length(1) + FEC_Req(1) */
+#define BTM_HCI_EIR_OFFSET          (BT_HDR_SIZE + 4)
+
+/***************************
+**  Device Discovery Types
+****************************/
+/* Definitions of the parameters passed to BTM_StartInquiry and
+** BTM_SetPeriodicInquiryMode.
+*/
+typedef struct              /* contains the two device class condition fields */
+{
+    DEV_CLASS       dev_class;
+    DEV_CLASS       dev_class_mask;
+} tBTM_COD_COND;
+
+
+typedef union               /* contains the inquiry filter condition */
+{
+    BD_ADDR         bdaddr_cond;
+    tBTM_COD_COND   cod_cond;
+} tBTM_INQ_FILT_COND;
+
+
+typedef struct              /* contains the parameters passed to the inquiry functions */
+{
+    UINT8   mode;                       /* general or limited */
+    UINT8   duration;                   /* duration of the inquiry (1.28 sec increments) */
+    UINT8   max_resps;                  /* maximum number of responses to return */
+    BOOLEAN report_dup;                 /* report duplicated inquiry response with higher RSSI value */
+    UINT8   filter_cond_type;           /* new devices, BD ADDR, COD, or No filtering */
+    tBTM_INQ_FILT_COND  filter_cond;    /* filter value based on filter cond type */
+#if (defined(BTA_HOST_INTERLEAVE_SEARCH) && BTA_HOST_INTERLEAVE_SEARCH == TRUE)
+    UINT8   intl_duration[4];              /*duration array storing the interleave scan's time portions*/
+#endif
+} tBTM_INQ_PARMS;
+
+#define BTM_INQ_RESULT_BR       0x01
+#define BTM_INQ_RESULT_BLE      0x02
+
+#if (BLE_INCLUDED == TRUE)
+#define BTM_BLE_EVT_CONN_ADV        0x00
+#define BTM_BLE_EVT_CONN_DIR_ADV    0x01
+#define BTM_BLE_EVT_DISC_ADV        0x02
+#define BTM_BLE_EVT_NON_CONN_ADV    0x03
+#define BTM_BLE_EVT_SCAN_RSP        0x04
+typedef UINT8 tBTM_BLE_EVT_TYPE;
+#endif
+
+/* These are the fields returned in each device's response to the inquiry.  It
+** is returned in the results callback if registered.
+*/
+typedef struct
+{
+    UINT16      clock_offset;
+    BD_ADDR     remote_bd_addr;
+    DEV_CLASS   dev_class;
+    UINT8       page_scan_rep_mode;
+    UINT8       page_scan_per_mode;
+    UINT8       page_scan_mode;
+    INT8        rssi;       /* Set to BTM_INQ_RES_IGNORE_RSSI if  not valid */
+    UINT32      eir_uuid[BTM_EIR_SERVICE_ARRAY_SIZE];
+    BOOLEAN     eir_complete_list;
+#if (BLE_INCLUDED == TRUE)
+    tBT_DEVICE_TYPE         device_type;
+    UINT8       inq_result_type;
+    UINT8       ble_addr_type;
+    tBTM_BLE_EVT_TYPE       ble_evt_type;
+    UINT8                   flag;
+#endif
+} tBTM_INQ_RESULTS;
+
+
+/* This is the inquiry response information held in its database by BTM, and available
+** to applications via BTM_InqDbRead, BTM_InqDbFirst, and BTM_InqDbNext.
+*/
+typedef struct
+{
+    tBTM_INQ_RESULTS    results;
+
+    BOOLEAN             appl_knows_rem_name;    /* set by application if it knows the remote name of the peer device.
+                                                   This is later used by application to determine if remote name request is
+                                                   required to be done. Having the flag here avoid duplicate store of inquiry results */
+#if ( BLE_INCLUDED == TRUE)
+    UINT16          remote_name_len;
+    tBTM_BD_NAME    remote_name;
+    UINT8           remote_name_state;
+    UINT8           remote_name_type;
+#endif
+
+} tBTM_INQ_INFO;
+
+
+/* Structure returned with inquiry complete callback */
+typedef struct
+{
+    tBTM_STATUS status;
+    UINT8       num_resp;       /* Number of results from the current inquiry */
+} tBTM_INQUIRY_CMPL;
+
+
+/* Structure returned with remote name  request */
+typedef struct
+{
+    UINT16      status;
+    BD_ADDR     bd_addr;
+    UINT16      length;
+    BD_NAME     remote_bd_name;
+} tBTM_REMOTE_DEV_NAME;
+
+typedef struct
+{
+    UINT8   pcm_intf_rate;  /* PCM interface rate: 0: 128kbps, 1: 256 kbps;
+                                2:512 bps; 3: 1024kbps; 4: 2048kbps */
+    UINT8   frame_type;     /* frame type: 0: short; 1: long */
+    UINT8   sync_mode;      /* sync mode: 0: slave; 1: master */
+    UINT8   clock_mode;     /* clock mode: 0: slave; 1: master */
+
+}tBTM_SCO_PCM_PARAM;
+
+/****************************************
+**  Device Discovery Callback Functions
+*****************************************/
+/* Callback function for asynchronous notifications when the BTM inquiry DB
+** changes. First param is inquiry database, second is if added to or removed
+** from the inquiry database.
+*/
+typedef void (tBTM_INQ_DB_CHANGE_CB) (void *p1, BOOLEAN is_new);
+
+/* Callback function for notifications when the BTM gets inquiry response.
+** First param is inquiry results database, second is pointer of EIR.
+*/
+typedef void (tBTM_INQ_RESULTS_CB) (tBTM_INQ_RESULTS *p_inq_results, UINT8 *p_eir);
+
+/*****************************************************************************
+**  ACL CHANNEL MANAGEMENT
+*****************************************************************************/
+/******************
+**  ACL Constants
+*******************/
+
+/* ACL modes */
+#define BTM_ACL_MODE_NORMAL     HCI_MODE_ACTIVE
+#define BTM_ACL_MODE_HOLD       HCI_MODE_HOLD
+#define BTM_ACL_MODE_SNIFF      HCI_MODE_SNIFF
+#define BTM_ACL_MODE_PARK       HCI_MODE_PARK
+
+/* Returned with structure in role switch callback (tBTM_ROLE_SWITCH_CMPL) */
+#define BTM_ROLE_MASTER         HCI_ROLE_MASTER
+#define BTM_ROLE_SLAVE          HCI_ROLE_SLAVE
+#define BTM_ROLE_UNDEFINED      0xff     /* undefined value (error status) */
+
+/* ACL Packet Types */
+#define BTM_ACL_PKT_TYPES_MASK_DM1      HCI_PKT_TYPES_MASK_DM1
+#define BTM_ACL_PKT_TYPES_MASK_DH1      HCI_PKT_TYPES_MASK_DH1
+#define BTM_ACL_PKT_TYPES_MASK_DM3      HCI_PKT_TYPES_MASK_DM3
+#define BTM_ACL_PKT_TYPES_MASK_DH3      HCI_PKT_TYPES_MASK_DH3
+#define BTM_ACL_PKT_TYPES_MASK_DM5      HCI_PKT_TYPES_MASK_DM5
+#define BTM_ACL_PKT_TYPES_MASK_DH5      HCI_PKT_TYPES_MASK_DH5
+#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH1 HCI_PKT_TYPES_MASK_NO_2_DH1
+#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH1 HCI_PKT_TYPES_MASK_NO_3_DH1
+#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH3 HCI_PKT_TYPES_MASK_NO_2_DH3
+#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH3 HCI_PKT_TYPES_MASK_NO_3_DH3
+#define BTM_ACL_PKT_TYPES_MASK_NO_2_DH5 HCI_PKT_TYPES_MASK_NO_2_DH5
+#define BTM_ACL_PKT_TYPES_MASK_NO_3_DH5 HCI_PKT_TYPES_MASK_NO_3_DH5
+
+/***************
+**  ACL Types
+****************/
+
+/* Structure returned with Role Switch information (in tBTM_CMPL_CB callback function)
+** in response to BTM_SwitchRole call.
+*/
+typedef struct
+{
+    UINT8   hci_status;     /* HCI status returned with the event */
+    UINT8   role;           /* BTM_ROLE_MASTER or BTM_ROLE_SLAVE */
+    BD_ADDR remote_bd_addr; /* Remote BD addr involved with the switch */
+} tBTM_ROLE_SWITCH_CMPL;
+
+/* Structure returned with QoS information (in tBTM_CMPL_CB callback function)
+** in response to BTM_SetQoS call.
+*/
+typedef struct
+{
+    FLOW_SPEC flow;
+    UINT16 handle;
+    UINT8 status;
+} tBTM_QOS_SETUP_CMPL;
+
+
+/* Structure returned with read RSSI event (in tBTM_CMPL_CB callback function)
+** in response to BTM_ReadRSSI call.
+*/
+typedef struct
+{
+    tBTM_STATUS status;
+    UINT8       hci_status;
+    INT8        rssi;
+    BD_ADDR     rem_bda;
+} tBTM_RSSI_RESULTS;
+
+/* Structure returned with read current TX power event (in tBTM_CMPL_CB callback function)
+** in response to BTM_ReadTxPower call.
+*/
+typedef struct
+{
+    tBTM_STATUS status;
+    UINT8       hci_status;
+    INT8        tx_power;
+    BD_ADDR     rem_bda;
+} tBTM_TX_POWER_RESULTS;
+
+/* Structure returned with read link quality event (in tBTM_CMPL_CB callback function)
+** in response to BTM_ReadLinkQuality call.
+*/
+typedef struct
+{
+    tBTM_STATUS status;
+    UINT8       hci_status;
+    UINT8       link_quality;
+    BD_ADDR     rem_bda;
+} tBTM_LINK_QUALITY_RESULTS;
+
+/* Structure returned with read inq tx power quality event (in tBTM_CMPL_CB callback function)
+** in response to BTM_ReadInquiryRspTxPower call.
+*/
+typedef struct
+{
+    tBTM_STATUS status;
+    UINT8       hci_status;
+    INT8        tx_power;
+} tBTM_INQ_TXPWR_RESULTS;
+
+enum
+{
+    BTM_BL_CONN_EVT,
+    BTM_BL_DISCN_EVT,
+    BTM_BL_UPDATE_EVT,
+    BTM_BL_ROLE_CHG_EVT,
+    BTM_BL_COLLISION_EVT
+};
+typedef UINT8 tBTM_BL_EVENT;
+typedef UINT16 tBTM_BL_EVENT_MASK;
+
+#define BTM_BL_CONN_MASK        0x0001
+#define BTM_BL_DISCN_MASK       0x0002
+#define BTM_BL_UPDATE_MASK      0x0004
+#define BTM_BL_ROLE_CHG_MASK    0x0008
+
+/* Device features mask definitions */
+#define BTM_FEATURE_BYTES_PER_PAGE  HCI_FEATURE_BYTES_PER_PAGE
+#define BTM_EXT_FEATURES_PAGE_MAX   HCI_EXT_FEATURES_PAGE_MAX
+
+/* the data type associated with BTM_BL_CONN_EVT */
+typedef struct
+{
+    tBTM_BL_EVENT   event;      /* The event reported. */
+    BD_ADDR_PTR     p_bda;      /* The address of the newly connected device */
+    DEV_CLASS_PTR   p_dc;       /* The device class */
+    BD_NAME_PTR     p_bdn;      /* The device name */
+    UINT8          *p_features; /* pointer to the remote device's features page[0] (supported features page) */
+#if BLE_INCLUDED == TRUE
+    UINT16          handle;     /* connection handle */
+    tBT_TRANSPORT   transport; /* link is LE or not */
+#endif
+} tBTM_BL_CONN_DATA;
+
+/* the data type associated with BTM_BL_DISCN_EVT */
+typedef struct
+{
+    tBTM_BL_EVENT   event;  /* The event reported. */
+    BD_ADDR_PTR     p_bda;  /* The address of the disconnected device */
+#if BLE_INCLUDED == TRUE
+    UINT16          handle; /* disconnected connection handle */
+    tBT_TRANSPORT   transport; /* link is LE link or not */
+#endif
+} tBTM_BL_DISCN_DATA;
+
+/* Busy-Level shall have the inquiry_paging mask set when
+ * inquiry/paging is in progress, Else the number of ACL links */
+#define BTM_BL_INQUIRY_PAGING_MASK 0x10
+#define BTM_BL_INQUIRY_STARTED   (BTM_BL_INQUIRY_PAGING_MASK | 0x1)
+#define BTM_BL_INQUIRY_CANCELLED (BTM_BL_INQUIRY_PAGING_MASK | 0x2)
+#define BTM_BL_INQUIRY_COMPLETE  (BTM_BL_INQUIRY_PAGING_MASK | 0x3)
+#define BTM_BL_PAGING_STARTED    (BTM_BL_INQUIRY_PAGING_MASK | 0x4)
+#define BTM_BL_PAGING_COMPLETE   (BTM_BL_INQUIRY_PAGING_MASK | 0x5)
+/* the data type associated with BTM_BL_UPDATE_EVT */
+typedef struct
+{
+    tBTM_BL_EVENT   event;  /* The event reported. */
+    UINT8           busy_level;/* when paging or inquiring, level is between
+                                  17 to 21 as the max links can be 16.
+                                * Otherwise, the number of ACL links. */
+    UINT8           busy_level_flags; /* Notifies actual inquiry/page activities */
+} tBTM_BL_UPDATE_DATA;
+
+/* the data type associated with BTM_BL_ROLE_CHG_EVT */
+typedef struct
+{
+    tBTM_BL_EVENT   event;      /* The event reported. */
+    BD_ADDR_PTR     p_bda;      /* The address of the peer connected device */
+    UINT8           new_role;
+    UINT8           hci_status; /* HCI status returned with the event */
+} tBTM_BL_ROLE_CHG_DATA;
+
+typedef union
+{
+    tBTM_BL_EVENT           event;  /* The event reported. */
+    tBTM_BL_CONN_DATA       conn;   /* The data associated with BTM_BL_CONN_EVT */
+    tBTM_BL_DISCN_DATA      discn;  /* The data associated with BTM_BL_DISCN_EVT */
+    tBTM_BL_UPDATE_DATA     update; /* The data associated with BTM_BL_UPDATE_EVT */
+    tBTM_BL_ROLE_CHG_DATA   role_chg;/*The data associated with BTM_BL_ROLE_CHG_EVT */
+} tBTM_BL_EVENT_DATA;
+
+/* Callback function for notifications when the BTM busy level
+** changes.
+*/
+typedef void (tBTM_BL_CHANGE_CB) (tBTM_BL_EVENT_DATA *p_data);
+
+/***************************
+**  ACL Callback Functions
+****************************/
+/* Callback function for notifications when the BTM ACL connection DB
+** changes. First param is BD address, second is if added or removed.
+** Registered through BTM_AclRegisterForChanges call.
+*/
+#if BLE_INCLUDED == TRUE
+typedef void (tBTM_ACL_DB_CHANGE_CB) (BD_ADDR p_bda, DEV_CLASS p_dc,
+                                      BD_NAME p_bdn, UINT8 *features,
+                                      BOOLEAN is_new, UINT16 handle,
+                                      tBT_TRANSPORT transport);
+#else
+typedef void (tBTM_ACL_DB_CHANGE_CB) (BD_ADDR p_bda, DEV_CLASS p_dc,
+                                      BD_NAME p_bdn, UINT8 *features,
+                                      BOOLEAN is_new);
+#endif
+/*****************************************************************************
+**  SCO CHANNEL MANAGEMENT
+*****************************************************************************/
+/******************
+**  SCO Constants
+*******************/
+
+/* Define an invalid SCO index and an invalid HCI handle */
+#define BTM_INVALID_SCO_INDEX       0xFFFF
+#define BTM_INVALID_HCI_HANDLE      0xFFFF
+
+/* Define an invalid SCO disconnect reason */
+#define BTM_INVALID_SCO_DISC_REASON 0xFFFF
+
+/* Define first active SCO index */
+#define BTM_FIRST_ACTIVE_SCO_INDEX  BTM_MAX_SCO_LINKS
+
+/* Define SCO packet types used in APIs */
+#define BTM_SCO_PKT_TYPES_MASK_HV1  HCI_ESCO_PKT_TYPES_MASK_HV1
+#define BTM_SCO_PKT_TYPES_MASK_HV2  HCI_ESCO_PKT_TYPES_MASK_HV2
+#define BTM_SCO_PKT_TYPES_MASK_HV3  HCI_ESCO_PKT_TYPES_MASK_HV3
+#define BTM_SCO_PKT_TYPES_MASK_EV3  HCI_ESCO_PKT_TYPES_MASK_EV3
+#define BTM_SCO_PKT_TYPES_MASK_EV4  HCI_ESCO_PKT_TYPES_MASK_EV4
+#define BTM_SCO_PKT_TYPES_MASK_EV5  HCI_ESCO_PKT_TYPES_MASK_EV5
+#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV3  HCI_ESCO_PKT_TYPES_MASK_NO_2_EV3
+#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV3  HCI_ESCO_PKT_TYPES_MASK_NO_3_EV3
+#define BTM_SCO_PKT_TYPES_MASK_NO_2_EV5  HCI_ESCO_PKT_TYPES_MASK_NO_2_EV5
+#define BTM_SCO_PKT_TYPES_MASK_NO_3_EV5  HCI_ESCO_PKT_TYPES_MASK_NO_3_EV5
+
+#define BTM_SCO_LINK_ONLY_MASK  (BTM_SCO_PKT_TYPES_MASK_HV1 | \
+                                 BTM_SCO_PKT_TYPES_MASK_HV2 | \
+                                 BTM_SCO_PKT_TYPES_MASK_HV3)
+
+#define BTM_ESCO_LINK_ONLY_MASK (BTM_SCO_PKT_TYPES_MASK_EV3 | \
+                                 BTM_SCO_PKT_TYPES_MASK_EV4 | \
+                                 BTM_SCO_PKT_TYPES_MASK_EV5)
+
+#define BTM_SCO_LINK_ALL_PKT_MASK   (BTM_SCO_LINK_ONLY_MASK     | \
+                                     BTM_ESCO_LINK_ONLY_MASK)
+
+#define BTM_VALID_SCO_ALL_PKT_TYPE HCI_VALID_SCO_ALL_PKT_TYPE
+
+/* Passed in BTM_CreateSco if the packet type parameter should be ignored */
+#define BTM_IGNORE_SCO_PKT_TYPE     0
+
+/***************
+**  SCO Types
+****************/
+#define BTM_LINK_TYPE_SCO           HCI_LINK_TYPE_SCO
+#define BTM_LINK_TYPE_ESCO          HCI_LINK_TYPE_ESCO
+typedef UINT8 tBTM_SCO_TYPE;
+
+
+/*******************
+** SCO Routing Path
+********************/
+#define BTM_SCO_ROUTE_PCM           HCI_BRCM_SCO_ROUTE_PCM
+#define BTM_SCO_ROUTE_HCI           HCI_BRCM_SCO_ROUTE_HCI
+typedef UINT8 tBTM_SCO_ROUTE_TYPE;
+
+
+/*******************
+** SCO Codec Types
+********************/
+// TODO(google) This should use common definitions
+// in hci/include/hci_audio.h
+#define BTM_SCO_CODEC_NONE          0x0000
+#define BTM_SCO_CODEC_CVSD          0x0001
+#define BTM_SCO_CODEC_MSBC          0x0002
+typedef UINT16 tBTM_SCO_CODEC_TYPE;
+
+
+
+/*******************
+** SCO Air Mode Types
+********************/
+#define BTM_SCO_AIR_MODE_U_LAW          0
+#define BTM_SCO_AIR_MODE_A_LAW          1
+#define BTM_SCO_AIR_MODE_CVSD           2
+#define BTM_SCO_AIR_MODE_TRANSPNT       3
+typedef UINT8 tBTM_SCO_AIR_MODE_TYPE;
+
+/*******************
+** SCO Voice Settings
+********************/
+#define BTM_VOICE_SETTING_CVSD  ((UINT16)  (HCI_INP_CODING_LINEAR          |   \
+                                            HCI_INP_DATA_FMT_2S_COMPLEMENT |   \
+                                            HCI_INP_SAMPLE_SIZE_16BIT      |   \
+                                            HCI_AIR_CODING_FORMAT_CVSD))
+
+#define BTM_VOICE_SETTING_TRANS ((UINT16)  (HCI_INP_CODING_LINEAR          |   \
+                                            HCI_INP_DATA_FMT_2S_COMPLEMENT |   \
+                                            HCI_INP_SAMPLE_SIZE_16BIT      |   \
+                                            HCI_AIR_CODING_FORMAT_TRANSPNT))
+
+/*******************
+** SCO Data Status
+********************/
+enum
+{
+    BTM_SCO_DATA_CORRECT,
+    BTM_SCO_DATA_PAR_ERR,
+    BTM_SCO_DATA_NONE,
+    BTM_SCO_DATA_PAR_LOST
+};
+typedef UINT8 tBTM_SCO_DATA_FLAG;
+
+/***************************
+**  SCO Callback Functions
+****************************/
+typedef void (tBTM_SCO_CB) (UINT16 sco_inx);
+typedef void (tBTM_SCO_DATA_CB) (UINT16 sco_inx, BT_HDR *p_data, tBTM_SCO_DATA_FLAG status);
+
+/******************
+**  eSCO Constants
+*******************/
+#define BTM_64KBITS_RATE            0x00001f40  /* 64 kbits/sec data rate */
+
+/* Retransmission effort */
+#define BTM_ESCO_RETRANS_OFF        0
+#define BTM_ESCO_RETRANS_POWER      1
+#define BTM_ESCO_RETRANS_QUALITY    2
+#define BTM_ESCO_RETRANS_DONTCARE   0xff
+
+/* Max Latency Don't Care */
+#define BTM_ESCO_MAX_LAT_DONTCARE   0xffff
+
+/***************
+**  eSCO Types
+****************/
+/* tBTM_ESCO_CBACK event types */
+#define BTM_ESCO_CHG_EVT        1
+#define BTM_ESCO_CONN_REQ_EVT   2
+typedef UINT8 tBTM_ESCO_EVT;
+
+/* Passed into BTM_SetEScoMode() */
+typedef struct
+{
+    UINT32 tx_bw;
+    UINT32 rx_bw;
+    UINT16 max_latency;
+    UINT16 voice_contfmt;  /* Voice Settings or Content Format */
+    UINT16 packet_types;
+    UINT8  retrans_effort;
+} tBTM_ESCO_PARAMS;
+
+typedef struct
+{
+    UINT16 max_latency;
+    UINT16 packet_types;
+    UINT8  retrans_effort;
+} tBTM_CHG_ESCO_PARAMS;
+
+/* Returned by BTM_ReadEScoLinkParms() */
+typedef struct
+{
+    UINT16  rx_pkt_len;
+    UINT16  tx_pkt_len;
+    BD_ADDR bd_addr;
+    UINT8   link_type;  /* BTM_LINK_TYPE_SCO or BTM_LINK_TYPE_ESCO */
+    UINT8   tx_interval;
+    UINT8   retrans_window;
+    UINT8   air_mode;
+} tBTM_ESCO_DATA;
+
+typedef struct
+{
+    UINT16  sco_inx;
+    UINT16  rx_pkt_len;
+    UINT16  tx_pkt_len;
+    BD_ADDR bd_addr;
+    UINT8   hci_status;
+    UINT8   tx_interval;
+    UINT8   retrans_window;
+} tBTM_CHG_ESCO_EVT_DATA;
+
+typedef struct
+{
+    UINT16        sco_inx;
+    BD_ADDR       bd_addr;
+    DEV_CLASS     dev_class;
+    tBTM_SCO_TYPE link_type;
+} tBTM_ESCO_CONN_REQ_EVT_DATA;
+
+typedef union
+{
+    tBTM_CHG_ESCO_EVT_DATA      chg_evt;
+    tBTM_ESCO_CONN_REQ_EVT_DATA conn_evt;
+} tBTM_ESCO_EVT_DATA;
+
+/***************************
+**  eSCO Callback Functions
+****************************/
+typedef void (tBTM_ESCO_CBACK) (tBTM_ESCO_EVT event, tBTM_ESCO_EVT_DATA *p_data);
+
+
+/*****************************************************************************
+**  SECURITY MANAGEMENT
+*****************************************************************************/
+/*******************************
+**  Security Manager Constants
+********************************/
+
+/* Security Mode (BTM_SetSecurityMode) */
+#define BTM_SEC_MODE_UNDEFINED      0
+#define BTM_SEC_MODE_NONE           1
+#define BTM_SEC_MODE_SERVICE        2
+#define BTM_SEC_MODE_LINK           3
+#define BTM_SEC_MODE_SP             4
+#define BTM_SEC_MODE_SP_DEBUG       5
+#define BTM_SEC_MODE_SC             6
+
+/* Maximum Number of BTM Security Modes */
+#define BTM_SEC_MODES_MAX           7
+
+/* Security Service Levels [bit mask] (BTM_SetSecurityLevel)
+** Encryption should not be used without authentication
+*/
+#define BTM_SEC_NONE               0x0000 /* Nothing required */
+#define BTM_SEC_IN_AUTHORIZE       0x0001 /* Inbound call requires authorization */
+#define BTM_SEC_IN_AUTHENTICATE    0x0002 /* Inbound call requires authentication */
+#define BTM_SEC_IN_ENCRYPT         0x0004 /* Inbound call requires encryption */
+#define BTM_SEC_OUT_AUTHORIZE      0x0008 /* Outbound call requires authorization */
+#define BTM_SEC_OUT_AUTHENTICATE   0x0010 /* Outbound call requires authentication */
+#define BTM_SEC_OUT_ENCRYPT        0x0020 /* Outbound call requires encryption */
+#define BTM_SEC_MODE4_LEVEL4       0x0040 /* Secure Connections Only Mode */
+#define BTM_SEC_FORCE_MASTER       0x0100 /* Need to switch connection to be master */
+#define BTM_SEC_ATTEMPT_MASTER     0x0200 /* Try to switch connection to be master */
+#define BTM_SEC_FORCE_SLAVE        0x0400 /* Need to switch connection to be master */
+#define BTM_SEC_ATTEMPT_SLAVE      0x0800 /* Try to switch connection to be slave */
+#define BTM_SEC_IN_MITM            0x1000 /* inbound Do man in the middle protection */
+#define BTM_SEC_OUT_MITM           0x2000 /* outbound Do man in the middle protection */
+#define BTM_SEC_IN_MIN_16_DIGIT_PIN 0x4000 /* enforce a minimum of 16 digit for sec mode 2 */
+
+/* Security Flags [bit mask] (BTM_GetSecurityFlags)
+*/
+#define BTM_SEC_FLAG_AUTHORIZED     0x01
+#define BTM_SEC_FLAG_AUTHENTICATED  0x02
+#define BTM_SEC_FLAG_ENCRYPTED      0x04
+#define BTM_SEC_FLAG_LKEY_KNOWN     0x10
+#define BTM_SEC_FLAG_LKEY_AUTHED    0x20
+
+/* PIN types */
+#define BTM_PIN_TYPE_VARIABLE       HCI_PIN_TYPE_VARIABLE
+#define BTM_PIN_TYPE_FIXED          HCI_PIN_TYPE_FIXED
+
+/* Link Key types used to generate the new link key.
+** returned in link key notification callback function
+*/
+#define BTM_LKEY_TYPE_COMBINATION   HCI_LKEY_TYPE_COMBINATION
+#define BTM_LKEY_TYPE_LOCAL_UNIT    HCI_LKEY_TYPE_LOCAL_UNIT
+#define BTM_LKEY_TYPE_REMOTE_UNIT   HCI_LKEY_TYPE_REMOTE_UNIT
+#define BTM_LKEY_TYPE_DEBUG_COMB    HCI_LKEY_TYPE_DEBUG_COMB
+#define BTM_LKEY_TYPE_UNAUTH_COMB   HCI_LKEY_TYPE_UNAUTH_COMB
+#define BTM_LKEY_TYPE_AUTH_COMB     HCI_LKEY_TYPE_AUTH_COMB
+#define BTM_LKEY_TYPE_CHANGED_COMB  HCI_LKEY_TYPE_CHANGED_COMB
+
+#define BTM_LKEY_TYPE_UNAUTH_COMB_P_256 HCI_LKEY_TYPE_UNAUTH_COMB_P_256
+#define BTM_LKEY_TYPE_AUTH_COMB_P_256   HCI_LKEY_TYPE_AUTH_COMB_P_256
+
+#define BTM_LTK_DERIVED_LKEY_OFFSET 0x20    /* "easy" requirements for LK derived from LTK */
+#define BTM_LKEY_TYPE_IGNORE        0xff    /* used when event is response from
+                                               hci return link keys request */
+
+typedef UINT8 tBTM_LINK_KEY_TYPE;
+
+/* Protocol level security (BTM_SetSecurityLevel) */
+#define BTM_SEC_PROTO_L2CAP         0
+#define BTM_SEC_PROTO_SDP           1
+#define BTM_SEC_PROTO_TCS           2
+#define BTM_SEC_PROTO_RFCOMM        3
+#define BTM_SEC_PROTO_OBEX          4
+#define BTM_SEC_PROTO_BNEP          5
+#define BTM_SEC_PROTO_HID           6   /* HID      */
+#define BTM_SEC_PROTO_AVDT          7
+#define BTM_SEC_PROTO_MCA           8
+
+/* Determine the number of UINT32's necessary for security services */
+#define BTM_SEC_ARRAY_BITS          32          /* Number of bits in each array element */
+#define BTM_SEC_SERVICE_ARRAY_SIZE  (((UINT32)BTM_SEC_MAX_SERVICES / BTM_SEC_ARRAY_BITS) + \
+                                    (((UINT32)BTM_SEC_MAX_SERVICES % BTM_SEC_ARRAY_BITS) ? 1 : 0))
+
+/* Security service definitions (BTM_SetSecurityLevel)
+** Used for Authorization APIs
+*/
+#define BTM_SEC_SERVICE_SDP_SERVER      0
+#define BTM_SEC_SERVICE_SERIAL_PORT     1
+#define BTM_SEC_SERVICE_LAN_ACCESS      2
+#define BTM_SEC_SERVICE_DUN             3
+#define BTM_SEC_SERVICE_IRMC_SYNC       4
+#define BTM_SEC_SERVICE_IRMC_SYNC_CMD   5
+#define BTM_SEC_SERVICE_OBEX            6
+#define BTM_SEC_SERVICE_OBEX_FTP        7
+#define BTM_SEC_SERVICE_HEADSET         8
+#define BTM_SEC_SERVICE_CORDLESS        9
+#define BTM_SEC_SERVICE_INTERCOM        10
+#define BTM_SEC_SERVICE_FAX             11
+#define BTM_SEC_SERVICE_HEADSET_AG      12
+#define BTM_SEC_SERVICE_PNP_INFO        13
+#define BTM_SEC_SERVICE_GEN_NET         14
+#define BTM_SEC_SERVICE_GEN_FILE        15
+#define BTM_SEC_SERVICE_GEN_AUDIO       16
+#define BTM_SEC_SERVICE_GEN_TEL         17
+#define BTM_SEC_SERVICE_CTP_DATA        18
+#define BTM_SEC_SERVICE_HCRP_CTRL       19
+#define BTM_SEC_SERVICE_HCRP_DATA       20
+#define BTM_SEC_SERVICE_HCRP_NOTIF      21
+#define BTM_SEC_SERVICE_BPP_JOB         22
+#define BTM_SEC_SERVICE_BPP_STATUS      23
+#define BTM_SEC_SERVICE_BPP_REF         24
+#define BTM_SEC_SERVICE_BNEP_PANU       25
+#define BTM_SEC_SERVICE_BNEP_GN         26
+#define BTM_SEC_SERVICE_BNEP_NAP        27
+#define BTM_SEC_SERVICE_HF_HANDSFREE    28
+#define BTM_SEC_SERVICE_AG_HANDSFREE    29
+#define BTM_SEC_SERVICE_TE_PHONE_ACCESS 30
+#define BTM_SEC_SERVICE_ME_PHONE_ACCESS 31
+
+#define BTM_SEC_SERVICE_HIDH_SEC_CTRL   32
+#define BTM_SEC_SERVICE_HIDH_NOSEC_CTRL 33
+#define BTM_SEC_SERVICE_HIDH_INTR       34
+#define BTM_SEC_SERVICE_BIP             35
+#define BTM_SEC_SERVICE_BIP_REF         36
+#define BTM_SEC_SERVICE_AVDTP           37
+#define BTM_SEC_SERVICE_AVDTP_NOSEC     38
+#define BTM_SEC_SERVICE_AVCTP           39
+#define BTM_SEC_SERVICE_SAP             40
+#define BTM_SEC_SERVICE_PBAP            41
+#define BTM_SEC_SERVICE_RFC_MUX         42
+#define BTM_SEC_SERVICE_AVCTP_BROWSE    43
+#define BTM_SEC_SERVICE_MAP             44
+#define BTM_SEC_SERVICE_MAP_NOTIF       45
+#define BTM_SEC_SERVICE_MCAP_CTRL       46
+#define BTM_SEC_SERVICE_MCAP_DATA       47
+#define BTM_SEC_SERVICE_HDP_SNK         48
+#define BTM_SEC_SERVICE_HDP_SRC         49
+#define BTM_SEC_SERVICE_ATT             50
+
+/* Update these as services are added */
+#define BTM_SEC_SERVICE_FIRST_EMPTY     51
+
+#ifndef BTM_SEC_MAX_SERVICES
+#define BTM_SEC_MAX_SERVICES            75
+#endif
+
+/************************************************************************************************
+** Security Services MACROS handle array of UINT32 bits for more than 32 trusted services
+*************************************************************************************************/
+/* MACRO to set the security service bit mask in a bit stream */
+#define BTM_SEC_SET_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)] |=  \
+                                    ((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))
+
+
+/* MACRO to clear the security service bit mask in a bit stream */
+#define BTM_SEC_CLR_SERVICE(p, service)  (((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)] &=  \
+                                    ~((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))
+
+/* MACRO to check the security service bit mask in a bit stream (Returns TRUE or FALSE) */
+#define BTM_SEC_IS_SERVICE_TRUSTED(p, service)    (((((UINT32 *)(p))[(((UINT32)(service)) / BTM_SEC_ARRAY_BITS)]) &   \
+                                        (UINT32)(((UINT32)1 << (((UINT32)(service)) % BTM_SEC_ARRAY_BITS)))) ? TRUE : FALSE)
+
+/* MACRO to copy two trusted device bitmask */
+#define BTM_SEC_COPY_TRUSTED_DEVICE(p_src, p_dst)   {UINT32 trst; for (trst = 0; trst < BTM_SEC_SERVICE_ARRAY_SIZE; trst++) \
+                                                        ((UINT32 *)(p_dst))[trst] = ((UINT32 *)(p_src))[trst];}
+
+/* MACRO to clear two trusted device bitmask */
+#define BTM_SEC_CLR_TRUSTED_DEVICE(p_dst)   {UINT32 trst; for (trst = 0; trst < BTM_SEC_SERVICE_ARRAY_SIZE; trst++) \
+                                                        ((UINT32 *)(p_dst))[trst] = 0;}
+
+/* Following bits can be provided by host in the trusted_mask array */
+/* 0..31 bits of mask[0] (Least Significant Word) */
+#define BTM_SEC_TRUST_SDP_SERVER        (1 << BTM_SEC_SERVICE_SDP_SERVER)
+#define BTM_SEC_TRUST_SERIAL_PORT       (1 << BTM_SEC_SERVICE_SERIAL_PORT)
+#define BTM_SEC_TRUST_LAN_ACCESS        (1 << BTM_SEC_SERVICE_LAN_ACCESS)
+#define BTM_SEC_TRUST_DUN               (1 << BTM_SEC_SERVICE_DUN)
+#define BTM_SEC_TRUST_IRMC_SYNC         (1 << BTM_SEC_SERVICE_IRMC_SYNC)
+#define BTM_SEC_TRUST_IRMC_SYNC_CMD     (1 << BTM_SEC_SERVICE_IRMC_SYNC_CMD)
+#define BTM_SEC_TRUST_OBEX              (1 << BTM_SEC_SERVICE_OBEX)
+#define BTM_SEC_TRUST_OBEX_FTP          (1 << BTM_SEC_SERVICE_OBEX_FTP)
+#define BTM_SEC_TRUST_HEADSET           (1 << BTM_SEC_SERVICE_HEADSET)
+#define BTM_SEC_TRUST_CORDLESS          (1 << BTM_SEC_SERVICE_CORDLESS)
+#define BTM_SEC_TRUST_INTERCOM          (1 << BTM_SEC_SERVICE_INTERCOM)
+#define BTM_SEC_TRUST_FAX               (1 << BTM_SEC_SERVICE_FAX)
+#define BTM_SEC_TRUST_HEADSET_AG        (1 << BTM_SEC_SERVICE_HEADSET_AG)
+#define BTM_SEC_TRUST_PNP_INFO          (1 << BTM_SEC_SERVICE_PNP_INFO)
+#define BTM_SEC_TRUST_GEN_NET           (1 << BTM_SEC_SERVICE_GEN_NET)
+#define BTM_SEC_TRUST_GEN_FILE          (1 << BTM_SEC_SERVICE_GEN_FILE)
+#define BTM_SEC_TRUST_GEN_AUDIO         (1 << BTM_SEC_SERVICE_GEN_AUDIO)
+#define BTM_SEC_TRUST_GEN_TEL           (1 << BTM_SEC_SERVICE_GEN_TEL)
+#define BTM_SEC_TRUST_CTP_DATA          (1 << BTM_SEC_SERVICE_CTP_DATA)
+#define BTM_SEC_TRUST_HCRP_CTRL         (1 << BTM_SEC_SERVICE_HCRP_CTRL)
+#define BTM_SEC_TRUST_HCRP_DATA         (1 << BTM_SEC_SERVICE_HCRP_DATA)
+#define BTM_SEC_TRUST_HCRP_NOTIF        (1 << BTM_SEC_SERVICE_HCRP_NOTIF)
+#define BTM_SEC_TRUST_BPP_JOB           (1 << BTM_SEC_SERVICE_JOB)
+#define BTM_SEC_TRUST_BPP_STATUS        (1 << BTM_SEC_SERVICE_STATUS)
+#define BTM_SEC_TRUST_BPP_REF           (1 << BTM_SEC_SERVICE_REF)
+#define BTM_SEC_TRUST_BNEP_PANU         (1 << BTM_SEC_SERVICE_BNEP_PANU)
+#define BTM_SEC_TRUST_BNEP_GN           (1 << BTM_SEC_SERVICE_BNEP_GN)
+#define BTM_SEC_TRUST_BNEP_NAP          (1 << BTM_SEC_SERVICE_BNEP_NAP)
+#define BTM_SEC_TRUST_HFP_HF            (1 << BTM_SEC_SERVICE_HF_HANDSFREE)
+#define BTM_SEC_TRUST_HFP_AG            (1 << BTM_SEC_SERVICE_AG_HANDSFREE)
+#define BTM_SEC_TRUST_TE_PHONE_ACCESS   (1 << BTM_SEC_SERVICE_TE_PHONE_ACCESS)
+#define BTM_SEC_TRUST_ME_PHONE_ACCESS   (1 << BTM_SEC_SERVICE_ME_PHONE_ACCESS)
+
+/* 0..31 bits of mask[1] (Most Significant Word) */
+#define BTM_SEC_TRUST_HIDH_CTRL         (1 << (BTM_SEC_SERVICE_HIDH_SEC_CTRL - 32))
+#define BTM_SEC_TRUST_HIDH_NOSEC_CTRL   (1 << (BTM_SEC_SERVICE_HIDH_NOSEC_CTRL - 32))
+#define BTM_SEC_TRUST_HIDH_INTR         (1 << (BTM_SEC_SERVICE_HIDH_INTR - 32))
+#define BTM_SEC_TRUST_BIP               (1 << (BTM_SEC_SERVICE_BIP - 32))
+#define BTM_SEC_TRUST_BIP_REF           (1 << (BTM_SEC_SERVICE_BIP_REF - 32))
+#define BTM_SEC_TRUST_AVDTP             (1 << (BTM_SEC_SERVICE_AVDTP - 32))
+#define BTM_SEC_TRUST_AVDTP_NOSEC       (1 << (BTM_SEC_SERVICE_AVDTP_NOSEC - 32))
+#define BTM_SEC_TRUST_AVCTP             (1 << (BTM_SEC_SERVICE_AVCTP - 32))
+#define BTM_SEC_TRUST_SAP               (1 << (BTM_SEC_SERVICE_SAP - 32))
+#define BTM_SEC_TRUST_PBAP              (1 << (BTM_SEC_SERVICE_PBAP - 32))
+#define BTM_SEC_TRUST_RFC_MUX           (1 << (BTM_SEC_SERVICE_RFC_MUX - 32))
+#define BTM_SEC_TRUST_AVCTP_BROWSE      (1 << (BTM_SEC_SERVICE_AVCTP_BROWSE - 32))
+#define BTM_SEC_TRUST_MAP               (1 << (BTM_SEC_SERVICE_MAP - 32))
+#define BTM_SEC_TRUST_MAP_NOTIF         (1 << (BTM_SEC_SERVICE_MAP_NOTIF - 32))
+#define BTM_SEC_TRUST_MCAP_CTRL         (1 << (BTM_SEC_SERVICE_MCAP_CTRL - 32))
+#define BTM_SEC_TRUST_MCAP_DATA         (1 << (BTM_SEC_SERVICE_MCAP_DATA - 32))
+#define BTM_SEC_TRUST_HDP_SNK           (1 << (BTM_SEC_SERVICE_HDP_SNK - 32))
+#define BTM_SEC_TRUST_HDP_SRC           (1 << (BTM_SEC_SERVICE_HDP_SRC - 32))
+
+#define BTM_SEC_TRUST_ALL               0xFFFFFFFF  /* for each array element */
+
+/****************************************
+**  Security Manager Callback Functions
+*****************************************/
+/* Authorize device for service.  Parameters are
+**              BD Address of remote
+**              Device Class of remote
+**              BD Name of remote
+**              Service name
+**              Service Id (NULL - unknown service or unused
+**                                 [BTM_SEC_SERVICE_NAME_LEN set to 0])
+**              Is originator of the connection
+**              Result of the operation
+*/
+typedef UINT8 (tBTM_AUTHORIZE_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
+                                         tBTM_BD_NAME bd_name, UINT8 *service_name,
+                                         UINT8 service_id, BOOLEAN is_originator);
+
+/* Get PIN for the connection.  Parameters are
+**              BD Address of remote
+**              Device Class of remote
+**              BD Name of remote
+**              Flag indicating the minimum pin code length to be 16 digits
+*/
+typedef UINT8 (tBTM_PIN_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
+                                   tBTM_BD_NAME bd_name, BOOLEAN min_16_digit);
+
+/* New Link Key for the connection.  Parameters are
+**              BD Address of remote
+**              Link Key
+**              Key Type: Combination, Local Unit, or Remote Unit
+*/
+typedef UINT8 (tBTM_LINK_KEY_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
+                                        tBTM_BD_NAME bd_name, UINT8 *key,
+                                        UINT8 key_type);
+
+
+/* Remote Name Resolved.  Parameters are
+**              BD Address of remote
+**              BD Name of remote
+*/
+typedef void (tBTM_RMT_NAME_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dc,
+                                       tBTM_BD_NAME bd_name);
+
+
+/* Authentication complete for the connection.  Parameters are
+**              BD Address of remote
+**              Device Class of remote
+**              BD Name of remote
+**
+*/
+typedef UINT8 (tBTM_AUTH_COMPLETE_CALLBACK) (BD_ADDR bd_addr, DEV_CLASS dev_class,
+                                             tBTM_BD_NAME bd_name, int result);
+
+enum
+{
+    BTM_SP_IO_REQ_EVT,      /* received IO_CAPABILITY_REQUEST event */
+    BTM_SP_IO_RSP_EVT,      /* received IO_CAPABILITY_RESPONSE event */
+    BTM_SP_CFM_REQ_EVT,     /* received USER_CONFIRMATION_REQUEST event */
+    BTM_SP_KEY_NOTIF_EVT,   /* received USER_PASSKEY_NOTIFY event */
+    BTM_SP_KEY_REQ_EVT,     /* received USER_PASSKEY_REQUEST event */
+    BTM_SP_KEYPRESS_EVT,    /* received KEYPRESS_NOTIFY event */
+    BTM_SP_LOC_OOB_EVT,     /* received result for READ_LOCAL_OOB_DATA command */
+    BTM_SP_RMT_OOB_EVT,     /* received REMOTE_OOB_DATA_REQUEST event */
+    BTM_SP_COMPLT_EVT,      /* received SIMPLE_PAIRING_COMPLETE event */
+    BTM_SP_UPGRADE_EVT      /* check if the application wants to upgrade the link key */
+};
+typedef UINT8 tBTM_SP_EVT;
+
+#define BTM_IO_CAP_OUT      0   /* DisplayOnly */
+#define BTM_IO_CAP_IO       1   /* DisplayYesNo */
+#define BTM_IO_CAP_IN       2   /* KeyboardOnly */
+#define BTM_IO_CAP_NONE     3   /* NoInputNoOutput */
+#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
+#define BTM_IO_CAP_KBDISP   4   /* Keyboard display */
+#define BTM_IO_CAP_MAX      5
+#else
+#define BTM_IO_CAP_MAX      4
+#endif
+
+typedef UINT8 tBTM_IO_CAP;
+
+#define BTM_MAX_PASSKEY_VAL (999999)
+#define BTM_MIN_PASSKEY_VAL (0)
+
+#define BTM_AUTH_SP_NO      0   /* MITM Protection Not Required - Single Profile/non-bonding
+                                Numeric comparison with automatic accept allowed */
+#define BTM_AUTH_SP_YES     1   /* MITM Protection Required - Single Profile/non-bonding
+                                Use IO Capabilities to determine authentication procedure */
+#define BTM_AUTH_AP_NO      2   /* MITM Protection Not Required - All Profiles/dedicated bonding
+                                Numeric comparison with automatic accept allowed */
+#define BTM_AUTH_AP_YES     3   /* MITM Protection Required - All Profiles/dedicated bonding
+                                Use IO Capabilities to determine authentication procedure */
+#define BTM_AUTH_SPGB_NO    4   /* MITM Protection Not Required - Single Profiles/general bonding
+                                Numeric comparison with automatic accept allowed */
+#define BTM_AUTH_SPGB_YES   5   /* MITM Protection Required - Single Profiles/general bonding
+                                Use IO Capabilities to determine authentication procedure */
+#define BTM_AUTH_DD_BOND    2   /* this bit is ORed to the BTM_AUTH_SP_* when IO exchange for dedicated bonding */
+#define BTM_AUTH_GB_BIT     4   /* the genernal bonding bit */
+#define BTM_AUTH_BONDS      6   /* the general/dedicated bonding bits  */
+#define BTM_AUTH_YN_BIT     1   /* this is the Yes or No bit  */
+
+#define BTM_BLE_INITIATOR_KEY_SIZE 15
+#define BTM_BLE_RESPONDER_KEY_SIZE 15
+#define BTM_BLE_MAX_KEY_SIZE       16
+
+typedef UINT8 tBTM_AUTH_REQ;
+
+enum
+{
+    BTM_OOB_NONE,
+    BTM_OOB_PRESENT,
+    BTM_OOB_UNKNOWN
+};
+typedef UINT8 tBTM_OOB_DATA;
+
+/* data type for BTM_SP_IO_REQ_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    tBTM_IO_CAP     io_cap;         /* local IO capabilities */
+    tBTM_OOB_DATA   oob_data;       /* OOB data present (locally) for the peer device */
+    tBTM_AUTH_REQ   auth_req;       /* Authentication required (for local device) */
+    BOOLEAN         is_orig;        /* TRUE, if local device initiated the SP process */
+} tBTM_SP_IO_REQ;
+
+/* data type for BTM_SP_IO_RSP_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    tBTM_IO_CAP     io_cap;         /* peer IO capabilities */
+    tBTM_OOB_DATA   oob_data;       /* OOB data present at peer device for the local device */
+    tBTM_AUTH_REQ   auth_req;       /* Authentication required for peer device */
+} tBTM_SP_IO_RSP;
+
+/* data type for BTM_SP_CFM_REQ_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    DEV_CLASS       dev_class;      /* peer CoD */
+    tBTM_BD_NAME    bd_name;        /* peer device name */
+    UINT32          num_val;        /* the numeric value for comparison. If just_works, do not show this number to UI */
+    BOOLEAN         just_works;     /* TRUE, if "Just Works" association model */
+    tBTM_AUTH_REQ   loc_auth_req;   /* Authentication required for local device */
+    tBTM_AUTH_REQ   rmt_auth_req;   /* Authentication required for peer device */
+    tBTM_IO_CAP     loc_io_caps;    /* IO Capabilities of the local device */
+    tBTM_IO_CAP     rmt_io_caps;    /* IO Capabilities of the remot device */
+} tBTM_SP_CFM_REQ;
+
+/* data type for BTM_SP_KEY_REQ_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    DEV_CLASS       dev_class;      /* peer CoD */
+    tBTM_BD_NAME    bd_name;        /* peer device name */
+} tBTM_SP_KEY_REQ;
+
+/* data type for BTM_SP_KEY_NOTIF_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    DEV_CLASS       dev_class;      /* peer CoD */
+    tBTM_BD_NAME    bd_name;        /* peer device name */
+    UINT32          passkey;        /* passkey */
+} tBTM_SP_KEY_NOTIF;
+
+enum
+{
+    BTM_SP_KEY_STARTED,         /* 0 - passkey entry started */
+    BTM_SP_KEY_ENTERED,         /* 1 - passkey digit entered */
+    BTM_SP_KEY_ERASED,          /* 2 - passkey digit erased */
+    BTM_SP_KEY_CLEARED,         /* 3 - passkey cleared */
+    BTM_SP_KEY_COMPLT,          /* 4 - passkey entry completed */
+    BTM_SP_KEY_OUT_OF_RANGE     /* 5 - out of range */
+};
+typedef UINT8   tBTM_SP_KEY_TYPE;
+
+/* data type for BTM_SP_KEYPRESS_EVT */
+typedef struct
+{
+    BD_ADDR             bd_addr;        /* peer address */
+    tBTM_SP_KEY_TYPE   notif_type;
+} tBTM_SP_KEYPRESS;
+
+/* data type for BTM_SP_LOC_OOB_EVT */
+typedef struct
+{
+    tBTM_STATUS     status;         /* */
+    BT_OCTET16      c;              /* Simple Pairing Hash C */
+    BT_OCTET16      r;              /* Simple Pairing Randomnizer R */
+} tBTM_SP_LOC_OOB;
+
+/* data type for BTM_SP_RMT_OOB_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    DEV_CLASS       dev_class;      /* peer CoD */
+    tBTM_BD_NAME    bd_name;        /* peer device name */
+} tBTM_SP_RMT_OOB;
+
+
+/* data type for BTM_SP_COMPLT_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    DEV_CLASS       dev_class;      /* peer CoD */
+    tBTM_BD_NAME    bd_name;        /* peer device name */
+    tBTM_STATUS     status;         /* status of the simple pairing process */
+} tBTM_SP_COMPLT;
+
+/* data type for BTM_SP_UPGRADE_EVT */
+typedef struct
+{
+    BD_ADDR         bd_addr;        /* peer address */
+    BOOLEAN         upgrade;        /* TRUE, to upgrade the link key */
+} tBTM_SP_UPGRADE;
+
+typedef union
+{
+    tBTM_SP_IO_REQ      io_req;     /* BTM_SP_IO_REQ_EVT      */
+    tBTM_SP_IO_RSP      io_rsp;     /* BTM_SP_IO_RSP_EVT      */
+    tBTM_SP_CFM_REQ     cfm_req;    /* BTM_SP_CFM_REQ_EVT     */
+    tBTM_SP_KEY_NOTIF   key_notif;  /* BTM_SP_KEY_NOTIF_EVT   */
+    tBTM_SP_KEY_REQ     key_req;    /* BTM_SP_KEY_REQ_EVT     */
+    tBTM_SP_KEYPRESS    key_press;  /* BTM_SP_KEYPRESS_EVT    */
+    tBTM_SP_LOC_OOB     loc_oob;    /* BTM_SP_LOC_OOB_EVT     */
+    tBTM_SP_RMT_OOB     rmt_oob;    /* BTM_SP_RMT_OOB_EVT     */
+    tBTM_SP_COMPLT      complt;     /* BTM_SP_COMPLT_EVT      */
+    tBTM_SP_UPGRADE     upgrade;    /* BTM_SP_UPGRADE_EVT      */
+} tBTM_SP_EVT_DATA;
+
+/* Simple Pairing Events.  Called by the stack when Simple Pairing related
+** events occur.
+*/
+typedef UINT8 (tBTM_SP_CALLBACK) (tBTM_SP_EVT event, tBTM_SP_EVT_DATA *p_data);
+
+
+typedef void (tBTM_MKEY_CALLBACK) (BD_ADDR bd_addr, UINT8 status, UINT8 key_flag) ;
+
+/* Encryption enabled/disabled complete: Optionally passed with BTM_SetEncryption.
+** Parameters are
+**              BD Address of remote
+**              optional data passed in by BTM_SetEncryption
+**              tBTM_STATUS - result of the operation
+*/
+typedef void (tBTM_SEC_CBACK) (BD_ADDR bd_addr, tBT_TRANSPORT trasnport,
+                                void *p_ref_data, tBTM_STATUS result);
+
+/* Bond Cancel complete. Parameters are
+**              Result of the cancel operation
+**
+*/
+typedef void (tBTM_BOND_CANCEL_CMPL_CALLBACK) (tBTM_STATUS result);
+
+/* LE related event and data structure
+*/
+#define BTM_LE_IO_REQ_EVT       SMP_IO_CAP_REQ_EVT     /* received IO_CAPABILITY_REQUEST event */
+#define BTM_LE_SEC_REQUEST_EVT  SMP_SEC_REQUEST_EVT    /* security request event */
+#define BTM_LE_KEY_NOTIF_EVT    SMP_PASSKEY_NOTIF_EVT  /* received USER_PASSKEY_NOTIFY event */
+#define BTM_LE_KEY_REQ_EVT      SMP_PASSKEY_REQ_EVT    /* received USER_PASSKEY_REQUEST event */
+#define BTM_LE_OOB_REQ_EVT      SMP_OOB_REQ_EVT        /* OOB data request event */
+#define BTM_LE_NC_REQ_EVT       SMP_NC_REQ_EVT          /* Numeric Comparison request event */
+#define BTM_LE_PR_KEYPR_NOT_EVT SMP_PEER_KEYPR_NOT_EVT /* Peer keypress notification recd event */
+/* SC OOB request event (both local and peer OOB data) can be expected in response */
+#define BTM_LE_SC_OOB_REQ_EVT   SMP_SC_OOB_REQ_EVT
+/* SC OOB local data set is created (as result of SMP_CrLocScOobData(...)) */
+#define BTM_LE_SC_LOC_OOB_EVT   SMP_SC_LOC_OOB_DATA_UP_EVT
+#define BTM_LE_BR_KEYS_REQ_EVT  SMP_BR_KEYS_REQ_EVT     /* SMP over BR keys request event */
+#define BTM_LE_COMPLT_EVT       SMP_COMPLT_EVT         /* SMP complete event */
+#define BTM_LE_LAST_FROM_SMP    BTM_LE_BR_KEYS_REQ_EVT
+#define BTM_LE_KEY_EVT          BTM_LE_LAST_FROM_SMP + 1 /* KEY update event */
+#define BTM_LE_CONSENT_REQ_EVT  SMP_CONSENT_REQ_EVT
+typedef UINT8 tBTM_LE_EVT;
+
+#define BTM_LE_KEY_NONE           0
+#define BTM_LE_KEY_PENC      SMP_SEC_KEY_TYPE_ENC        /* encryption information of peer device */
+#define BTM_LE_KEY_PID       SMP_SEC_KEY_TYPE_ID         /* identity key of the peer device */
+#define BTM_LE_KEY_PCSRK     SMP_SEC_KEY_TYPE_CSRK      /* peer SRK */
+#define BTM_LE_KEY_PLK       SMP_SEC_KEY_TYPE_LK
+#define BTM_LE_KEY_LLK       (SMP_SEC_KEY_TYPE_LK << 4)
+#define BTM_LE_KEY_LENC      (SMP_SEC_KEY_TYPE_ENC << 4)  /* master role security information:div */
+#define BTM_LE_KEY_LID       (SMP_SEC_KEY_TYPE_ID << 4)   /* master device ID key */
+#define BTM_LE_KEY_LCSRK     (SMP_SEC_KEY_TYPE_CSRK << 4) /* local CSRK has been deliver to peer */
+typedef UINT8 tBTM_LE_KEY_TYPE;
+
+#define BTM_LE_AUTH_REQ_NO_BOND SMP_AUTH_NO_BOND   /* 0 */
+#define BTM_LE_AUTH_REQ_BOND    SMP_AUTH_GEN_BOND  /* 1 << 0 */
+#define BTM_LE_AUTH_REQ_MITM    SMP_AUTH_YN_BIT    /* 1 << 2 */
+typedef UINT8 tBTM_LE_AUTH_REQ;
+#define BTM_LE_SC_SUPPORT_BIT           SMP_SC_SUPPORT_BIT     /* (1 << 3) */
+#define BTM_LE_KP_SUPPORT_BIT           SMP_KP_SUPPORT_BIT     /* (1 << 4) */
+
+#define BTM_LE_AUTH_REQ_SC_ONLY         SMP_AUTH_SC_ENC_ONLY    /* 1 << 3 */
+#define BTM_LE_AUTH_REQ_SC_BOND         SMP_AUTH_SC_GB          /* 1001 */
+#define BTM_LE_AUTH_REQ_SC_MITM         SMP_AUTH_SC_MITM_NB     /* 1100 */
+#define BTM_LE_AUTH_REQ_SC_MITM_BOND    SMP_AUTH_SC_MITM_GB     /* 1101 */
+#define BTM_LE_AUTH_REQ_MASK            SMP_AUTH_MASK           /* 0x1D */
+
+/* LE security level */
+#define BTM_LE_SEC_NONE             SMP_SEC_NONE
+#define BTM_LE_SEC_UNAUTHENTICATE   SMP_SEC_UNAUTHENTICATE      /* 1 */
+#define BTM_LE_SEC_AUTHENTICATED    SMP_SEC_AUTHENTICATED       /* 4 */
+typedef UINT8 tBTM_LE_SEC;
+
+
+typedef struct
+{
+    tBTM_IO_CAP         io_cap;         /* local IO capabilities */
+    UINT8               oob_data;       /* OOB data present (locally) for the peer device */
+    tBTM_LE_AUTH_REQ    auth_req;       /* Authentication request (for local device) contain bonding and MITM info */
+    UINT8               max_key_size;   /* max encryption key size */
+    tBTM_LE_KEY_TYPE    init_keys;      /* keys to be distributed, bit mask */
+    tBTM_LE_KEY_TYPE    resp_keys;      /* keys to be distributed, bit mask */
+} tBTM_LE_IO_REQ;
+
+#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
+/* data type for tBTM_LE_COMPLT */
+typedef struct
+{
+    UINT8 reason;
+    UINT8 sec_level;
+    BOOLEAN is_pair_cancel;
+    BOOLEAN smp_over_br;
+}tBTM_LE_COMPLT;
+#endif
+
+/* BLE encryption keys */
+typedef struct
+{
+    BT_OCTET16  ltk;
+    BT_OCTET8   rand;
+    UINT16      ediv;
+    UINT8       sec_level;
+    UINT8       key_size;
+}tBTM_LE_PENC_KEYS;
+
+/* BLE CSRK keys */
+typedef struct
+{
+    UINT32          counter;
+    BT_OCTET16      csrk;
+    UINT8           sec_level;
+}tBTM_LE_PCSRK_KEYS;
+
+/* BLE Encryption reproduction keys */
+typedef struct
+{
+    BT_OCTET16  ltk;
+    UINT16      div;
+    UINT8       key_size;
+    UINT8       sec_level;
+}tBTM_LE_LENC_KEYS;
+
+/* BLE SRK keys */
+typedef struct
+{
+    UINT32          counter;
+    UINT16          div;
+    UINT8           sec_level;
+    BT_OCTET16      csrk;
+}tBTM_LE_LCSRK_KEYS;
+
+typedef struct
+{
+    BT_OCTET16          irk;
+    tBLE_ADDR_TYPE      addr_type;
+    BD_ADDR             static_addr;
+}tBTM_LE_PID_KEYS;
+
+typedef union
+{
+    tBTM_LE_PENC_KEYS   penc_key;       /* received peer encryption key */
+    tBTM_LE_PCSRK_KEYS  pcsrk_key;      /* received peer device SRK */
+    tBTM_LE_PID_KEYS    pid_key;        /* peer device ID key */
+    tBTM_LE_LENC_KEYS   lenc_key;       /* local encryption reproduction keys LTK = = d1(ER,DIV,0)*/
+    tBTM_LE_LCSRK_KEYS   lcsrk_key;     /* local device CSRK = d1(ER,DIV,1)*/
+}tBTM_LE_KEY_VALUE;
+
+typedef struct
+{
+    tBTM_LE_KEY_TYPE        key_type;
+    tBTM_LE_KEY_VALUE       *p_key_value;
+}tBTM_LE_KEY;
+
+typedef union
+{
+    tBTM_LE_IO_REQ      io_req;     /* BTM_LE_IO_REQ_EVT      */
+    UINT32              key_notif;  /* BTM_LE_KEY_NOTIF_EVT   */
+                                    /* BTM_LE_NC_REQ_EVT */
+                                    /* no callback data for BTM_LE_KEY_REQ_EVT */
+                                    /* and BTM_LE_OOB_REQ_EVT  */
+#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
+    tBTM_LE_COMPLT      complt;     /* BTM_LE_COMPLT_EVT      */
+    tSMP_OOB_DATA_TYPE  req_oob_type;
+#endif
+    tBTM_LE_KEY         key;
+} tBTM_LE_EVT_DATA;
+
+/* Simple Pairing Events.  Called by the stack when Simple Pairing related
+** events occur.
+*/
+typedef UINT8 (tBTM_LE_CALLBACK) (tBTM_LE_EVT event, BD_ADDR bda, tBTM_LE_EVT_DATA *p_data);
+
+#define BTM_BLE_KEY_TYPE_ID         1
+#define BTM_BLE_KEY_TYPE_ER         2
+#define BTM_BLE_KEY_TYPE_COUNTER    3  //tobe obsolete
+
+typedef struct
+{
+    BT_OCTET16       ir;
+    BT_OCTET16       irk;
+    BT_OCTET16       dhk;
+
+}tBTM_BLE_LOCAL_ID_KEYS;
+
+typedef union
+{
+    tBTM_BLE_LOCAL_ID_KEYS  id_keys;
+    BT_OCTET16              er;
+}tBTM_BLE_LOCAL_KEYS;
+
+
+/* New LE identity key for local device.
+*/
+typedef void (tBTM_LE_KEY_CALLBACK) (UINT8 key_type, tBTM_BLE_LOCAL_KEYS *p_key);
+
+
+/***************************
+**  Security Manager Types
+****************************/
+/* Structure that applications use to register with BTM_SecRegister */
+typedef struct
+{
+    tBTM_AUTHORIZE_CALLBACK     *p_authorize_callback;
+    tBTM_PIN_CALLBACK           *p_pin_callback;
+    tBTM_LINK_KEY_CALLBACK      *p_link_key_callback;
+    tBTM_AUTH_COMPLETE_CALLBACK *p_auth_complete_callback;
+    tBTM_BOND_CANCEL_CMPL_CALLBACK *p_bond_cancel_cmpl_callback;
+    tBTM_SP_CALLBACK            *p_sp_callback;
+#if BLE_INCLUDED == TRUE
+#if SMP_INCLUDED == TRUE
+    tBTM_LE_CALLBACK            *p_le_callback;
+#endif
+    tBTM_LE_KEY_CALLBACK        *p_le_key_callback;
+#endif
+} tBTM_APPL_INFO;
+
+/* Callback function for when a link supervision timeout event occurs.
+** This asynchronous event is enabled/disabled by calling BTM_RegForLstoEvt().
+*/
+typedef void (tBTM_LSTO_CBACK) (BD_ADDR remote_bda, UINT16 timeout);
+
+/*****************************************************************************
+**  POWER MANAGEMENT
+*****************************************************************************/
+/****************************
+**  Power Manager Constants
+*****************************/
+/* BTM Power manager status codes */
+enum
+{
+    BTM_PM_STS_ACTIVE = HCI_MODE_ACTIVE,
+    BTM_PM_STS_HOLD   = HCI_MODE_HOLD,
+    BTM_PM_STS_SNIFF  = HCI_MODE_SNIFF,
+    BTM_PM_STS_PARK   = HCI_MODE_PARK,
+    BTM_PM_STS_SSR,     /* report the SSR parameters in HCI_SNIFF_SUB_RATE_EVT */
+    BTM_PM_STS_PENDING,   /* when waiting for status from controller */
+    BTM_PM_STS_ERROR   /* when HCI command status returns error */
+};
+typedef UINT8 tBTM_PM_STATUS;
+
+/* BTM Power manager modes */
+enum
+{
+    BTM_PM_MD_ACTIVE = BTM_PM_STS_ACTIVE,
+    BTM_PM_MD_HOLD   = BTM_PM_STS_HOLD,
+    BTM_PM_MD_SNIFF  = BTM_PM_STS_SNIFF,
+    BTM_PM_MD_PARK   = BTM_PM_STS_PARK,
+    BTM_PM_MD_FORCE  = 0x10 /* OR this to force ACL link to a certain mode */
+};
+typedef UINT8 tBTM_PM_MODE;
+
+#define BTM_PM_SET_ONLY_ID  0x80
+
+/* Operation codes */
+#define BTM_PM_REG_SET      1 /* The module wants to set the desired power mode */
+#define BTM_PM_REG_NOTIF    2 /* The module wants to receive mode change event */
+#define BTM_PM_DEREG        4 /* The module does not want to involve with PM anymore */
+
+/************************
+**  Power Manager Types
+*************************/
+typedef struct
+{
+    UINT16          max;
+    UINT16          min;
+    UINT16          attempt;
+    UINT16          timeout;
+    tBTM_PM_MODE    mode;
+} tBTM_PM_PWR_MD;
+
+/*************************************
+**  Power Manager Callback Functions
+**************************************/
+typedef void (tBTM_PM_STATUS_CBACK) (BD_ADDR p_bda, tBTM_PM_STATUS status,
+                                     UINT16 value, UINT8 hci_status);
+
+
+/************************
+**  Stored Linkkey Types
+*************************/
+#define BTM_CB_EVT_DELETE_STORED_LINK_KEYS  4
+
+typedef struct
+{
+    UINT8          event;
+    UINT8          status;
+    UINT16         num_keys;
+
+} tBTM_DELETE_STORED_LINK_KEY_COMPLETE;
+
+/* MIP evnets, callbacks    */
+enum
+{
+    BTM_MIP_MODE_CHG_EVT,
+    BTM_MIP_DISCONNECT_EVT,
+    BTM_MIP_PKTS_COMPL_EVT,
+    BTM_MIP_RXDATA_EVT
+};
+typedef UINT8 tBTM_MIP_EVT;
+
+typedef struct
+{
+    tBTM_MIP_EVT    event;
+    BD_ADDR         bd_addr;
+    UINT16          mip_id;
+} tBTM_MIP_MODE_CHANGE;
+
+typedef struct
+{
+    tBTM_MIP_EVT    event;
+    UINT16          mip_id;
+    UINT8           disc_reason;
+} tBTM_MIP_CONN_TIMEOUT;
+
+#define BTM_MIP_MAX_RX_LEN  17
+
+typedef struct
+{
+    tBTM_MIP_EVT    event;
+    UINT16          mip_id;
+    UINT8           rx_len;
+    UINT8           rx_data[BTM_MIP_MAX_RX_LEN];
+} tBTM_MIP_RXDATA;
+
+typedef struct
+{
+    tBTM_MIP_EVT    event;
+    BD_ADDR         bd_addr;
+    UINT8           data[11];       /* data[0] shows Vender-specific device type */
+} tBTM_MIP_EIR_HANDSHAKE;
+
+typedef struct
+{
+    tBTM_MIP_EVT    event;
+    UINT16          num_sent;       /* Number of packets completed at the controller */
+} tBTM_MIP_PKTS_COMPL;
+
+typedef union
+{
+    tBTM_MIP_EVT            event;
+    tBTM_MIP_MODE_CHANGE    mod_chg;
+    tBTM_MIP_CONN_TIMEOUT   conn_tmo;
+    tBTM_MIP_EIR_HANDSHAKE  eir;
+    tBTM_MIP_PKTS_COMPL     completed;
+    tBTM_MIP_RXDATA         rxdata;
+} tBTM_MIP_EVENT_DATA;
+
+/* MIP event callback function  */
+typedef void (tBTM_MIP_EVENTS_CB) (tBTM_MIP_EVT event, tBTM_MIP_EVENT_DATA data);
+
+/* MIP Device query callback function  */
+typedef BOOLEAN (tBTM_MIP_QUERY_CB) (BD_ADDR dev_addr, UINT8 *p_mode, LINK_KEY link_key);
+
+#define BTM_CONTRL_ACTIVE  1       /* ACL link on, SCO link ongoing, sniff mode */
+#define BTM_CONTRL_SCAN    2       /* Scan state - paging/inquiry/trying to connect*/
+#define BTM_CONTRL_IDLE    3       /* Idle state - page scan, LE advt, inquiry scan */
+
+typedef UINT8 tBTM_CONTRL_STATE;
+
+#endif // BTM_API_TYPES_H
diff --git a/stack/include/btm_ble_api.h b/stack/include/btm_ble_api.h
index 0cc2e18a2..556470431 100644
--- a/stack/include/btm_ble_api.h
+++ b/stack/include/btm_ble_api.h
@@ -29,864 +29,7 @@
 #include "bt_common.h"
 #include "osi/include/alarm.h"
 #include <hardware/bt_common_types.h>
-
-#define CHNL_MAP_LEN    5
-typedef UINT8 tBTM_BLE_CHNL_MAP[CHNL_MAP_LEN];
-
-/* 0x00-0x04 only used for set advertising parameter command */
-#define BTM_BLE_CONNECT_EVT     0x00   /* 0x00-0x04 only used for set advertising
-                                            parameter command */
-#define BTM_BLE_CONNECT_DIR_EVT 0x01   /* Connectable directed advertising */
-#define BTM_BLE_DISCOVER_EVT    0x02  /* Scannable undirected advertising */
-#define BTM_BLE_NON_CONNECT_EVT 0x03  /* Non connectable undirected advertising */
-#define BTM_BLE_CONNECT_LO_DUTY_DIR_EVT 0x04        /* Connectable low duty
-                                                       cycle directed advertising  */
-    /* 0x00 - 0x05 can be received on adv event type */
-#define BTM_BLE_SCAN_RSP_EVT    0x04
-#define BTM_BLE_SCAN_REQ_EVT    0x05
-#define BTM_BLE_UNKNOWN_EVT     0xff
-
-#define BTM_BLE_UNKNOWN_EVT     0xff
-
-typedef UINT8 tBTM_BLE_EVT;
-typedef UINT8 tBTM_BLE_CONN_MODE;
-
-typedef UINT32 tBTM_BLE_REF_VALUE;
-
-#define BTM_BLE_SCAN_MODE_PASS      0
-#define BTM_BLE_SCAN_MODE_ACTI      1
-#define BTM_BLE_SCAN_MODE_NONE      0xff
-typedef UINT8 tBLE_SCAN_MODE;
-
-#define BTM_BLE_BATCH_SCAN_MODE_DISABLE 0
-#define BTM_BLE_BATCH_SCAN_MODE_PASS  1
-#define BTM_BLE_BATCH_SCAN_MODE_ACTI  2
-#define BTM_BLE_BATCH_SCAN_MODE_PASS_ACTI 3
-
-typedef UINT8 tBTM_BLE_BATCH_SCAN_MODE;
-
-/* advertising channel map */
-#define BTM_BLE_ADV_CHNL_37    (0x01 << 0)
-#define BTM_BLE_ADV_CHNL_38    (0x01 << 1)
-#define BTM_BLE_ADV_CHNL_39    (0x01 << 2)
-typedef UINT8 tBTM_BLE_ADV_CHNL_MAP;
-
-/*d efault advertising channel map */
-#ifndef BTM_BLE_DEFAULT_ADV_CHNL_MAP
-#define BTM_BLE_DEFAULT_ADV_CHNL_MAP   (BTM_BLE_ADV_CHNL_37| BTM_BLE_ADV_CHNL_38| BTM_BLE_ADV_CHNL_39)
-#endif
-
-/* advertising filter policy */
-#define AP_SCAN_CONN_ALL           0x00        /* default */
-#define AP_SCAN_WL_CONN_ALL        0x01
-#define AP_SCAN_ALL_CONN_WL        0x02
-#define AP_SCAN_CONN_WL            0x03
-#define AP_SCAN_CONN_POLICY_MAX    0x04
-typedef UINT8   tBTM_BLE_AFP;
-
-/* default advertising filter policy */
-#ifndef BTM_BLE_DEFAULT_AFP
-#define BTM_BLE_DEFAULT_AFP   AP_SCAN_CONN_ALL
-#endif
-
-/* scanning filter policy */
-#define SP_ADV_ALL     0x00     /* 0: accept adv packet from all, directed adv pkt not directed */
-                                /* to local device is ignored */
-#define SP_ADV_WL      0x01     /* 1: accept adv packet from device in white list, directed adv */
-                                /* packet not directed to local device is ignored */
-#define SP_ADV_ALL_RPA_DIR_ADV 0x02  /* 2: accept adv packet from all, directed adv pkt */
-                                     /* not directed to me is ignored except direct adv with RPA */
-#define SP_ADV_WL_RPA_DIR_ADV  0x03  /* 3: accept adv packet from device in white list, directed */
-                                     /* adv pkt not directed to me is ignored except direct adv */
-                                     /* with RPA */
-typedef UINT8   tBTM_BLE_SFP;
-
-#ifndef BTM_BLE_DEFAULT_SFP
-#define BTM_BLE_DEFAULT_SFP   SP_ADV_ALL
-#endif
-
-/* adv parameter boundary values */
-#define BTM_BLE_ADV_INT_MIN            0x0020
-#define BTM_BLE_ADV_INT_MAX            0x4000
-
-/* Full scan boundary values */
-#define BTM_BLE_ADV_SCAN_FULL_MIN      0x00
-#define BTM_BLE_ADV_SCAN_FULL_MAX      0x64
-
-/* Partial scan boundary values */
-#define BTM_BLE_ADV_SCAN_TRUNC_MIN      BTM_BLE_ADV_SCAN_FULL_MIN
-#define BTM_BLE_ADV_SCAN_TRUNC_MAX      BTM_BLE_ADV_SCAN_FULL_MAX
-
-/* Threshold values */
-#define BTM_BLE_ADV_SCAN_THR_MIN        BTM_BLE_ADV_SCAN_FULL_MIN
-#define BTM_BLE_ADV_SCAN_THR_MAX        BTM_BLE_ADV_SCAN_FULL_MAX
-
-/* connection parameter boundary values */
-#define BTM_BLE_SCAN_INT_MIN            0x0004
-#define BTM_BLE_SCAN_INT_MAX            0x4000
-#define BTM_BLE_SCAN_WIN_MIN            0x0004
-#define BTM_BLE_SCAN_WIN_MAX            0x4000
-#define BTM_BLE_EXT_SCAN_INT_MAX        0x00FFFFFF
-#define BTM_BLE_EXT_SCAN_WIN_MAX        0xFFFF
-#define BTM_BLE_CONN_INT_MIN            0x0006
-#define BTM_BLE_CONN_INT_MAX            0x0C80
-#define BTM_BLE_CONN_LATENCY_MAX        500
-#define BTM_BLE_CONN_SUP_TOUT_MIN       0x000A
-#define BTM_BLE_CONN_SUP_TOUT_MAX       0x0C80
-#define BTM_BLE_CONN_PARAM_UNDEF        0xffff      /* use this value when a specific value not to be overwritten */
-#define BTM_BLE_SCAN_PARAM_UNDEF        0xffffffff
-
-/* default connection parameters if not configured, use GAP recommend value for auto/selective connection */
-/* default scan interval */
-#ifndef BTM_BLE_SCAN_FAST_INT
-#define BTM_BLE_SCAN_FAST_INT    96    /* 30 ~ 60 ms (use 60)  = 96 *0.625 */
-#endif
-/* default scan window for background connection, applicable for auto connection or selective conenction */
-#ifndef BTM_BLE_SCAN_FAST_WIN
-#define BTM_BLE_SCAN_FAST_WIN   48      /* 30 ms = 48 *0.625 */
-#endif
-
-/* default scan paramter used in reduced power cycle (background scanning) */
-#ifndef BTM_BLE_SCAN_SLOW_INT_1
-#define BTM_BLE_SCAN_SLOW_INT_1    2048    /* 1.28 s   = 2048 *0.625 */
-#endif
-#ifndef BTM_BLE_SCAN_SLOW_WIN_1
-#define BTM_BLE_SCAN_SLOW_WIN_1   48      /* 30 ms = 48 *0.625 */
-#endif
-
-/* default scan paramter used in reduced power cycle (background scanning) */
-#ifndef BTM_BLE_SCAN_SLOW_INT_2
-#define BTM_BLE_SCAN_SLOW_INT_2    4096    /* 2.56 s   = 4096 *0.625 */
-#endif
-#ifndef BTM_BLE_SCAN_SLOW_WIN_2
-#define BTM_BLE_SCAN_SLOW_WIN_2   36      /* 22.5 ms = 36 *0.625 */
-#endif
-
-/* default connection interval min */
-#ifndef BTM_BLE_CONN_INT_MIN_DEF
-#define BTM_BLE_CONN_INT_MIN_DEF     24      /* recommended min: 30ms  = 24 * 1.25 */
-#endif
-
-/* default connectino interval max */
-#ifndef BTM_BLE_CONN_INT_MAX_DEF
-#define BTM_BLE_CONN_INT_MAX_DEF     40      /* recommended max: 50 ms = 56 * 1.25 */
-#endif
-
-/* default slave latency */
-#ifndef BTM_BLE_CONN_SLAVE_LATENCY_DEF
-#define BTM_BLE_CONN_SLAVE_LATENCY_DEF  0      /* 0 */
-#endif
-
-/* default supervision timeout */
-#ifndef BTM_BLE_CONN_TIMEOUT_DEF
-#define BTM_BLE_CONN_TIMEOUT_DEF    2000
-#endif
-
-/* minimum supervision timeout */
-#ifndef BTM_BLE_CONN_TIMEOUT_MIN_DEF
-#define BTM_BLE_CONN_TIMEOUT_MIN_DEF    100
-#endif
-
-/* minimum acceptable connection interval */
-#ifndef BTM_BLE_CONN_INT_MIN_LIMIT
-#define BTM_BLE_CONN_INT_MIN_LIMIT     0x0009
-#endif
-
-#define BTM_BLE_DIR_CONN_FALLBACK_UNDIR         1
-#define BTM_BLE_DIR_CONN_FALLBACK_NO_ADV        2
-
-#ifndef BTM_BLE_DIR_CONN_FALLBACK
-#define BTM_BLE_DIR_CONN_FALLBACK   BTM_BLE_DIR_CONN_FALLBACK_UNDIR
-#endif
-
-#define BTM_CMAC_TLEN_SIZE          8                   /* 64 bits */
-#define BTM_BLE_AUTH_SIGN_LEN       12                   /* BLE data signature length 8 Bytes + 4 bytes counter*/
-typedef UINT8 BLE_SIGNATURE[BTM_BLE_AUTH_SIGN_LEN];         /* Device address */
-
-#ifndef BTM_BLE_HOST_SUPPORT
-#define BTM_BLE_HOST_SUPPORT        0x01
-#endif
-
-#ifndef BTM_BLE_SIMULTANEOUS_HOST
-#define BTM_BLE_SIMULTANEOUS_HOST   0x01
-#endif
-
-/* Appearance Values Reported with BTM_BLE_AD_TYPE_APPEARANCE */
-#define BTM_BLE_APPEARANCE_UKNOWN                  0x0000
-#define BTM_BLE_APPEARANCE_GENERIC_PHONE           0x0040
-#define BTM_BLE_APPEARANCE_GENERIC_COMPUTER        0x0080
-#define BTM_BLE_APPEARANCE_GENERIC_WATCH           0x00C0
-#define BTM_BLE_APPEARANCE_SPORTS_WATCH            0x00C1
-#define BTM_BLE_APPEARANCE_GENERIC_CLOCK           0x0100
-#define BTM_BLE_APPEARANCE_GENERIC_DISPLAY         0x0140
-#define BTM_BLE_APPEARANCE_GENERIC_REMOTE          0x0180
-#define BTM_BLE_APPEARANCE_GENERIC_EYEGLASSES      0x01C0
-#define BTM_BLE_APPEARANCE_GENERIC_TAG             0x0200
-#define BTM_BLE_APPEARANCE_GENERIC_KEYRING         0x0240
-#define BTM_BLE_APPEARANCE_GENERIC_MEDIA_PLAYER    0x0280
-#define BTM_BLE_APPEARANCE_GENERIC_BARCODE_SCANNER 0x02C0
-#define BTM_BLE_APPEARANCE_GENERIC_THERMOMETER     0x0300
-#define BTM_BLE_APPEARANCE_THERMOMETER_EAR         0x0301
-#define BTM_BLE_APPEARANCE_GENERIC_HEART_RATE      0x0340
-#define BTM_BLE_APPEARANCE_HEART_RATE_BELT         0x0341
-#define BTM_BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE  0x0380
-#define BTM_BLE_APPEARANCE_BLOOD_PRESSURE_ARM      0x0381
-#define BTM_BLE_APPEARANCE_BLOOD_PRESSURE_WRIST    0x0382
-#define BTM_BLE_APPEARANCE_GENERIC_HID             0x03C0
-#define BTM_BLE_APPEARANCE_HID_KEYBOARD            0x03C1
-#define BTM_BLE_APPEARANCE_HID_MOUSE               0x03C2
-#define BTM_BLE_APPEARANCE_HID_JOYSTICK            0x03C3
-#define BTM_BLE_APPEARANCE_HID_GAMEPAD             0x03C4
-#define BTM_BLE_APPEARANCE_HID_DIGITIZER_TABLET    0x03C5
-#define BTM_BLE_APPEARANCE_HID_CARD_READER         0x03C6
-#define BTM_BLE_APPEARANCE_HID_DIGITAL_PEN         0x03C7
-#define BTM_BLE_APPEARANCE_HID_BARCODE_SCANNER     0x03C8
-#define BTM_BLE_APPEARANCE_GENERIC_GLUCOSE         0x0400
-#define BTM_BLE_APPEARANCE_GENERIC_WALKING         0x0440
-#define BTM_BLE_APPEARANCE_WALKING_IN_SHOE         0x0441
-#define BTM_BLE_APPEARANCE_WALKING_ON_SHOE         0x0442
-#define BTM_BLE_APPEARANCE_WALKING_ON_HIP          0x0443
-#define BTM_BLE_APPEARANCE_GENERIC_CYCLING         0x0480
-#define BTM_BLE_APPEARANCE_CYCLING_COMPUTER        0x0481
-#define BTM_BLE_APPEARANCE_CYCLING_SPEED           0x0482
-#define BTM_BLE_APPEARANCE_CYCLING_CADENCE         0x0483
-#define BTM_BLE_APPEARANCE_CYCLING_POWER           0x0484
-#define BTM_BLE_APPEARANCE_CYCLING_SPEED_CADENCE   0x0485
-#define BTM_BLE_APPEARANCE_GENERIC_PULSE_OXIMETER  0x0C40
-#define BTM_BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP 0x0C41
-#define BTM_BLE_APPEARANCE_PULSE_OXIMETER_WRIST    0x0C42
-#define BTM_BLE_APPEARANCE_GENERIC_WEIGHT          0x0C80
-#define BTM_BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS  0x1440
-#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION 0x1441
-#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_AND_NAV     0x1442
-#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_POD         0x1443
-#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_POD_AND_NAV 0x1444
-
-
-/* Structure returned with Rand/Encrypt complete callback */
-typedef struct
-{
-    UINT8   status;
-    UINT8   param_len;
-    UINT16  opcode;
-    UINT8   param_buf[BT_OCTET16_LEN];
-} tBTM_RAND_ENC;
-
-/* General callback function for notifying an application that a synchronous
-** BTM function is complete. The pointer contains the address of any returned data.
-*/
-typedef void (tBTM_RAND_ENC_CB) (tBTM_RAND_ENC *p1);
-
-#define BTM_BLE_FILTER_TARGET_SCANNER       0x01
-#define BTM_BLE_FILTER_TARGET_ADVR          0x00
-
-#define BTM_BLE_POLICY_BLACK_ALL            0x00    /* relevant to both */
-#define BTM_BLE_POLICY_ALLOW_SCAN           0x01    /* relevant to advertiser */
-#define BTM_BLE_POLICY_ALLOW_CONN           0x02    /* relevant to advertiser */
-#define BTM_BLE_POLICY_WHITE_ALL            0x03    /* relevant to both */
-
-/* ADV data flag bit definition used for BTM_BLE_AD_TYPE_FLAG */
-#define BTM_BLE_LIMIT_DISC_FLAG         (0x01 << 0)
-#define BTM_BLE_GEN_DISC_FLAG           (0x01 << 1)
-#define BTM_BLE_BREDR_NOT_SPT           (0x01 << 2)
-/* 4.1 spec adv flag for simultaneous BR/EDR+LE connection support */
-#define BTM_BLE_DMT_CONTROLLER_SPT      (0x01 << 3)
-#define BTM_BLE_DMT_HOST_SPT            (0x01 << 4)
-#define BTM_BLE_NON_LIMIT_DISC_FLAG     (0x00 )         /* lowest bit unset */
-#define BTM_BLE_ADV_FLAG_MASK           (BTM_BLE_LIMIT_DISC_FLAG | BTM_BLE_BREDR_NOT_SPT | BTM_BLE_GEN_DISC_FLAG)
-#define BTM_BLE_LIMIT_DISC_MASK         (BTM_BLE_LIMIT_DISC_FLAG )
-
-#define BTM_BLE_AD_BIT_DEV_NAME        (0x00000001 << 0)
-#define BTM_BLE_AD_BIT_FLAGS           (0x00000001 << 1)
-#define BTM_BLE_AD_BIT_MANU            (0x00000001 << 2)
-#define BTM_BLE_AD_BIT_TX_PWR          (0x00000001 << 3)
-#define BTM_BLE_AD_BIT_INT_RANGE       (0x00000001 << 5)
-#define BTM_BLE_AD_BIT_SERVICE         (0x00000001 << 6)
-#define BTM_BLE_AD_BIT_SERVICE_SOL     (0x00000001 << 7)
-#define BTM_BLE_AD_BIT_SERVICE_DATA    (0x00000001 << 8)
-#define BTM_BLE_AD_BIT_SIGN_DATA       (0x00000001 << 9)
-#define BTM_BLE_AD_BIT_SERVICE_128SOL  (0x00000001 << 10)
-#define BTM_BLE_AD_BIT_APPEARANCE      (0x00000001 << 11)
-#define BTM_BLE_AD_BIT_PUBLIC_ADDR      (0x00000001 << 12)
-#define BTM_BLE_AD_BIT_RANDOM_ADDR       (0x00000001 << 13)
-#define BTM_BLE_AD_BIT_SERVICE_32        (0x00000001 << 4)
-#define BTM_BLE_AD_BIT_SERVICE_32SOL     (0x00000001 << 14)
-#define BTM_BLE_AD_BIT_PROPRIETARY     (0x00000001 << 15)
-#define BTM_BLE_AD_BIT_SERVICE_128      (0x00000001 << 16)      /*128-bit Service UUIDs*/
-
-typedef  UINT32  tBTM_BLE_AD_MASK;
-
-#define BTM_BLE_AD_TYPE_FLAG            HCI_EIR_FLAGS_TYPE                  /* 0x01 */
-#define BTM_BLE_AD_TYPE_16SRV_PART      HCI_EIR_MORE_16BITS_UUID_TYPE       /* 0x02 */
-#define BTM_BLE_AD_TYPE_16SRV_CMPL      HCI_EIR_COMPLETE_16BITS_UUID_TYPE   /* 0x03 */
-#define BTM_BLE_AD_TYPE_32SRV_PART      HCI_EIR_MORE_32BITS_UUID_TYPE       /* 0x04 */
-#define BTM_BLE_AD_TYPE_32SRV_CMPL      HCI_EIR_COMPLETE_32BITS_UUID_TYPE   /* 0x05 */
-#define BTM_BLE_AD_TYPE_128SRV_PART     HCI_EIR_MORE_128BITS_UUID_TYPE       /* 0x06 */
-#define BTM_BLE_AD_TYPE_128SRV_CMPL     HCI_EIR_COMPLETE_128BITS_UUID_TYPE   /* 0x07 */
-#define BTM_BLE_AD_TYPE_NAME_SHORT      HCI_EIR_SHORTENED_LOCAL_NAME_TYPE       /* 0x08 */
-#define BTM_BLE_AD_TYPE_NAME_CMPL       HCI_EIR_COMPLETE_LOCAL_NAME_TYPE        /* 0x09 */
-#define BTM_BLE_AD_TYPE_TX_PWR          HCI_EIR_TX_POWER_LEVEL_TYPE             /* 0x0A */
-#define BTM_BLE_AD_TYPE_DEV_CLASS       0x0D
-#define BTM_BLE_AD_TYPE_SM_TK           0x10
-#define BTM_BLE_AD_TYPE_SM_OOB_FLAG     0x11
-#define BTM_BLE_AD_TYPE_INT_RANGE       0x12
-#define BTM_BLE_AD_TYPE_SOL_SRV_UUID    0x14
-#define BTM_BLE_AD_TYPE_128SOL_SRV_UUID 0x15
-#define BTM_BLE_AD_TYPE_SERVICE_DATA    0x16
-#define BTM_BLE_AD_TYPE_PUBLIC_TARGET   0x17
-#define BTM_BLE_AD_TYPE_RANDOM_TARGET   0x18
-#define BTM_BLE_AD_TYPE_APPEARANCE      0x19
-#define BTM_BLE_AD_TYPE_ADV_INT         0x1a
-#define BTM_BLE_AD_TYPE_32SOL_SRV_UUID  0x1b
-#define BTM_BLE_AD_TYPE_32SERVICE_DATA  0x1c
-#define BTM_BLE_AD_TYPE_128SERVICE_DATA 0x1d
-
-#define BTM_BLE_AD_TYPE_MANU            HCI_EIR_MANUFACTURER_SPECIFIC_TYPE      /* 0xff */
-typedef UINT8   tBTM_BLE_AD_TYPE;
-
-/*  Security settings used with L2CAP LE COC */
-#define BTM_SEC_LE_LINK_ENCRYPTED           0x01
-#define BTM_SEC_LE_LINK_PAIRED_WITHOUT_MITM 0x02
-#define BTM_SEC_LE_LINK_PAIRED_WITH_MITM    0x04
-
-/*  Min/max Preferred  number of payload octets that the local Controller
-    should include in a single Link Layer Data Channel PDU. */
-#define BTM_BLE_DATA_SIZE_MAX     0x00fb
-#define BTM_BLE_DATA_SIZE_MIN     0x001b
-
-/*  Preferred maximum number of microseconds that the local Controller
-    should use to transmit a single Link Layer Data Channel PDU. */
-#define BTM_BLE_DATA_TX_TIME_MIN     0x0148
-#define BTM_BLE_DATA_TX_TIME_MAX     0x0848
-
-/* adv tx power level */
-#define BTM_BLE_ADV_TX_POWER_MIN        0           /* minimum tx power */
-#define BTM_BLE_ADV_TX_POWER_LOW        1           /* low tx power     */
-#define BTM_BLE_ADV_TX_POWER_MID        2           /* middle tx power  */
-#define BTM_BLE_ADV_TX_POWER_UPPER      3           /* upper tx power   */
-#define BTM_BLE_ADV_TX_POWER_MAX        4           /* maximum tx power */
-typedef UINT8 tBTM_BLE_ADV_TX_POWER;
-
-/* adv tx power in dBm */
-typedef struct
-{
-    UINT8 adv_inst_max;         /* max adv instance supported in controller */
-    UINT8 rpa_offloading;
-    UINT16 tot_scan_results_strg;
-    UINT8 max_irk_list_sz;
-    UINT8 filter_support;
-    UINT8 max_filter;
-    UINT8 energy_support;
-    BOOLEAN values_read;
-    UINT16 version_supported;
-    UINT16 total_trackable_advertisers;
-    UINT8 extended_scan_support;
-    UINT8 debug_logging_supported;
-}tBTM_BLE_VSC_CB;
-
-/* slave preferred connection interval range */
-typedef struct
-{
-    UINT16  low;
-    UINT16  hi;
-
-}tBTM_BLE_INT_RANGE;
-
-/* Service tag supported in the device */
-#define MAX_16BIT_SERVICES 16
-typedef struct
-{
-    UINT8       num_service;
-    BOOLEAN     list_cmpl;
-    UINT16      uuid[MAX_16BIT_SERVICES];
-}tBTM_BLE_SERVICE;
-
-/* 32 bits Service supported in the device */
-#define MAX_32BIT_SERVICES 4
-typedef struct
-{
-    UINT8       num_service;
-    BOOLEAN     list_cmpl;
-    UINT32      uuid[MAX_32BIT_SERVICES];
-}tBTM_BLE_32SERVICE;
-
-/* 128 bits Service supported in the device */
-typedef struct
-{
-    UINT8       num_service;
-    BOOLEAN     list_cmpl;
-    UINT8       uuid128[MAX_UUID_SIZE];
-}tBTM_BLE_128SERVICE;
-
-#define MAX_SIZE_MANUFACTURER_DATA 32
-typedef struct
-{
-    UINT8 len;
-    UINT8 val[MAX_SIZE_MANUFACTURER_DATA];
-}tBTM_BLE_MANU;
-
-#define MAX_SIZE_SERVICE_DATA 32
-typedef struct
-{
-    tBT_UUID    service_uuid;
-    UINT8       len;
-    UINT8       val[MAX_SIZE_SERVICE_DATA];
-}tBTM_BLE_SERVICE_DATA;
-
-#define MAX_SIZE_PROPRIETARY_ELEMENT 32
-typedef struct
-{
-    UINT8       adv_type;
-    UINT8       len;
-    UINT8       val[MAX_SIZE_PROPRIETARY_ELEMENT];     /* number of len byte */
-}tBTM_BLE_PROP_ELEM;
-
-#define MAX_PROPRIETARY_ELEMENTS 4
-typedef struct
-{
-    UINT8                   num_elem;
-    tBTM_BLE_PROP_ELEM      elem[MAX_PROPRIETARY_ELEMENTS];
-}tBTM_BLE_PROPRIETARY;
-
-typedef struct
-{
-    tBTM_BLE_INT_RANGE      int_range;      /* slave prefered conn interval range */
-    tBTM_BLE_MANU           manu;           /* manufactuer data */
-    tBTM_BLE_SERVICE        services;       /* services */
-    tBTM_BLE_128SERVICE     services_128b;  /* 128 bits service */
-    tBTM_BLE_32SERVICE      service_32b;     /* 32 bits Service UUID */
-    tBTM_BLE_SERVICE        sol_services;    /* 16 bits services Solicitation UUIDs */
-    tBTM_BLE_32SERVICE      sol_service_32b;    /* List of 32 bit Service Solicitation UUIDs */
-    tBTM_BLE_128SERVICE     sol_service_128b;    /* List of 128 bit Service Solicitation UUIDs */
-    tBTM_BLE_PROPRIETARY    proprietary;
-    tBTM_BLE_SERVICE_DATA   service_data;    /* service data */
-    UINT16                  appearance;
-    UINT8                   flag;
-    UINT8                   tx_power;
-}tBTM_BLE_ADV_DATA;
-
-#ifndef BTM_BLE_MULTI_ADV_MAX
-#define BTM_BLE_MULTI_ADV_MAX   16 /* controller returned adv_inst_max should be less
-                                      than this number */
-#endif
-
-#define BTM_BLE_MULTI_ADV_INVALID   0
-
-#define BTM_BLE_MULTI_ADV_ENB_EVT           1
-#define BTM_BLE_MULTI_ADV_DISABLE_EVT       2
-#define BTM_BLE_MULTI_ADV_PARAM_EVT         3
-#define BTM_BLE_MULTI_ADV_DATA_EVT          4
-typedef UINT8 tBTM_BLE_MULTI_ADV_EVT;
-
-#define BTM_BLE_MULTI_ADV_DEFAULT_STD 0
-
-typedef struct
-{
-    UINT16          adv_int_min;
-    UINT16          adv_int_max;
-    UINT8           adv_type;
-    tBTM_BLE_ADV_CHNL_MAP channel_map;
-    tBTM_BLE_AFP    adv_filter_policy;
-    tBTM_BLE_ADV_TX_POWER tx_power;
-}tBTM_BLE_ADV_PARAMS;
-
-typedef struct
-{
-    UINT8   *p_sub_code; /* dynamic array to store sub code */
-    UINT8   *p_inst_id;  /* dynamic array to store instance id */
-    UINT8   pending_idx;
-    UINT8   next_idx;
-}tBTM_BLE_MULTI_ADV_OPQ;
-
-typedef void (tBTM_BLE_MULTI_ADV_CBACK)(tBTM_BLE_MULTI_ADV_EVT evt, UINT8 inst_id,
-                void *p_ref, tBTM_STATUS status);
-
-typedef struct
-{
-    UINT8                       inst_id;
-    BOOLEAN                     in_use;
-    UINT8                       adv_evt;
-    BD_ADDR                     rpa;
-    alarm_t                     *adv_raddr_timer;
-    tBTM_BLE_MULTI_ADV_CBACK    *p_cback;
-    void                        *p_ref;
-    UINT8                       index;
-}tBTM_BLE_MULTI_ADV_INST;
-
-typedef struct
-{
-    UINT8 inst_index_queue[BTM_BLE_MULTI_ADV_MAX];
-    int front;
-    int rear;
-}tBTM_BLE_MULTI_ADV_INST_IDX_Q;
-
-typedef struct
-{
-    tBTM_BLE_MULTI_ADV_INST *p_adv_inst; /* dynamic array to store adv instance */
-    tBTM_BLE_MULTI_ADV_OPQ  op_q;
-}tBTM_BLE_MULTI_ADV_CB;
-
-typedef UINT8 tGATT_IF;
-
-typedef void (tBTM_BLE_SCAN_THRESHOLD_CBACK)(tBTM_BLE_REF_VALUE ref_value);
-typedef void (tBTM_BLE_SCAN_REP_CBACK)(tBTM_BLE_REF_VALUE ref_value, UINT8 report_format,
-                                       UINT8 num_records, UINT16 total_len,
-                                       UINT8* p_rep_data, UINT8 status);
-typedef void (tBTM_BLE_SCAN_SETUP_CBACK)(UINT8 evt, tBTM_BLE_REF_VALUE ref_value, UINT8 status);
-
-#ifndef BTM_BLE_BATCH_SCAN_MAX
-#define BTM_BLE_BATCH_SCAN_MAX   5
-#endif
-
-#ifndef BTM_BLE_BATCH_REP_MAIN_Q_SIZE
-#define BTM_BLE_BATCH_REP_MAIN_Q_SIZE  2
-#endif
-
-typedef enum
-{
-    BTM_BLE_SCAN_INVALID_STATE=0,
-    BTM_BLE_SCAN_ENABLE_CALLED=1,
-    BTM_BLE_SCAN_ENABLED_STATE=2,
-    BTM_BLE_SCAN_DISABLE_CALLED=3,
-    BTM_BLE_SCAN_DISABLED_STATE=4
-}tBTM_BLE_BATCH_SCAN_STATE;
-
-enum
-{
-    BTM_BLE_DISCARD_OLD_ITEMS,
-    BTM_BLE_DISCARD_LOWER_RSSI_ITEMS
-};
-typedef UINT8 tBTM_BLE_DISCARD_RULE;
-
-typedef struct
-{
-    UINT8   sub_code[BTM_BLE_BATCH_SCAN_MAX];
-    tBTM_BLE_BATCH_SCAN_STATE cur_state[BTM_BLE_BATCH_SCAN_MAX];
-    tBTM_BLE_REF_VALUE        ref_value[BTM_BLE_BATCH_SCAN_MAX];
-    UINT8   pending_idx;
-    UINT8   next_idx;
-}tBTM_BLE_BATCH_SCAN_OPQ;
-
-typedef struct
-{
-    UINT8   rep_mode[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
-    tBTM_BLE_REF_VALUE  ref_value[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
-    UINT8   num_records[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
-    UINT16  data_len[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
-    UINT8   *p_data[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
-    UINT8   pending_idx;
-    UINT8   next_idx;
-}tBTM_BLE_BATCH_SCAN_REP_Q;
-
-typedef struct
-{
-    tBTM_BLE_BATCH_SCAN_STATE      cur_state;
-    tBTM_BLE_BATCH_SCAN_MODE scan_mode;
-    UINT32                  scan_interval;
-    UINT32                  scan_window;
-    tBLE_ADDR_TYPE          addr_type;
-    tBTM_BLE_DISCARD_RULE   discard_rule;
-    tBTM_BLE_BATCH_SCAN_OPQ  op_q;
-    tBTM_BLE_BATCH_SCAN_REP_Q main_rep_q;
-    tBTM_BLE_SCAN_SETUP_CBACK     *p_setup_cback;
-    tBTM_BLE_SCAN_THRESHOLD_CBACK *p_thres_cback;
-    tBTM_BLE_SCAN_REP_CBACK       *p_scan_rep_cback;
-    tBTM_BLE_REF_VALUE             ref_value;
-}tBTM_BLE_BATCH_SCAN_CB;
-
-/* filter selection bit index  */
-#define BTM_BLE_PF_ADDR_FILTER          0
-#define BTM_BLE_PF_SRVC_DATA            1
-#define BTM_BLE_PF_SRVC_UUID            2
-#define BTM_BLE_PF_SRVC_SOL_UUID        3
-#define BTM_BLE_PF_LOCAL_NAME           4
-#define BTM_BLE_PF_MANU_DATA            5
-#define BTM_BLE_PF_SRVC_DATA_PATTERN    6
-#define BTM_BLE_PF_TYPE_ALL             7  /* when passed in payload filter type all, only clear action is applicable */
-#define BTM_BLE_PF_TYPE_MAX             8
-
-/* max number of filter spot for different filter type */
-#ifndef BTM_BLE_MAX_UUID_FILTER
-#define BTM_BLE_MAX_UUID_FILTER     8
-#endif
-#ifndef BTM_BLE_MAX_ADDR_FILTER
-#define BTM_BLE_MAX_ADDR_FILTER     8
-#endif
-#ifndef BTM_BLE_PF_STR_COND_MAX
-#define BTM_BLE_PF_STR_COND_MAX     4   /* apply to manu data , or local name */
-#endif
-#ifndef BTM_BLE_PF_STR_LEN_MAX
-#define BTM_BLE_PF_STR_LEN_MAX      29  /* match for first 29 bytes */
-#endif
-
-typedef UINT8   tBTM_BLE_PF_COND_TYPE;
-
-#define BTM_BLE_PF_LOGIC_OR              0
-#define BTM_BLE_PF_LOGIC_AND             1
-typedef UINT8 tBTM_BLE_PF_LOGIC_TYPE;
-
-#define BTM_BLE_PF_ENABLE       1
-#define BTM_BLE_PF_CONFIG       2
-typedef UINT8 tBTM_BLE_PF_ACTION;
-
-typedef UINT8 tBTM_BLE_PF_FILT_INDEX;
-
-typedef UINT8 tBTM_BLE_PF_AVBL_SPACE;
-
-#define BTM_BLE_PF_BRDCAST_ADDR_FILT  1
-#define BTM_BLE_PF_SERV_DATA_CHG_FILT 2
-#define BTM_BLE_PF_SERV_UUID          4
-#define BTM_BLE_PF_SERV_SOLC_UUID     8
-#define BTM_BLE_PF_LOC_NAME_CHECK    16
-#define BTM_BLE_PF_MANUF_NAME_CHECK  32
-#define BTM_BLE_PF_SERV_DATA_CHECK   64
-typedef UINT16 tBTM_BLE_PF_FEAT_SEL;
-
-#define BTM_BLE_PF_LIST_LOGIC_OR   1
-#define BTM_BLE_PF_LIST_LOGIC_AND  2
-typedef UINT16 tBTM_BLE_PF_LIST_LOGIC_TYPE;
-
-#define BTM_BLE_PF_FILT_LOGIC_OR   0
-#define BTM_BLE_PF_FILT_LOGIC_AND  1
-typedef UINT16 tBTM_BLE_PF_FILT_LOGIC_TYPE;
-
-typedef UINT8  tBTM_BLE_PF_RSSI_THRESHOLD;
-typedef UINT8  tBTM_BLE_PF_DELIVERY_MODE;
-typedef UINT16 tBTM_BLE_PF_TIMEOUT;
-typedef UINT8  tBTM_BLE_PF_TIMEOUT_CNT;
-typedef UINT16 tBTM_BLE_PF_ADV_TRACK_ENTRIES;
-
-typedef struct
-{
-    tBTM_BLE_PF_FEAT_SEL feat_seln;
-    tBTM_BLE_PF_LIST_LOGIC_TYPE logic_type;
-    tBTM_BLE_PF_FILT_LOGIC_TYPE filt_logic_type;
-    tBTM_BLE_PF_RSSI_THRESHOLD  rssi_high_thres;
-    tBTM_BLE_PF_RSSI_THRESHOLD  rssi_low_thres;
-    tBTM_BLE_PF_DELIVERY_MODE dely_mode;
-    tBTM_BLE_PF_TIMEOUT found_timeout;
-    tBTM_BLE_PF_TIMEOUT lost_timeout;
-    tBTM_BLE_PF_TIMEOUT_CNT found_timeout_cnt;
-    tBTM_BLE_PF_ADV_TRACK_ENTRIES num_of_tracking_entries;
-}tBTM_BLE_PF_FILT_PARAMS;
-
-enum
-{
-    BTM_BLE_SCAN_COND_ADD,
-    BTM_BLE_SCAN_COND_DELETE,
-    BTM_BLE_SCAN_COND_CLEAR = 2
-};
-typedef UINT8 tBTM_BLE_SCAN_COND_OP;
-
-enum
-{
-    BTM_BLE_FILT_ENABLE_DISABLE = 1,
-    BTM_BLE_FILT_CFG            = 2,
-    BTM_BLE_FILT_ADV_PARAM      = 3
-};
-
-typedef UINT8 tBTM_BLE_FILT_CB_EVT;
-
-/* BLE adv payload filtering config complete callback */
-typedef void (tBTM_BLE_PF_CFG_CBACK)(tBTM_BLE_PF_ACTION action, tBTM_BLE_SCAN_COND_OP cfg_op,
-                                     tBTM_BLE_PF_AVBL_SPACE avbl_space, tBTM_STATUS status,
-                                     tBTM_BLE_REF_VALUE ref_value);
-
-typedef void (tBTM_BLE_PF_CMPL_CBACK) (tBTM_BLE_PF_CFG_CBACK);
-
-/* BLE adv payload filtering status setup complete callback */
-typedef void (tBTM_BLE_PF_STATUS_CBACK) (UINT8 action, tBTM_STATUS status,
-                                        tBTM_BLE_REF_VALUE ref_value);
-
-/* BLE adv payload filtering param setup complete callback */
-typedef void (tBTM_BLE_PF_PARAM_CBACK) (tBTM_BLE_PF_ACTION action_type,
-                                        tBTM_BLE_PF_AVBL_SPACE avbl_space,
-                                        tBTM_BLE_REF_VALUE ref_value, tBTM_STATUS status);
-
-typedef union
-{
-      UINT16              uuid16_mask;
-      UINT32              uuid32_mask;
-      UINT8               uuid128_mask[LEN_UUID_128];
-}tBTM_BLE_PF_COND_MASK;
-
-typedef struct
-{
-    tBLE_BD_ADDR            *p_target_addr;     /* target address, if NULL, generic UUID filter */
-    tBT_UUID                uuid;           /* UUID condition */
-    tBTM_BLE_PF_LOGIC_TYPE  cond_logic;    /* AND/OR */
-    tBTM_BLE_PF_COND_MASK   *p_uuid_mask;           /* UUID mask */
-}tBTM_BLE_PF_UUID_COND;
-
-typedef struct
-{
-    UINT8                   data_len;       /* <= 20 bytes */
-    UINT8                   *p_data;
-}tBTM_BLE_PF_LOCAL_NAME_COND;
-
-typedef struct
-{
-    UINT16                  company_id;     /* company ID */
-    UINT8                   data_len;       /* <= 20 bytes */
-    UINT8                   *p_pattern;
-    UINT16                  company_id_mask; /* UUID value mask */
-    UINT8                   *p_pattern_mask; /* Manufacturer data matching mask,
-                                                same length as data pattern,
-                                                set to all 0xff, match exact data */
-}tBTM_BLE_PF_MANU_COND;
-
-typedef struct
-{
-    UINT16                  uuid;     /* service ID */
-    UINT8                   data_len;       /* <= 20 bytes */
-    UINT8                   *p_pattern;
-    UINT8                   *p_pattern_mask; /* Service data matching mask, same length as data pattern,
-                                                set to all 0xff, match exact data */
-}tBTM_BLE_PF_SRVC_PATTERN_COND;
-
-
-typedef union
-{
-    tBLE_BD_ADDR                            target_addr;
-    tBTM_BLE_PF_LOCAL_NAME_COND             local_name; /* lcoal name filtering */
-    tBTM_BLE_PF_MANU_COND                   manu_data;  /* manufactuer data filtering */
-    tBTM_BLE_PF_UUID_COND                   srvc_uuid;  /* service UUID filtering */
-    tBTM_BLE_PF_UUID_COND                   solicitate_uuid;   /* solicitated service UUID filtering */
-    tBTM_BLE_PF_SRVC_PATTERN_COND           srvc_data;      /* service data pattern */
-}tBTM_BLE_PF_COND_PARAM;
-
-typedef struct
-{
-    UINT8   action_ocf[BTM_BLE_PF_TYPE_MAX];
-    tBTM_BLE_REF_VALUE  ref_value[BTM_BLE_PF_TYPE_MAX];
-    tBTM_BLE_PF_PARAM_CBACK  *p_filt_param_cback[BTM_BLE_PF_TYPE_MAX];
-    tBTM_BLE_PF_CFG_CBACK *p_scan_cfg_cback[BTM_BLE_PF_TYPE_MAX];
-    UINT8   cb_evt[BTM_BLE_PF_TYPE_MAX];
-    UINT8   pending_idx;
-    UINT8   next_idx;
-}tBTM_BLE_ADV_FILTER_ADV_OPQ;
-
-#define BTM_BLE_MAX_FILTER_COUNTER  (BTM_BLE_MAX_ADDR_FILTER + 1) /* per device filter + one generic filter indexed by 0 */
-
-#ifndef BTM_CS_IRK_LIST_MAX
-#define BTM_CS_IRK_LIST_MAX 0x20
-#endif
-
-typedef struct
-{
-    BOOLEAN    in_use;
-    BD_ADDR    bd_addr;
-    UINT8      pf_counter[BTM_BLE_PF_TYPE_MAX]; /* number of filter indexed by tBTM_BLE_PF_COND_TYPE */
-}tBTM_BLE_PF_COUNT;
-
-typedef struct
-{
-    BOOLEAN             enable;
-    UINT8               op_type;
-    tBTM_BLE_PF_COUNT   *p_addr_filter_count; /* per BDA filter array */
-    tBLE_BD_ADDR        cur_filter_target;
-    tBTM_BLE_PF_STATUS_CBACK *p_filt_stat_cback;
-    tBTM_BLE_ADV_FILTER_ADV_OPQ  op_q;
-}tBTM_BLE_ADV_FILTER_CB;
-
-/* Sub codes */
-#define BTM_BLE_META_PF_ENABLE          0x00
-#define BTM_BLE_META_PF_FEAT_SEL        0x01
-#define BTM_BLE_META_PF_ADDR            0x02
-#define BTM_BLE_META_PF_UUID            0x03
-#define BTM_BLE_META_PF_SOL_UUID        0x04
-#define BTM_BLE_META_PF_LOCAL_NAME      0x05
-#define BTM_BLE_META_PF_MANU_DATA       0x06
-#define BTM_BLE_META_PF_SRVC_DATA       0x07
-#define BTM_BLE_META_PF_ALL             0x08
-
-typedef UINT8 BTM_BLE_ADV_STATE;
-typedef UINT8 BTM_BLE_ADV_INFO_PRESENT;
-typedef UINT8 BTM_BLE_RSSI_VALUE;
-typedef UINT16 BTM_BLE_ADV_INFO_TIMESTAMP;
-
-/* These are the fields returned in each device adv packet.  It
-** is returned in the results callback if registered.
-*/
-typedef struct
-{
-    UINT8               conn_mode;
-    tBTM_BLE_AD_MASK    ad_mask;        /* mask of the valid adv data field */
-    UINT8               flag;
-    UINT8               tx_power_level;
-    UINT8               remote_name_len;
-    UINT8               *p_remote_name;
-    tBTM_BLE_SERVICE    service;
-} tBTM_BLE_INQ_DATA;
-
-enum
-{
-    BTM_BLE_CONN_NONE,
-    BTM_BLE_CONN_AUTO,
-    BTM_BLE_CONN_SELECTIVE
-};
-typedef UINT8   tBTM_BLE_CONN_TYPE;
-
-#define ADV_INFO_PRESENT        0x00
-#define NO_ADV_INFO_PRESENT     0x01
-
-typedef btgatt_track_adv_info_t tBTM_BLE_TRACK_ADV_DATA;
-
-typedef void (tBTM_BLE_TRACK_ADV_CBACK)(tBTM_BLE_TRACK_ADV_DATA *p_track_adv_data);
-
-typedef UINT8 tBTM_BLE_TRACK_ADV_EVT;
-
-typedef struct
-{
-    tBTM_BLE_REF_VALUE             ref_value;
-    tBTM_BLE_TRACK_ADV_CBACK *p_track_cback;
-}tBTM_BLE_ADV_TRACK_CB;
-
-enum
-{
-    BTM_BLE_TRACK_ADV_ADD,
-    BTM_BLE_TRACK_ADV_REMOVE
-};
-
-typedef UINT8 tBTM_BLE_TRACK_ADV_ACTION;
-
-#define BTM_BLE_MULTI_ADV_INVALID   0
-
-#define BTM_BLE_BATCH_SCAN_ENABLE_EVT     1
-#define BTM_BLE_BATCH_SCAN_CFG_STRG_EVT   2
-#define BTM_BLE_BATCH_SCAN_READ_REPTS_EVT 3
-#define BTM_BLE_BATCH_SCAN_THR_EVT        4
-#define BTM_BLE_BATCH_SCAN_PARAM_EVT      5
-#define BTM_BLE_BATCH_SCAN_DISABLE_EVT    6
-
-typedef UINT8 tBTM_BLE_BATCH_SCAN_EVT;
-
-typedef UINT32 tBTM_BLE_TX_TIME_MS;
-typedef UINT32 tBTM_BLE_RX_TIME_MS;
-typedef UINT32 tBTM_BLE_IDLE_TIME_MS;
-typedef UINT32 tBTM_BLE_ENERGY_USED;
-
-typedef void (tBTM_BLE_ENERGY_INFO_CBACK)(tBTM_BLE_TX_TIME_MS tx_time, tBTM_BLE_RX_TIME_MS rx_time,
-                                          tBTM_BLE_IDLE_TIME_MS idle_time,
-                                          tBTM_BLE_ENERGY_USED  energy_used,
-                                          tBTM_STATUS status);
-
-typedef struct
-{
-    tBTM_BLE_ENERGY_INFO_CBACK *p_ener_cback;
-}tBTM_BLE_ENERGY_INFO_CB;
-
-typedef BOOLEAN (tBTM_BLE_SEL_CBACK)(BD_ADDR random_bda,     UINT8 *p_remote_name);
-typedef void (tBTM_BLE_CTRL_FEATURES_CBACK)(tBTM_STATUS status);
-
-/* callback function for SMP signing algorithm, signed data in little endian order with tlen bits long */
-typedef void (tBTM_BLE_SIGN_CBACK)(void *p_ref_data, UINT8 *p_signing_data);
-typedef void (tBTM_BLE_VERIFY_CBACK)(void *p_ref_data, BOOLEAN match);
-/* random address set complete callback */
-typedef void (tBTM_BLE_RANDOM_SET_CBACK) (BD_ADDR random_bda);
-
-typedef void (tBTM_BLE_SCAN_REQ_CBACK)(BD_ADDR remote_bda, tBLE_ADDR_TYPE addr_type, UINT8 adv_evt);
-typedef void (*tBLE_SCAN_PARAM_SETUP_CBACK)(tGATT_IF client_if, tBTM_STATUS status);
+#include "btm_ble_api_types.h"
 
 tBTM_BLE_SCAN_SETUP_CBACK bta_ble_scan_setup_cb;
 
diff --git a/stack/include/btm_ble_api_types.h b/stack/include/btm_ble_api_types.h
new file mode 100644
index 000000000..d31028e1a
--- /dev/null
+++ b/stack/include/btm_ble_api_types.h
@@ -0,0 +1,890 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef BTM_BLE_API_TYPES_H
+#define BTM_BLE_API_TYPES_H
+
+#include <hardware/bt_common_types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CHNL_MAP_LEN    5
+typedef UINT8 tBTM_BLE_CHNL_MAP[CHNL_MAP_LEN];
+
+/* 0x00-0x04 only used for set advertising parameter command */
+#define BTM_BLE_CONNECT_EVT     0x00   /* 0x00-0x04 only used for set advertising
+                                            parameter command */
+#define BTM_BLE_CONNECT_DIR_EVT 0x01   /* Connectable directed advertising */
+#define BTM_BLE_DISCOVER_EVT    0x02  /* Scannable undirected advertising */
+#define BTM_BLE_NON_CONNECT_EVT 0x03  /* Non connectable undirected advertising */
+#define BTM_BLE_CONNECT_LO_DUTY_DIR_EVT 0x04        /* Connectable low duty
+                                                       cycle directed advertising  */
+    /* 0x00 - 0x05 can be received on adv event type */
+#define BTM_BLE_SCAN_RSP_EVT    0x04
+#define BTM_BLE_SCAN_REQ_EVT    0x05
+#define BTM_BLE_UNKNOWN_EVT     0xff
+
+#define BTM_BLE_UNKNOWN_EVT     0xff
+
+typedef UINT8 tBTM_BLE_EVT;
+typedef UINT8 tBTM_BLE_CONN_MODE;
+
+typedef UINT32 tBTM_BLE_REF_VALUE;
+
+#define BTM_BLE_SCAN_MODE_PASS      0
+#define BTM_BLE_SCAN_MODE_ACTI      1
+#define BTM_BLE_SCAN_MODE_NONE      0xff
+typedef UINT8 tBLE_SCAN_MODE;
+
+#define BTM_BLE_BATCH_SCAN_MODE_DISABLE 0
+#define BTM_BLE_BATCH_SCAN_MODE_PASS  1
+#define BTM_BLE_BATCH_SCAN_MODE_ACTI  2
+#define BTM_BLE_BATCH_SCAN_MODE_PASS_ACTI 3
+
+typedef UINT8 tBTM_BLE_BATCH_SCAN_MODE;
+
+/* advertising channel map */
+#define BTM_BLE_ADV_CHNL_37    (0x01 << 0)
+#define BTM_BLE_ADV_CHNL_38    (0x01 << 1)
+#define BTM_BLE_ADV_CHNL_39    (0x01 << 2)
+typedef UINT8 tBTM_BLE_ADV_CHNL_MAP;
+
+/*d efault advertising channel map */
+#ifndef BTM_BLE_DEFAULT_ADV_CHNL_MAP
+#define BTM_BLE_DEFAULT_ADV_CHNL_MAP   (BTM_BLE_ADV_CHNL_37| BTM_BLE_ADV_CHNL_38| BTM_BLE_ADV_CHNL_39)
+#endif
+
+/* advertising filter policy */
+#define AP_SCAN_CONN_ALL           0x00        /* default */
+#define AP_SCAN_WL_CONN_ALL        0x01
+#define AP_SCAN_ALL_CONN_WL        0x02
+#define AP_SCAN_CONN_WL            0x03
+#define AP_SCAN_CONN_POLICY_MAX    0x04
+typedef UINT8   tBTM_BLE_AFP;
+
+/* default advertising filter policy */
+#ifndef BTM_BLE_DEFAULT_AFP
+#define BTM_BLE_DEFAULT_AFP   AP_SCAN_CONN_ALL
+#endif
+
+/* scanning filter policy */
+#define SP_ADV_ALL     0x00     /* 0: accept adv packet from all, directed adv pkt not directed */
+                                /* to local device is ignored */
+#define SP_ADV_WL      0x01     /* 1: accept adv packet from device in white list, directed adv */
+                                /* packet not directed to local device is ignored */
+#define SP_ADV_ALL_RPA_DIR_ADV 0x02  /* 2: accept adv packet from all, directed adv pkt */
+                                     /* not directed to me is ignored except direct adv with RPA */
+#define SP_ADV_WL_RPA_DIR_ADV  0x03  /* 3: accept adv packet from device in white list, directed */
+                                     /* adv pkt not directed to me is ignored except direct adv */
+                                     /* with RPA */
+typedef UINT8   tBTM_BLE_SFP;
+
+#ifndef BTM_BLE_DEFAULT_SFP
+#define BTM_BLE_DEFAULT_SFP   SP_ADV_ALL
+#endif
+
+/* adv parameter boundary values */
+#define BTM_BLE_ADV_INT_MIN            0x0020
+#define BTM_BLE_ADV_INT_MAX            0x4000
+
+/* Full scan boundary values */
+#define BTM_BLE_ADV_SCAN_FULL_MIN      0x00
+#define BTM_BLE_ADV_SCAN_FULL_MAX      0x64
+
+/* Partial scan boundary values */
+#define BTM_BLE_ADV_SCAN_TRUNC_MIN      BTM_BLE_ADV_SCAN_FULL_MIN
+#define BTM_BLE_ADV_SCAN_TRUNC_MAX      BTM_BLE_ADV_SCAN_FULL_MAX
+
+/* Threshold values */
+#define BTM_BLE_ADV_SCAN_THR_MIN        BTM_BLE_ADV_SCAN_FULL_MIN
+#define BTM_BLE_ADV_SCAN_THR_MAX        BTM_BLE_ADV_SCAN_FULL_MAX
+
+/* connection parameter boundary values */
+#define BTM_BLE_SCAN_INT_MIN            0x0004
+#define BTM_BLE_SCAN_INT_MAX            0x4000
+#define BTM_BLE_SCAN_WIN_MIN            0x0004
+#define BTM_BLE_SCAN_WIN_MAX            0x4000
+#define BTM_BLE_EXT_SCAN_INT_MAX        0x00FFFFFF
+#define BTM_BLE_EXT_SCAN_WIN_MAX        0xFFFF
+#define BTM_BLE_CONN_INT_MIN            0x0006
+#define BTM_BLE_CONN_INT_MAX            0x0C80
+#define BTM_BLE_CONN_LATENCY_MAX        500
+#define BTM_BLE_CONN_SUP_TOUT_MIN       0x000A
+#define BTM_BLE_CONN_SUP_TOUT_MAX       0x0C80
+#define BTM_BLE_CONN_PARAM_UNDEF        0xffff      /* use this value when a specific value not to be overwritten */
+#define BTM_BLE_SCAN_PARAM_UNDEF        0xffffffff
+
+/* default connection parameters if not configured, use GAP recommend value for auto/selective connection */
+/* default scan interval */
+#ifndef BTM_BLE_SCAN_FAST_INT
+#define BTM_BLE_SCAN_FAST_INT    96    /* 30 ~ 60 ms (use 60)  = 96 *0.625 */
+#endif
+/* default scan window for background connection, applicable for auto connection or selective conenction */
+#ifndef BTM_BLE_SCAN_FAST_WIN
+#define BTM_BLE_SCAN_FAST_WIN   48      /* 30 ms = 48 *0.625 */
+#endif
+
+/* default scan paramter used in reduced power cycle (background scanning) */
+#ifndef BTM_BLE_SCAN_SLOW_INT_1
+#define BTM_BLE_SCAN_SLOW_INT_1    2048    /* 1.28 s   = 2048 *0.625 */
+#endif
+#ifndef BTM_BLE_SCAN_SLOW_WIN_1
+#define BTM_BLE_SCAN_SLOW_WIN_1   48      /* 30 ms = 48 *0.625 */
+#endif
+
+/* default scan paramter used in reduced power cycle (background scanning) */
+#ifndef BTM_BLE_SCAN_SLOW_INT_2
+#define BTM_BLE_SCAN_SLOW_INT_2    4096    /* 2.56 s   = 4096 *0.625 */
+#endif
+#ifndef BTM_BLE_SCAN_SLOW_WIN_2
+#define BTM_BLE_SCAN_SLOW_WIN_2   36      /* 22.5 ms = 36 *0.625 */
+#endif
+
+/* default connection interval min */
+#ifndef BTM_BLE_CONN_INT_MIN_DEF
+#define BTM_BLE_CONN_INT_MIN_DEF     24      /* recommended min: 30ms  = 24 * 1.25 */
+#endif
+
+/* default connectino interval max */
+#ifndef BTM_BLE_CONN_INT_MAX_DEF
+#define BTM_BLE_CONN_INT_MAX_DEF     40      /* recommended max: 50 ms = 56 * 1.25 */
+#endif
+
+/* default slave latency */
+#ifndef BTM_BLE_CONN_SLAVE_LATENCY_DEF
+#define BTM_BLE_CONN_SLAVE_LATENCY_DEF  0      /* 0 */
+#endif
+
+/* default supervision timeout */
+#ifndef BTM_BLE_CONN_TIMEOUT_DEF
+#define BTM_BLE_CONN_TIMEOUT_DEF    2000
+#endif
+
+/* minimum supervision timeout */
+#ifndef BTM_BLE_CONN_TIMEOUT_MIN_DEF
+#define BTM_BLE_CONN_TIMEOUT_MIN_DEF    100
+#endif
+
+/* minimum acceptable connection interval */
+#ifndef BTM_BLE_CONN_INT_MIN_LIMIT
+#define BTM_BLE_CONN_INT_MIN_LIMIT     0x0009
+#endif
+
+#define BTM_BLE_DIR_CONN_FALLBACK_UNDIR         1
+#define BTM_BLE_DIR_CONN_FALLBACK_NO_ADV        2
+
+#ifndef BTM_BLE_DIR_CONN_FALLBACK
+#define BTM_BLE_DIR_CONN_FALLBACK   BTM_BLE_DIR_CONN_FALLBACK_UNDIR
+#endif
+
+#define BTM_CMAC_TLEN_SIZE          8                   /* 64 bits */
+#define BTM_BLE_AUTH_SIGN_LEN       12                   /* BLE data signature length 8 Bytes + 4 bytes counter*/
+typedef UINT8 BLE_SIGNATURE[BTM_BLE_AUTH_SIGN_LEN];         /* Device address */
+
+#ifndef BTM_BLE_HOST_SUPPORT
+#define BTM_BLE_HOST_SUPPORT        0x01
+#endif
+
+#ifndef BTM_BLE_SIMULTANEOUS_HOST
+#define BTM_BLE_SIMULTANEOUS_HOST   0x01
+#endif
+
+/* Appearance Values Reported with BTM_BLE_AD_TYPE_APPEARANCE */
+#define BTM_BLE_APPEARANCE_UKNOWN                  0x0000
+#define BTM_BLE_APPEARANCE_GENERIC_PHONE           0x0040
+#define BTM_BLE_APPEARANCE_GENERIC_COMPUTER        0x0080
+#define BTM_BLE_APPEARANCE_GENERIC_WATCH           0x00C0
+#define BTM_BLE_APPEARANCE_SPORTS_WATCH            0x00C1
+#define BTM_BLE_APPEARANCE_GENERIC_CLOCK           0x0100
+#define BTM_BLE_APPEARANCE_GENERIC_DISPLAY         0x0140
+#define BTM_BLE_APPEARANCE_GENERIC_REMOTE          0x0180
+#define BTM_BLE_APPEARANCE_GENERIC_EYEGLASSES      0x01C0
+#define BTM_BLE_APPEARANCE_GENERIC_TAG             0x0200
+#define BTM_BLE_APPEARANCE_GENERIC_KEYRING         0x0240
+#define BTM_BLE_APPEARANCE_GENERIC_MEDIA_PLAYER    0x0280
+#define BTM_BLE_APPEARANCE_GENERIC_BARCODE_SCANNER 0x02C0
+#define BTM_BLE_APPEARANCE_GENERIC_THERMOMETER     0x0300
+#define BTM_BLE_APPEARANCE_THERMOMETER_EAR         0x0301
+#define BTM_BLE_APPEARANCE_GENERIC_HEART_RATE      0x0340
+#define BTM_BLE_APPEARANCE_HEART_RATE_BELT         0x0341
+#define BTM_BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE  0x0380
+#define BTM_BLE_APPEARANCE_BLOOD_PRESSURE_ARM      0x0381
+#define BTM_BLE_APPEARANCE_BLOOD_PRESSURE_WRIST    0x0382
+#define BTM_BLE_APPEARANCE_GENERIC_HID             0x03C0
+#define BTM_BLE_APPEARANCE_HID_KEYBOARD            0x03C1
+#define BTM_BLE_APPEARANCE_HID_MOUSE               0x03C2
+#define BTM_BLE_APPEARANCE_HID_JOYSTICK            0x03C3
+#define BTM_BLE_APPEARANCE_HID_GAMEPAD             0x03C4
+#define BTM_BLE_APPEARANCE_HID_DIGITIZER_TABLET    0x03C5
+#define BTM_BLE_APPEARANCE_HID_CARD_READER         0x03C6
+#define BTM_BLE_APPEARANCE_HID_DIGITAL_PEN         0x03C7
+#define BTM_BLE_APPEARANCE_HID_BARCODE_SCANNER     0x03C8
+#define BTM_BLE_APPEARANCE_GENERIC_GLUCOSE         0x0400
+#define BTM_BLE_APPEARANCE_GENERIC_WALKING         0x0440
+#define BTM_BLE_APPEARANCE_WALKING_IN_SHOE         0x0441
+#define BTM_BLE_APPEARANCE_WALKING_ON_SHOE         0x0442
+#define BTM_BLE_APPEARANCE_WALKING_ON_HIP          0x0443
+#define BTM_BLE_APPEARANCE_GENERIC_CYCLING         0x0480
+#define BTM_BLE_APPEARANCE_CYCLING_COMPUTER        0x0481
+#define BTM_BLE_APPEARANCE_CYCLING_SPEED           0x0482
+#define BTM_BLE_APPEARANCE_CYCLING_CADENCE         0x0483
+#define BTM_BLE_APPEARANCE_CYCLING_POWER           0x0484
+#define BTM_BLE_APPEARANCE_CYCLING_SPEED_CADENCE   0x0485
+#define BTM_BLE_APPEARANCE_GENERIC_PULSE_OXIMETER  0x0C40
+#define BTM_BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP 0x0C41
+#define BTM_BLE_APPEARANCE_PULSE_OXIMETER_WRIST    0x0C42
+#define BTM_BLE_APPEARANCE_GENERIC_WEIGHT          0x0C80
+#define BTM_BLE_APPEARANCE_GENERIC_OUTDOOR_SPORTS  0x1440
+#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION 0x1441
+#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_AND_NAV     0x1442
+#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_POD         0x1443
+#define BTM_BLE_APPEARANCE_OUTDOOR_SPORTS_LOCATION_POD_AND_NAV 0x1444
+
+
+/* Structure returned with Rand/Encrypt complete callback */
+typedef struct
+{
+    UINT8   status;
+    UINT8   param_len;
+    UINT16  opcode;
+    UINT8   param_buf[BT_OCTET16_LEN];
+} tBTM_RAND_ENC;
+
+/* General callback function for notifying an application that a synchronous
+** BTM function is complete. The pointer contains the address of any returned data.
+*/
+typedef void (tBTM_RAND_ENC_CB) (tBTM_RAND_ENC *p1);
+
+#define BTM_BLE_FILTER_TARGET_SCANNER       0x01
+#define BTM_BLE_FILTER_TARGET_ADVR          0x00
+
+#define BTM_BLE_POLICY_BLACK_ALL            0x00    /* relevant to both */
+#define BTM_BLE_POLICY_ALLOW_SCAN           0x01    /* relevant to advertiser */
+#define BTM_BLE_POLICY_ALLOW_CONN           0x02    /* relevant to advertiser */
+#define BTM_BLE_POLICY_WHITE_ALL            0x03    /* relevant to both */
+
+/* ADV data flag bit definition used for BTM_BLE_AD_TYPE_FLAG */
+#define BTM_BLE_LIMIT_DISC_FLAG         (0x01 << 0)
+#define BTM_BLE_GEN_DISC_FLAG           (0x01 << 1)
+#define BTM_BLE_BREDR_NOT_SPT           (0x01 << 2)
+/* 4.1 spec adv flag for simultaneous BR/EDR+LE connection support */
+#define BTM_BLE_DMT_CONTROLLER_SPT      (0x01 << 3)
+#define BTM_BLE_DMT_HOST_SPT            (0x01 << 4)
+#define BTM_BLE_NON_LIMIT_DISC_FLAG     (0x00 )         /* lowest bit unset */
+#define BTM_BLE_ADV_FLAG_MASK           (BTM_BLE_LIMIT_DISC_FLAG | BTM_BLE_BREDR_NOT_SPT | BTM_BLE_GEN_DISC_FLAG)
+#define BTM_BLE_LIMIT_DISC_MASK         (BTM_BLE_LIMIT_DISC_FLAG )
+
+#define BTM_BLE_AD_BIT_DEV_NAME        (0x00000001 << 0)
+#define BTM_BLE_AD_BIT_FLAGS           (0x00000001 << 1)
+#define BTM_BLE_AD_BIT_MANU            (0x00000001 << 2)
+#define BTM_BLE_AD_BIT_TX_PWR          (0x00000001 << 3)
+#define BTM_BLE_AD_BIT_INT_RANGE       (0x00000001 << 5)
+#define BTM_BLE_AD_BIT_SERVICE         (0x00000001 << 6)
+#define BTM_BLE_AD_BIT_SERVICE_SOL     (0x00000001 << 7)
+#define BTM_BLE_AD_BIT_SERVICE_DATA    (0x00000001 << 8)
+#define BTM_BLE_AD_BIT_SIGN_DATA       (0x00000001 << 9)
+#define BTM_BLE_AD_BIT_SERVICE_128SOL  (0x00000001 << 10)
+#define BTM_BLE_AD_BIT_APPEARANCE      (0x00000001 << 11)
+#define BTM_BLE_AD_BIT_PUBLIC_ADDR      (0x00000001 << 12)
+#define BTM_BLE_AD_BIT_RANDOM_ADDR       (0x00000001 << 13)
+#define BTM_BLE_AD_BIT_SERVICE_32        (0x00000001 << 4)
+#define BTM_BLE_AD_BIT_SERVICE_32SOL     (0x00000001 << 14)
+#define BTM_BLE_AD_BIT_PROPRIETARY     (0x00000001 << 15)
+#define BTM_BLE_AD_BIT_SERVICE_128      (0x00000001 << 16)      /*128-bit Service UUIDs*/
+
+typedef  UINT32  tBTM_BLE_AD_MASK;
+
+#define BTM_BLE_AD_TYPE_FLAG            HCI_EIR_FLAGS_TYPE                  /* 0x01 */
+#define BTM_BLE_AD_TYPE_16SRV_PART      HCI_EIR_MORE_16BITS_UUID_TYPE       /* 0x02 */
+#define BTM_BLE_AD_TYPE_16SRV_CMPL      HCI_EIR_COMPLETE_16BITS_UUID_TYPE   /* 0x03 */
+#define BTM_BLE_AD_TYPE_32SRV_PART      HCI_EIR_MORE_32BITS_UUID_TYPE       /* 0x04 */
+#define BTM_BLE_AD_TYPE_32SRV_CMPL      HCI_EIR_COMPLETE_32BITS_UUID_TYPE   /* 0x05 */
+#define BTM_BLE_AD_TYPE_128SRV_PART     HCI_EIR_MORE_128BITS_UUID_TYPE       /* 0x06 */
+#define BTM_BLE_AD_TYPE_128SRV_CMPL     HCI_EIR_COMPLETE_128BITS_UUID_TYPE   /* 0x07 */
+#define BTM_BLE_AD_TYPE_NAME_SHORT      HCI_EIR_SHORTENED_LOCAL_NAME_TYPE       /* 0x08 */
+#define BTM_BLE_AD_TYPE_NAME_CMPL       HCI_EIR_COMPLETE_LOCAL_NAME_TYPE        /* 0x09 */
+#define BTM_BLE_AD_TYPE_TX_PWR          HCI_EIR_TX_POWER_LEVEL_TYPE             /* 0x0A */
+#define BTM_BLE_AD_TYPE_DEV_CLASS       0x0D
+#define BTM_BLE_AD_TYPE_SM_TK           0x10
+#define BTM_BLE_AD_TYPE_SM_OOB_FLAG     0x11
+#define BTM_BLE_AD_TYPE_INT_RANGE       0x12
+#define BTM_BLE_AD_TYPE_SOL_SRV_UUID    0x14
+#define BTM_BLE_AD_TYPE_128SOL_SRV_UUID 0x15
+#define BTM_BLE_AD_TYPE_SERVICE_DATA    0x16
+#define BTM_BLE_AD_TYPE_PUBLIC_TARGET   0x17
+#define BTM_BLE_AD_TYPE_RANDOM_TARGET   0x18
+#define BTM_BLE_AD_TYPE_APPEARANCE      0x19
+#define BTM_BLE_AD_TYPE_ADV_INT         0x1a
+#define BTM_BLE_AD_TYPE_32SOL_SRV_UUID  0x1b
+#define BTM_BLE_AD_TYPE_32SERVICE_DATA  0x1c
+#define BTM_BLE_AD_TYPE_128SERVICE_DATA 0x1d
+
+#define BTM_BLE_AD_TYPE_MANU            HCI_EIR_MANUFACTURER_SPECIFIC_TYPE      /* 0xff */
+typedef UINT8   tBTM_BLE_AD_TYPE;
+
+/*  Security settings used with L2CAP LE COC */
+#define BTM_SEC_LE_LINK_ENCRYPTED           0x01
+#define BTM_SEC_LE_LINK_PAIRED_WITHOUT_MITM 0x02
+#define BTM_SEC_LE_LINK_PAIRED_WITH_MITM    0x04
+
+/*  Min/max Preferred  number of payload octets that the local Controller
+    should include in a single Link Layer Data Channel PDU. */
+#define BTM_BLE_DATA_SIZE_MAX     0x00fb
+#define BTM_BLE_DATA_SIZE_MIN     0x001b
+
+/*  Preferred maximum number of microseconds that the local Controller
+    should use to transmit a single Link Layer Data Channel PDU. */
+#define BTM_BLE_DATA_TX_TIME_MIN     0x0148
+#define BTM_BLE_DATA_TX_TIME_MAX     0x0848
+
+/* adv tx power level */
+#define BTM_BLE_ADV_TX_POWER_MIN        0           /* minimum tx power */
+#define BTM_BLE_ADV_TX_POWER_LOW        1           /* low tx power     */
+#define BTM_BLE_ADV_TX_POWER_MID        2           /* middle tx power  */
+#define BTM_BLE_ADV_TX_POWER_UPPER      3           /* upper tx power   */
+#define BTM_BLE_ADV_TX_POWER_MAX        4           /* maximum tx power */
+typedef UINT8 tBTM_BLE_ADV_TX_POWER;
+
+/* adv tx power in dBm */
+typedef struct
+{
+    UINT8 adv_inst_max;         /* max adv instance supported in controller */
+    UINT8 rpa_offloading;
+    UINT16 tot_scan_results_strg;
+    UINT8 max_irk_list_sz;
+    UINT8 filter_support;
+    UINT8 max_filter;
+    UINT8 energy_support;
+    BOOLEAN values_read;
+    UINT16 version_supported;
+    UINT16 total_trackable_advertisers;
+    UINT8 extended_scan_support;
+    UINT8 debug_logging_supported;
+}tBTM_BLE_VSC_CB;
+
+/* slave preferred connection interval range */
+typedef struct
+{
+    UINT16  low;
+    UINT16  hi;
+
+}tBTM_BLE_INT_RANGE;
+
+/* Service tag supported in the device */
+#define MAX_16BIT_SERVICES 16
+typedef struct
+{
+    UINT8       num_service;
+    BOOLEAN     list_cmpl;
+    UINT16      uuid[MAX_16BIT_SERVICES];
+}tBTM_BLE_SERVICE;
+
+/* 32 bits Service supported in the device */
+#define MAX_32BIT_SERVICES 4
+typedef struct
+{
+    UINT8       num_service;
+    BOOLEAN     list_cmpl;
+    UINT32      uuid[MAX_32BIT_SERVICES];
+}tBTM_BLE_32SERVICE;
+
+/* 128 bits Service supported in the device */
+typedef struct
+{
+    UINT8       num_service;
+    BOOLEAN     list_cmpl;
+    UINT8       uuid128[MAX_UUID_SIZE];
+}tBTM_BLE_128SERVICE;
+
+#define MAX_SIZE_MANUFACTURER_DATA 32
+typedef struct
+{
+    UINT8 len;
+    UINT8 val[MAX_SIZE_MANUFACTURER_DATA];
+}tBTM_BLE_MANU;
+
+#define MAX_SIZE_SERVICE_DATA 32
+typedef struct
+{
+    tBT_UUID    service_uuid;
+    UINT8       len;
+    UINT8       val[MAX_SIZE_SERVICE_DATA];
+}tBTM_BLE_SERVICE_DATA;
+
+#define MAX_SIZE_PROPRIETARY_ELEMENT 32
+typedef struct
+{
+    UINT8       adv_type;
+    UINT8       len;
+    UINT8       val[MAX_SIZE_PROPRIETARY_ELEMENT];     /* number of len byte */
+}tBTM_BLE_PROP_ELEM;
+
+#define MAX_PROPRIETARY_ELEMENTS 4
+typedef struct
+{
+    UINT8                   num_elem;
+    tBTM_BLE_PROP_ELEM      elem[MAX_PROPRIETARY_ELEMENTS];
+}tBTM_BLE_PROPRIETARY;
+
+typedef struct
+{
+    tBTM_BLE_INT_RANGE      int_range;      /* slave prefered conn interval range */
+    tBTM_BLE_MANU           manu;           /* manufactuer data */
+    tBTM_BLE_SERVICE        services;       /* services */
+    tBTM_BLE_128SERVICE     services_128b;  /* 128 bits service */
+    tBTM_BLE_32SERVICE      service_32b;     /* 32 bits Service UUID */
+    tBTM_BLE_SERVICE        sol_services;    /* 16 bits services Solicitation UUIDs */
+    tBTM_BLE_32SERVICE      sol_service_32b;    /* List of 32 bit Service Solicitation UUIDs */
+    tBTM_BLE_128SERVICE     sol_service_128b;    /* List of 128 bit Service Solicitation UUIDs */
+    tBTM_BLE_PROPRIETARY    proprietary;
+    tBTM_BLE_SERVICE_DATA   service_data;    /* service data */
+    UINT16                  appearance;
+    UINT8                   flag;
+    UINT8                   tx_power;
+}tBTM_BLE_ADV_DATA;
+
+#ifndef BTM_BLE_MULTI_ADV_MAX
+#define BTM_BLE_MULTI_ADV_MAX   16 /* controller returned adv_inst_max should be less
+                                      than this number */
+#endif
+
+#define BTM_BLE_MULTI_ADV_INVALID   0
+
+#define BTM_BLE_MULTI_ADV_ENB_EVT           1
+#define BTM_BLE_MULTI_ADV_DISABLE_EVT       2
+#define BTM_BLE_MULTI_ADV_PARAM_EVT         3
+#define BTM_BLE_MULTI_ADV_DATA_EVT          4
+typedef UINT8 tBTM_BLE_MULTI_ADV_EVT;
+
+#define BTM_BLE_MULTI_ADV_DEFAULT_STD 0
+
+typedef struct
+{
+    UINT16          adv_int_min;
+    UINT16          adv_int_max;
+    UINT8           adv_type;
+    tBTM_BLE_ADV_CHNL_MAP channel_map;
+    tBTM_BLE_AFP    adv_filter_policy;
+    tBTM_BLE_ADV_TX_POWER tx_power;
+}tBTM_BLE_ADV_PARAMS;
+
+typedef struct
+{
+    UINT8   *p_sub_code; /* dynamic array to store sub code */
+    UINT8   *p_inst_id;  /* dynamic array to store instance id */
+    UINT8   pending_idx;
+    UINT8   next_idx;
+}tBTM_BLE_MULTI_ADV_OPQ;
+
+typedef void (tBTM_BLE_MULTI_ADV_CBACK)(tBTM_BLE_MULTI_ADV_EVT evt, UINT8 inst_id,
+                void *p_ref, tBTM_STATUS status);
+
+typedef struct
+{
+    UINT8                       inst_id;
+    BOOLEAN                     in_use;
+    UINT8                       adv_evt;
+    BD_ADDR                     rpa;
+    alarm_t                     *adv_raddr_timer;
+    tBTM_BLE_MULTI_ADV_CBACK    *p_cback;
+    void                        *p_ref;
+    UINT8                       index;
+}tBTM_BLE_MULTI_ADV_INST;
+
+typedef struct
+{
+    UINT8 inst_index_queue[BTM_BLE_MULTI_ADV_MAX];
+    int front;
+    int rear;
+}tBTM_BLE_MULTI_ADV_INST_IDX_Q;
+
+typedef struct
+{
+    tBTM_BLE_MULTI_ADV_INST *p_adv_inst; /* dynamic array to store adv instance */
+    tBTM_BLE_MULTI_ADV_OPQ  op_q;
+}tBTM_BLE_MULTI_ADV_CB;
+
+typedef UINT8 tGATT_IF;
+
+typedef void (tBTM_BLE_SCAN_THRESHOLD_CBACK)(tBTM_BLE_REF_VALUE ref_value);
+typedef void (tBTM_BLE_SCAN_REP_CBACK)(tBTM_BLE_REF_VALUE ref_value, UINT8 report_format,
+                                       UINT8 num_records, UINT16 total_len,
+                                       UINT8* p_rep_data, UINT8 status);
+typedef void (tBTM_BLE_SCAN_SETUP_CBACK)(UINT8 evt, tBTM_BLE_REF_VALUE ref_value, UINT8 status);
+
+#ifndef BTM_BLE_BATCH_SCAN_MAX
+#define BTM_BLE_BATCH_SCAN_MAX   5
+#endif
+
+#ifndef BTM_BLE_BATCH_REP_MAIN_Q_SIZE
+#define BTM_BLE_BATCH_REP_MAIN_Q_SIZE  2
+#endif
+
+typedef enum
+{
+    BTM_BLE_SCAN_INVALID_STATE=0,
+    BTM_BLE_SCAN_ENABLE_CALLED=1,
+    BTM_BLE_SCAN_ENABLED_STATE=2,
+    BTM_BLE_SCAN_DISABLE_CALLED=3,
+    BTM_BLE_SCAN_DISABLED_STATE=4
+}tBTM_BLE_BATCH_SCAN_STATE;
+
+enum
+{
+    BTM_BLE_DISCARD_OLD_ITEMS,
+    BTM_BLE_DISCARD_LOWER_RSSI_ITEMS
+};
+typedef UINT8 tBTM_BLE_DISCARD_RULE;
+
+typedef struct
+{
+    UINT8   sub_code[BTM_BLE_BATCH_SCAN_MAX];
+    tBTM_BLE_BATCH_SCAN_STATE cur_state[BTM_BLE_BATCH_SCAN_MAX];
+    tBTM_BLE_REF_VALUE        ref_value[BTM_BLE_BATCH_SCAN_MAX];
+    UINT8   pending_idx;
+    UINT8   next_idx;
+}tBTM_BLE_BATCH_SCAN_OPQ;
+
+typedef struct
+{
+    UINT8   rep_mode[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
+    tBTM_BLE_REF_VALUE  ref_value[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
+    UINT8   num_records[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
+    UINT16  data_len[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
+    UINT8   *p_data[BTM_BLE_BATCH_REP_MAIN_Q_SIZE];
+    UINT8   pending_idx;
+    UINT8   next_idx;
+}tBTM_BLE_BATCH_SCAN_REP_Q;
+
+typedef struct
+{
+    tBTM_BLE_BATCH_SCAN_STATE      cur_state;
+    tBTM_BLE_BATCH_SCAN_MODE scan_mode;
+    UINT32                  scan_interval;
+    UINT32                  scan_window;
+    tBLE_ADDR_TYPE          addr_type;
+    tBTM_BLE_DISCARD_RULE   discard_rule;
+    tBTM_BLE_BATCH_SCAN_OPQ  op_q;
+    tBTM_BLE_BATCH_SCAN_REP_Q main_rep_q;
+    tBTM_BLE_SCAN_SETUP_CBACK     *p_setup_cback;
+    tBTM_BLE_SCAN_THRESHOLD_CBACK *p_thres_cback;
+    tBTM_BLE_SCAN_REP_CBACK       *p_scan_rep_cback;
+    tBTM_BLE_REF_VALUE             ref_value;
+}tBTM_BLE_BATCH_SCAN_CB;
+
+/* filter selection bit index  */
+#define BTM_BLE_PF_ADDR_FILTER          0
+#define BTM_BLE_PF_SRVC_DATA            1
+#define BTM_BLE_PF_SRVC_UUID            2
+#define BTM_BLE_PF_SRVC_SOL_UUID        3
+#define BTM_BLE_PF_LOCAL_NAME           4
+#define BTM_BLE_PF_MANU_DATA            5
+#define BTM_BLE_PF_SRVC_DATA_PATTERN    6
+#define BTM_BLE_PF_TYPE_ALL             7  /* when passed in payload filter type all, only clear action is applicable */
+#define BTM_BLE_PF_TYPE_MAX             8
+
+/* max number of filter spot for different filter type */
+#ifndef BTM_BLE_MAX_UUID_FILTER
+#define BTM_BLE_MAX_UUID_FILTER     8
+#endif
+#ifndef BTM_BLE_MAX_ADDR_FILTER
+#define BTM_BLE_MAX_ADDR_FILTER     8
+#endif
+#ifndef BTM_BLE_PF_STR_COND_MAX
+#define BTM_BLE_PF_STR_COND_MAX     4   /* apply to manu data , or local name */
+#endif
+#ifndef BTM_BLE_PF_STR_LEN_MAX
+#define BTM_BLE_PF_STR_LEN_MAX      29  /* match for first 29 bytes */
+#endif
+
+typedef UINT8   tBTM_BLE_PF_COND_TYPE;
+
+#define BTM_BLE_PF_LOGIC_OR              0
+#define BTM_BLE_PF_LOGIC_AND             1
+typedef UINT8 tBTM_BLE_PF_LOGIC_TYPE;
+
+#define BTM_BLE_PF_ENABLE       1
+#define BTM_BLE_PF_CONFIG       2
+typedef UINT8 tBTM_BLE_PF_ACTION;
+
+typedef UINT8 tBTM_BLE_PF_FILT_INDEX;
+
+typedef UINT8 tBTM_BLE_PF_AVBL_SPACE;
+
+#define BTM_BLE_PF_BRDCAST_ADDR_FILT  1
+#define BTM_BLE_PF_SERV_DATA_CHG_FILT 2
+#define BTM_BLE_PF_SERV_UUID          4
+#define BTM_BLE_PF_SERV_SOLC_UUID     8
+#define BTM_BLE_PF_LOC_NAME_CHECK    16
+#define BTM_BLE_PF_MANUF_NAME_CHECK  32
+#define BTM_BLE_PF_SERV_DATA_CHECK   64
+typedef UINT16 tBTM_BLE_PF_FEAT_SEL;
+
+#define BTM_BLE_PF_LIST_LOGIC_OR   1
+#define BTM_BLE_PF_LIST_LOGIC_AND  2
+typedef UINT16 tBTM_BLE_PF_LIST_LOGIC_TYPE;
+
+#define BTM_BLE_PF_FILT_LOGIC_OR   0
+#define BTM_BLE_PF_FILT_LOGIC_AND  1
+typedef UINT16 tBTM_BLE_PF_FILT_LOGIC_TYPE;
+
+typedef UINT8  tBTM_BLE_PF_RSSI_THRESHOLD;
+typedef UINT8  tBTM_BLE_PF_DELIVERY_MODE;
+typedef UINT16 tBTM_BLE_PF_TIMEOUT;
+typedef UINT8  tBTM_BLE_PF_TIMEOUT_CNT;
+typedef UINT16 tBTM_BLE_PF_ADV_TRACK_ENTRIES;
+
+typedef struct
+{
+    tBTM_BLE_PF_FEAT_SEL feat_seln;
+    tBTM_BLE_PF_LIST_LOGIC_TYPE logic_type;
+    tBTM_BLE_PF_FILT_LOGIC_TYPE filt_logic_type;
+    tBTM_BLE_PF_RSSI_THRESHOLD  rssi_high_thres;
+    tBTM_BLE_PF_RSSI_THRESHOLD  rssi_low_thres;
+    tBTM_BLE_PF_DELIVERY_MODE dely_mode;
+    tBTM_BLE_PF_TIMEOUT found_timeout;
+    tBTM_BLE_PF_TIMEOUT lost_timeout;
+    tBTM_BLE_PF_TIMEOUT_CNT found_timeout_cnt;
+    tBTM_BLE_PF_ADV_TRACK_ENTRIES num_of_tracking_entries;
+}tBTM_BLE_PF_FILT_PARAMS;
+
+enum
+{
+    BTM_BLE_SCAN_COND_ADD,
+    BTM_BLE_SCAN_COND_DELETE,
+    BTM_BLE_SCAN_COND_CLEAR = 2
+};
+typedef UINT8 tBTM_BLE_SCAN_COND_OP;
+
+enum
+{
+    BTM_BLE_FILT_ENABLE_DISABLE = 1,
+    BTM_BLE_FILT_CFG            = 2,
+    BTM_BLE_FILT_ADV_PARAM      = 3
+};
+
+typedef UINT8 tBTM_BLE_FILT_CB_EVT;
+
+/* BLE adv payload filtering config complete callback */
+typedef void (tBTM_BLE_PF_CFG_CBACK)(tBTM_BLE_PF_ACTION action, tBTM_BLE_SCAN_COND_OP cfg_op,
+                                     tBTM_BLE_PF_AVBL_SPACE avbl_space, tBTM_STATUS status,
+                                     tBTM_BLE_REF_VALUE ref_value);
+
+typedef void (tBTM_BLE_PF_CMPL_CBACK) (tBTM_BLE_PF_CFG_CBACK);
+
+/* BLE adv payload filtering status setup complete callback */
+typedef void (tBTM_BLE_PF_STATUS_CBACK) (UINT8 action, tBTM_STATUS status,
+                                        tBTM_BLE_REF_VALUE ref_value);
+
+/* BLE adv payload filtering param setup complete callback */
+typedef void (tBTM_BLE_PF_PARAM_CBACK) (tBTM_BLE_PF_ACTION action_type,
+                                        tBTM_BLE_PF_AVBL_SPACE avbl_space,
+                                        tBTM_BLE_REF_VALUE ref_value, tBTM_STATUS status);
+
+typedef union
+{
+      UINT16              uuid16_mask;
+      UINT32              uuid32_mask;
+      UINT8               uuid128_mask[LEN_UUID_128];
+}tBTM_BLE_PF_COND_MASK;
+
+typedef struct
+{
+    tBLE_BD_ADDR            *p_target_addr;     /* target address, if NULL, generic UUID filter */
+    tBT_UUID                uuid;           /* UUID condition */
+    tBTM_BLE_PF_LOGIC_TYPE  cond_logic;    /* AND/OR */
+    tBTM_BLE_PF_COND_MASK   *p_uuid_mask;           /* UUID mask */
+}tBTM_BLE_PF_UUID_COND;
+
+typedef struct
+{
+    UINT8                   data_len;       /* <= 20 bytes */
+    UINT8                   *p_data;
+}tBTM_BLE_PF_LOCAL_NAME_COND;
+
+typedef struct
+{
+    UINT16                  company_id;     /* company ID */
+    UINT8                   data_len;       /* <= 20 bytes */
+    UINT8                   *p_pattern;
+    UINT16                  company_id_mask; /* UUID value mask */
+    UINT8                   *p_pattern_mask; /* Manufacturer data matching mask,
+                                                same length as data pattern,
+                                                set to all 0xff, match exact data */
+}tBTM_BLE_PF_MANU_COND;
+
+typedef struct
+{
+    UINT16                  uuid;     /* service ID */
+    UINT8                   data_len;       /* <= 20 bytes */
+    UINT8                   *p_pattern;
+    UINT8                   *p_pattern_mask; /* Service data matching mask, same length as data pattern,
+                                                set to all 0xff, match exact data */
+}tBTM_BLE_PF_SRVC_PATTERN_COND;
+
+
+typedef union
+{
+    tBLE_BD_ADDR                            target_addr;
+    tBTM_BLE_PF_LOCAL_NAME_COND             local_name; /* lcoal name filtering */
+    tBTM_BLE_PF_MANU_COND                   manu_data;  /* manufactuer data filtering */
+    tBTM_BLE_PF_UUID_COND                   srvc_uuid;  /* service UUID filtering */
+    tBTM_BLE_PF_UUID_COND                   solicitate_uuid;   /* solicitated service UUID filtering */
+    tBTM_BLE_PF_SRVC_PATTERN_COND           srvc_data;      /* service data pattern */
+}tBTM_BLE_PF_COND_PARAM;
+
+typedef struct
+{
+    UINT8   action_ocf[BTM_BLE_PF_TYPE_MAX];
+    tBTM_BLE_REF_VALUE  ref_value[BTM_BLE_PF_TYPE_MAX];
+    tBTM_BLE_PF_PARAM_CBACK  *p_filt_param_cback[BTM_BLE_PF_TYPE_MAX];
+    tBTM_BLE_PF_CFG_CBACK *p_scan_cfg_cback[BTM_BLE_PF_TYPE_MAX];
+    UINT8   cb_evt[BTM_BLE_PF_TYPE_MAX];
+    UINT8   pending_idx;
+    UINT8   next_idx;
+}tBTM_BLE_ADV_FILTER_ADV_OPQ;
+
+#define BTM_BLE_MAX_FILTER_COUNTER  (BTM_BLE_MAX_ADDR_FILTER + 1) /* per device filter + one generic filter indexed by 0 */
+
+#ifndef BTM_CS_IRK_LIST_MAX
+#define BTM_CS_IRK_LIST_MAX 0x20
+#endif
+
+typedef struct
+{
+    BOOLEAN    in_use;
+    BD_ADDR    bd_addr;
+    UINT8      pf_counter[BTM_BLE_PF_TYPE_MAX]; /* number of filter indexed by tBTM_BLE_PF_COND_TYPE */
+}tBTM_BLE_PF_COUNT;
+
+typedef struct
+{
+    BOOLEAN             enable;
+    UINT8               op_type;
+    tBTM_BLE_PF_COUNT   *p_addr_filter_count; /* per BDA filter array */
+    tBLE_BD_ADDR        cur_filter_target;
+    tBTM_BLE_PF_STATUS_CBACK *p_filt_stat_cback;
+    tBTM_BLE_ADV_FILTER_ADV_OPQ  op_q;
+}tBTM_BLE_ADV_FILTER_CB;
+
+/* Sub codes */
+#define BTM_BLE_META_PF_ENABLE          0x00
+#define BTM_BLE_META_PF_FEAT_SEL        0x01
+#define BTM_BLE_META_PF_ADDR            0x02
+#define BTM_BLE_META_PF_UUID            0x03
+#define BTM_BLE_META_PF_SOL_UUID        0x04
+#define BTM_BLE_META_PF_LOCAL_NAME      0x05
+#define BTM_BLE_META_PF_MANU_DATA       0x06
+#define BTM_BLE_META_PF_SRVC_DATA       0x07
+#define BTM_BLE_META_PF_ALL             0x08
+
+typedef UINT8 BTM_BLE_ADV_STATE;
+typedef UINT8 BTM_BLE_ADV_INFO_PRESENT;
+typedef UINT8 BTM_BLE_RSSI_VALUE;
+typedef UINT16 BTM_BLE_ADV_INFO_TIMESTAMP;
+
+/* These are the fields returned in each device adv packet.  It
+** is returned in the results callback if registered.
+*/
+typedef struct
+{
+    UINT8               conn_mode;
+    tBTM_BLE_AD_MASK    ad_mask;        /* mask of the valid adv data field */
+    UINT8               flag;
+    UINT8               tx_power_level;
+    UINT8               remote_name_len;
+    UINT8               *p_remote_name;
+    tBTM_BLE_SERVICE    service;
+} tBTM_BLE_INQ_DATA;
+
+enum
+{
+    BTM_BLE_CONN_NONE,
+    BTM_BLE_CONN_AUTO,
+    BTM_BLE_CONN_SELECTIVE
+};
+typedef UINT8   tBTM_BLE_CONN_TYPE;
+
+#define ADV_INFO_PRESENT        0x00
+#define NO_ADV_INFO_PRESENT     0x01
+
+typedef btgatt_track_adv_info_t tBTM_BLE_TRACK_ADV_DATA;
+
+typedef void (tBTM_BLE_TRACK_ADV_CBACK)(tBTM_BLE_TRACK_ADV_DATA *p_track_adv_data);
+
+typedef UINT8 tBTM_BLE_TRACK_ADV_EVT;
+
+typedef struct
+{
+    tBTM_BLE_REF_VALUE             ref_value;
+    tBTM_BLE_TRACK_ADV_CBACK *p_track_cback;
+}tBTM_BLE_ADV_TRACK_CB;
+
+enum
+{
+    BTM_BLE_TRACK_ADV_ADD,
+    BTM_BLE_TRACK_ADV_REMOVE
+};
+
+typedef UINT8 tBTM_BLE_TRACK_ADV_ACTION;
+
+#define BTM_BLE_MULTI_ADV_INVALID   0
+
+#define BTM_BLE_BATCH_SCAN_ENABLE_EVT     1
+#define BTM_BLE_BATCH_SCAN_CFG_STRG_EVT   2
+#define BTM_BLE_BATCH_SCAN_READ_REPTS_EVT 3
+#define BTM_BLE_BATCH_SCAN_THR_EVT        4
+#define BTM_BLE_BATCH_SCAN_PARAM_EVT      5
+#define BTM_BLE_BATCH_SCAN_DISABLE_EVT    6
+
+typedef UINT8 tBTM_BLE_BATCH_SCAN_EVT;
+
+typedef UINT32 tBTM_BLE_TX_TIME_MS;
+typedef UINT32 tBTM_BLE_RX_TIME_MS;
+typedef UINT32 tBTM_BLE_IDLE_TIME_MS;
+typedef UINT32 tBTM_BLE_ENERGY_USED;
+
+typedef void (tBTM_BLE_ENERGY_INFO_CBACK)(tBTM_BLE_TX_TIME_MS tx_time, tBTM_BLE_RX_TIME_MS rx_time,
+                                          tBTM_BLE_IDLE_TIME_MS idle_time,
+                                          tBTM_BLE_ENERGY_USED  energy_used,
+                                          tBTM_STATUS status);
+
+typedef struct
+{
+    tBTM_BLE_ENERGY_INFO_CBACK *p_ener_cback;
+}tBTM_BLE_ENERGY_INFO_CB;
+
+typedef BOOLEAN (tBTM_BLE_SEL_CBACK)(BD_ADDR random_bda,     UINT8 *p_remote_name);
+typedef void (tBTM_BLE_CTRL_FEATURES_CBACK)(tBTM_STATUS status);
+
+/* callback function for SMP signing algorithm, signed data in little endian order with tlen bits long */
+typedef void (tBTM_BLE_SIGN_CBACK)(void *p_ref_data, UINT8 *p_signing_data);
+typedef void (tBTM_BLE_VERIFY_CBACK)(void *p_ref_data, BOOLEAN match);
+/* random address set complete callback */
+typedef void (tBTM_BLE_RANDOM_SET_CBACK) (BD_ADDR random_bda);
+
+typedef void (tBTM_BLE_SCAN_REQ_CBACK)(BD_ADDR remote_bda, tBLE_ADDR_TYPE addr_type, UINT8 adv_evt);
+typedef void (*tBLE_SCAN_PARAM_SETUP_CBACK)(tGATT_IF client_if, tBTM_STATUS status);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // BTM_BLE_API_TYPES_H
diff --git a/stack/include/smp_api.h b/stack/include/smp_api.h
index 964b7f941..e64292077 100644
--- a/stack/include/smp_api.h
+++ b/stack/include/smp_api.h
@@ -25,274 +25,7 @@
 #define SMP_API_H
 
 #include "bt_target.h"
-
-#define SMP_PIN_CODE_LEN_MAX    PIN_CODE_LEN
-#define SMP_PIN_CODE_LEN_MIN    6
-
-#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
-/* SMP command code */
-#define SMP_OPCODE_PAIRING_REQ            0x01
-#define SMP_OPCODE_PAIRING_RSP            0x02
-#define SMP_OPCODE_CONFIRM                0x03
-#define SMP_OPCODE_RAND                   0x04
-#define SMP_OPCODE_PAIRING_FAILED         0x05
-#define SMP_OPCODE_ENCRYPT_INFO           0x06
-#define SMP_OPCODE_MASTER_ID              0x07
-#define SMP_OPCODE_IDENTITY_INFO          0x08
-#define SMP_OPCODE_ID_ADDR                0x09
-#define SMP_OPCODE_SIGN_INFO              0x0A
-#define SMP_OPCODE_SEC_REQ                0x0B
-#define SMP_OPCODE_PAIR_PUBLIC_KEY        0x0C
-#define SMP_OPCODE_PAIR_DHKEY_CHECK       0x0D
-#define SMP_OPCODE_PAIR_KEYPR_NOTIF       0x0E
-#define SMP_OPCODE_MAX                    SMP_OPCODE_PAIR_KEYPR_NOTIF
-#define SMP_OPCODE_MIN                    SMP_OPCODE_PAIRING_REQ
-#define SMP_OPCODE_PAIR_COMMITM           0x0F
-#endif
-
-/* SMP event type */
-#define SMP_IO_CAP_REQ_EVT      1       /* IO capability request event */
-#define SMP_SEC_REQUEST_EVT     2       /* SMP pairing request */
-#define SMP_PASSKEY_NOTIF_EVT   3       /* passkey notification event */
-#define SMP_PASSKEY_REQ_EVT     4       /* passkey request event */
-#define SMP_OOB_REQ_EVT         5       /* OOB request event */
-#define SMP_NC_REQ_EVT          6       /* Numeric Comparison request event */
-#define SMP_COMPLT_EVT          7       /* SMP complete event */
-#define SMP_PEER_KEYPR_NOT_EVT  8       /* Peer keypress notification received event */
-#define SMP_SC_OOB_REQ_EVT      9       /* SC OOB request event (both local and peer OOB data */
-                                        /* can be expected in response) */
-#define SMP_SC_LOC_OOB_DATA_UP_EVT  10  /* SC OOB local data set is created */
-                                        /* (as result of SMP_CrLocScOobData(...)) */
-#define SMP_BR_KEYS_REQ_EVT     12      /* SMP over BR keys request event */
-#define SMP_CONSENT_REQ_EVT     14      /* Consent request event */
-typedef UINT8   tSMP_EVT;
-
-
-/* pairing failure reason code */
-#define SMP_PASSKEY_ENTRY_FAIL      0x01
-#define SMP_OOB_FAIL                0x02
-#define SMP_PAIR_AUTH_FAIL          0x03
-#define SMP_CONFIRM_VALUE_ERR       0x04
-#define SMP_PAIR_NOT_SUPPORT        0x05
-#define SMP_ENC_KEY_SIZE            0x06
-#define SMP_INVALID_CMD             0x07
-#define SMP_PAIR_FAIL_UNKNOWN       0x08
-#define SMP_REPEATED_ATTEMPTS       0x09
-#define SMP_INVALID_PARAMETERS      0x0A
-#define SMP_DHKEY_CHK_FAIL          0x0B
-#define SMP_NUMERIC_COMPAR_FAIL     0x0C
-#define SMP_BR_PARING_IN_PROGR      0x0D
-#define SMP_XTRANS_DERIVE_NOT_ALLOW 0x0E
-#define SMP_MAX_FAIL_RSN_PER_SPEC   SMP_XTRANS_DERIVE_NOT_ALLOW
-
-/* self defined error code */
-#define SMP_PAIR_INTERNAL_ERR       (SMP_MAX_FAIL_RSN_PER_SPEC + 0x01) /* 0x0F */
-
-/* Unknown IO capability, unable to decide association model */
-#define SMP_UNKNOWN_IO_CAP          (SMP_MAX_FAIL_RSN_PER_SPEC + 0x02) /* 0x10 */
-
-#define SMP_INIT_FAIL               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x03) /* 0x11 */
-#define SMP_CONFIRM_FAIL            (SMP_MAX_FAIL_RSN_PER_SPEC + 0x04) /* 0x12 */
-#define SMP_BUSY                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x05) /* 0x13 */
-#define SMP_ENC_FAIL                (SMP_MAX_FAIL_RSN_PER_SPEC + 0x06) /* 0x14 */
-#define SMP_STARTED                 (SMP_MAX_FAIL_RSN_PER_SPEC + 0x07) /* 0x15 */
-#define SMP_RSP_TIMEOUT             (SMP_MAX_FAIL_RSN_PER_SPEC + 0x08) /* 0x16 */
-#define SMP_DIV_NOT_AVAIL           (SMP_MAX_FAIL_RSN_PER_SPEC + 0x09) /* 0x17 */
-
-/* Unspecified failure reason */
-#define SMP_FAIL                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0A) /* 0x18 */
-
-#define SMP_CONN_TOUT               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0B) /* 0x19 */
-#define SMP_SUCCESS                 0
-
-typedef UINT8 tSMP_STATUS;
-
-
-/* Device IO capability */
-#define SMP_IO_CAP_OUT      BTM_IO_CAP_OUT   /* DisplayOnly */
-#define SMP_IO_CAP_IO       BTM_IO_CAP_IO   /* DisplayYesNo */
-#define SMP_IO_CAP_IN       BTM_IO_CAP_IN   /* KeyboardOnly */
-#define SMP_IO_CAP_NONE     BTM_IO_CAP_NONE   /* NoInputNoOutput */
-#define SMP_IO_CAP_KBDISP   BTM_IO_CAP_KBDISP   /* Keyboard Display */
-#define SMP_IO_CAP_MAX      BTM_IO_CAP_MAX
-typedef UINT8  tSMP_IO_CAP;
-
-#ifndef SMP_DEFAULT_IO_CAPS
-    #define SMP_DEFAULT_IO_CAPS     SMP_IO_CAP_KBDISP
-#endif
-
-/* OOB data present or not */
-enum
-{
-    SMP_OOB_NONE,
-    SMP_OOB_PRESENT,
-    SMP_OOB_UNKNOWN
-};
-typedef UINT8  tSMP_OOB_FLAG;
-
-/* type of OOB data required from application */
-enum
-{
-    SMP_OOB_INVALID_TYPE,
-    SMP_OOB_PEER,
-    SMP_OOB_LOCAL,
-    SMP_OOB_BOTH
-};
-typedef UINT8   tSMP_OOB_DATA_TYPE;
-
-#define SMP_AUTH_NO_BOND        0x00
-#define SMP_AUTH_GEN_BOND       0x01 //todo sdh change GEN_BOND to BOND
-
-/* SMP Authentication requirement */
-#define SMP_AUTH_YN_BIT         (1 << 2)
-#define SMP_SC_SUPPORT_BIT      (1 << 3)
-#define SMP_KP_SUPPORT_BIT      (1 << 4)
-
-#define SMP_AUTH_MASK    (SMP_AUTH_GEN_BOND|SMP_AUTH_YN_BIT|SMP_SC_SUPPORT_BIT|SMP_KP_SUPPORT_BIT)
-
-#define SMP_AUTH_BOND           SMP_AUTH_GEN_BOND
-
-/* no MITM, No Bonding, encryption only */
-#define SMP_AUTH_NB_ENC_ONLY    0x00 //(SMP_AUTH_MASK | BTM_AUTH_SP_NO)
-
-/* MITM, No Bonding, Use IO Capability to determine authentication procedure */
-#define SMP_AUTH_NB_IOCAP       (SMP_AUTH_NO_BOND | SMP_AUTH_YN_BIT)
-
-/* No MITM, General Bonding, Encryption only */
-#define SMP_AUTH_GB_ENC_ONLY    (SMP_AUTH_GEN_BOND )
-
-/* MITM, General Bonding, Use IO Capability to determine authentication procedure */
-#define SMP_AUTH_GB_IOCAP       (SMP_AUTH_GEN_BOND | SMP_AUTH_YN_BIT)
-
-/* Secure Connections, no MITM, no Bonding */
-#define SMP_AUTH_SC_ENC_ONLY    (SMP_SC_SUPPORT_BIT)
-
-/* Secure Connections, no MITM, Bonding */
-#define SMP_AUTH_SC_GB          (SMP_SC_SUPPORT_BIT | SMP_AUTH_GEN_BOND)
-
-/* Secure Connections, MITM, no Bonding */
-#define SMP_AUTH_SC_MITM_NB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_NO_BOND)
-
-/* Secure Connections, MITM, Bonding */
-#define SMP_AUTH_SC_MITM_GB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_GEN_BOND)
-
- /* All AuthReq RFU bits are set to 1 - NOTE: reserved bit in Bonding_Flags is not set */
-#define SMP_AUTH_ALL_RFU_SET    0xF8
-
-typedef UINT8 tSMP_AUTH_REQ;
-
-#define SMP_SEC_NONE                 0
-#define SMP_SEC_UNAUTHENTICATE      (1 << 0)
-#define SMP_SEC_AUTHENTICATED       (1 << 2)
-typedef UINT8 tSMP_SEC_LEVEL;
-
-/* Maximum Encryption Key Size range */
-#define SMP_ENCR_KEY_SIZE_MIN       7
-#define SMP_ENCR_KEY_SIZE_MAX       16
-
-/* SMP key types */
-#define SMP_SEC_KEY_TYPE_ENC                (1 << 0)    /* encryption key */
-#define SMP_SEC_KEY_TYPE_ID                 (1 << 1)    /* identity key */
-#define SMP_SEC_KEY_TYPE_CSRK               (1 << 2)    /* slave CSRK */
-#define SMP_SEC_KEY_TYPE_LK                 (1 << 3)    /* BR/EDR link key */
-typedef UINT8 tSMP_KEYS;
-
-#define SMP_BR_SEC_DEFAULT_KEY   (SMP_SEC_KEY_TYPE_ENC | SMP_SEC_KEY_TYPE_ID | \
-                                  SMP_SEC_KEY_TYPE_CSRK)
-
-/* default security key distribution value */
-#define SMP_SEC_DEFAULT_KEY      (SMP_SEC_KEY_TYPE_ENC | SMP_SEC_KEY_TYPE_ID | \
-                                  SMP_SEC_KEY_TYPE_CSRK | SMP_SEC_KEY_TYPE_LK)
-
-#define SMP_SC_KEY_STARTED      0   /* passkey entry started */
-#define SMP_SC_KEY_ENTERED      1   /* passkey digit entered */
-#define SMP_SC_KEY_ERASED       2   /* passkey digit erased */
-#define SMP_SC_KEY_CLEARED      3   /* passkey cleared */
-#define SMP_SC_KEY_COMPLT       4   /* passkey entry completed */
-#define SMP_SC_KEY_OUT_OF_RANGE 5   /* out of range */
-typedef UINT8 tSMP_SC_KEY_TYPE;
-
-/* data type for BTM_SP_IO_REQ_EVT */
-typedef struct
-{
-    tSMP_IO_CAP     io_cap;         /* local IO capabilities */
-    tSMP_OOB_FLAG   oob_data;       /* OOB data present (locally) for the peer device */
-    tSMP_AUTH_REQ   auth_req;       /* Authentication required (for local device) */
-    UINT8           max_key_size;   /* max encryption key size */
-    tSMP_KEYS       init_keys;      /* initiator keys to be distributed */
-    tSMP_KEYS       resp_keys;      /* responder keys */
-} tSMP_IO_REQ;
-
-typedef struct
-{
-    tSMP_STATUS reason;
-    tSMP_SEC_LEVEL sec_level;
-    BOOLEAN is_pair_cancel;
-    BOOLEAN smp_over_br;
-} tSMP_CMPL;
-
-typedef struct
-{
-    BT_OCTET32  x;
-    BT_OCTET32  y;
-} tSMP_PUBLIC_KEY;
-
-/* the data associated with the info sent to the peer via OOB interface */
-typedef struct
-{
-    BOOLEAN         present;
-    BT_OCTET16      randomizer;
-    BT_OCTET16      commitment;
-
-    tBLE_BD_ADDR    addr_sent_to;
-    BT_OCTET32      private_key_used;   /* is used to calculate: */
-                    /* publ_key_used = P-256(private_key_used, curve_p256.G) - send it to the */
-                    /* other side */
-                    /* dhkey = P-256(private_key_used, publ key rcvd from the other side) */
-    tSMP_PUBLIC_KEY publ_key_used; /* P-256(private_key_used, curve_p256.G) */
-} tSMP_LOC_OOB_DATA;
-
-/* the data associated with the info received from the peer via OOB interface */
-typedef struct
-{
-    BOOLEAN         present;
-    BT_OCTET16      randomizer;
-    BT_OCTET16      commitment;
-    tBLE_BD_ADDR    addr_rcvd_from;
-} tSMP_PEER_OOB_DATA;
-
-typedef struct
-{
-    tSMP_LOC_OOB_DATA   loc_oob_data;
-    tSMP_PEER_OOB_DATA  peer_oob_data;
-} tSMP_SC_OOB_DATA;
-
-
-typedef union
-{
-    UINT32          passkey;
-    tSMP_IO_REQ     io_req;     /* IO request */
-    tSMP_CMPL       cmplt;
-    tSMP_OOB_DATA_TYPE  req_oob_type;
-    tSMP_LOC_OOB_DATA   loc_oob_data;
-}tSMP_EVT_DATA;
-
-
-/* AES Encryption output */
-typedef struct
-{
-    UINT8   status;
-    UINT8   param_len;
-    UINT16  opcode;
-    UINT8   param_buf[BT_OCTET16_LEN];
-} tSMP_ENC;
-
-/* Security Manager events - Called by the stack when Security Manager related events occur.*/
-typedef UINT8 (tSMP_CALLBACK) (tSMP_EVT event, BD_ADDR bd_addr, tSMP_EVT_DATA *p_data);
-
-/* callback function for CMAC algorithm
-*/
-typedef void (tCMAC_CMPL_CBACK)(UINT8 *p_mac, UINT16 tlen, UINT32 sign_counter);
+#include "smp_api_types.h"
 
 /*****************************************************************************
 **  External Function Declarations
diff --git a/stack/include/smp_api_types.h b/stack/include/smp_api_types.h
new file mode 100644
index 000000000..3ad28e818
--- /dev/null
+++ b/stack/include/smp_api_types.h
@@ -0,0 +1,300 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef SMP_API_TYPES_H
+#define SMP_API_TYPES_H
+
+#include "bt_target.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SMP_PIN_CODE_LEN_MAX    PIN_CODE_LEN
+#define SMP_PIN_CODE_LEN_MIN    6
+
+#if BLE_INCLUDED == TRUE && SMP_INCLUDED == TRUE
+/* SMP command code */
+#define SMP_OPCODE_PAIRING_REQ            0x01
+#define SMP_OPCODE_PAIRING_RSP            0x02
+#define SMP_OPCODE_CONFIRM                0x03
+#define SMP_OPCODE_RAND                   0x04
+#define SMP_OPCODE_PAIRING_FAILED         0x05
+#define SMP_OPCODE_ENCRYPT_INFO           0x06
+#define SMP_OPCODE_MASTER_ID              0x07
+#define SMP_OPCODE_IDENTITY_INFO          0x08
+#define SMP_OPCODE_ID_ADDR                0x09
+#define SMP_OPCODE_SIGN_INFO              0x0A
+#define SMP_OPCODE_SEC_REQ                0x0B
+#define SMP_OPCODE_PAIR_PUBLIC_KEY        0x0C
+#define SMP_OPCODE_PAIR_DHKEY_CHECK       0x0D
+#define SMP_OPCODE_PAIR_KEYPR_NOTIF       0x0E
+#define SMP_OPCODE_MAX                    SMP_OPCODE_PAIR_KEYPR_NOTIF
+#define SMP_OPCODE_MIN                    SMP_OPCODE_PAIRING_REQ
+#define SMP_OPCODE_PAIR_COMMITM           0x0F
+#endif
+
+/* SMP event type */
+#define SMP_IO_CAP_REQ_EVT      1       /* IO capability request event */
+#define SMP_SEC_REQUEST_EVT     2       /* SMP pairing request */
+#define SMP_PASSKEY_NOTIF_EVT   3       /* passkey notification event */
+#define SMP_PASSKEY_REQ_EVT     4       /* passkey request event */
+#define SMP_OOB_REQ_EVT         5       /* OOB request event */
+#define SMP_NC_REQ_EVT          6       /* Numeric Comparison request event */
+#define SMP_COMPLT_EVT          7       /* SMP complete event */
+#define SMP_PEER_KEYPR_NOT_EVT  8       /* Peer keypress notification received event */
+#define SMP_SC_OOB_REQ_EVT      9       /* SC OOB request event (both local and peer OOB data */
+                                        /* can be expected in response) */
+#define SMP_SC_LOC_OOB_DATA_UP_EVT  10  /* SC OOB local data set is created */
+                                        /* (as result of SMP_CrLocScOobData(...)) */
+#define SMP_BR_KEYS_REQ_EVT     12      /* SMP over BR keys request event */
+#define SMP_CONSENT_REQ_EVT     14      /* Consent request event */
+typedef UINT8   tSMP_EVT;
+
+
+/* pairing failure reason code */
+#define SMP_PASSKEY_ENTRY_FAIL      0x01
+#define SMP_OOB_FAIL                0x02
+#define SMP_PAIR_AUTH_FAIL          0x03
+#define SMP_CONFIRM_VALUE_ERR       0x04
+#define SMP_PAIR_NOT_SUPPORT        0x05
+#define SMP_ENC_KEY_SIZE            0x06
+#define SMP_INVALID_CMD             0x07
+#define SMP_PAIR_FAIL_UNKNOWN       0x08
+#define SMP_REPEATED_ATTEMPTS       0x09
+#define SMP_INVALID_PARAMETERS      0x0A
+#define SMP_DHKEY_CHK_FAIL          0x0B
+#define SMP_NUMERIC_COMPAR_FAIL     0x0C
+#define SMP_BR_PARING_IN_PROGR      0x0D
+#define SMP_XTRANS_DERIVE_NOT_ALLOW 0x0E
+#define SMP_MAX_FAIL_RSN_PER_SPEC   SMP_XTRANS_DERIVE_NOT_ALLOW
+
+/* self defined error code */
+#define SMP_PAIR_INTERNAL_ERR       (SMP_MAX_FAIL_RSN_PER_SPEC + 0x01) /* 0x0F */
+
+/* Unknown IO capability, unable to decide association model */
+#define SMP_UNKNOWN_IO_CAP          (SMP_MAX_FAIL_RSN_PER_SPEC + 0x02) /* 0x10 */
+
+#define SMP_INIT_FAIL               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x03) /* 0x11 */
+#define SMP_CONFIRM_FAIL            (SMP_MAX_FAIL_RSN_PER_SPEC + 0x04) /* 0x12 */
+#define SMP_BUSY                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x05) /* 0x13 */
+#define SMP_ENC_FAIL                (SMP_MAX_FAIL_RSN_PER_SPEC + 0x06) /* 0x14 */
+#define SMP_STARTED                 (SMP_MAX_FAIL_RSN_PER_SPEC + 0x07) /* 0x15 */
+#define SMP_RSP_TIMEOUT             (SMP_MAX_FAIL_RSN_PER_SPEC + 0x08) /* 0x16 */
+#define SMP_DIV_NOT_AVAIL           (SMP_MAX_FAIL_RSN_PER_SPEC + 0x09) /* 0x17 */
+
+/* Unspecified failure reason */
+#define SMP_FAIL                    (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0A) /* 0x18 */
+
+#define SMP_CONN_TOUT               (SMP_MAX_FAIL_RSN_PER_SPEC + 0x0B) /* 0x19 */
+#define SMP_SUCCESS                 0
+
+typedef UINT8 tSMP_STATUS;
+
+
+/* Device IO capability */
+#define SMP_IO_CAP_OUT      BTM_IO_CAP_OUT   /* DisplayOnly */
+#define SMP_IO_CAP_IO       BTM_IO_CAP_IO   /* DisplayYesNo */
+#define SMP_IO_CAP_IN       BTM_IO_CAP_IN   /* KeyboardOnly */
+#define SMP_IO_CAP_NONE     BTM_IO_CAP_NONE   /* NoInputNoOutput */
+#define SMP_IO_CAP_KBDISP   BTM_IO_CAP_KBDISP   /* Keyboard Display */
+#define SMP_IO_CAP_MAX      BTM_IO_CAP_MAX
+typedef UINT8  tSMP_IO_CAP;
+
+#ifndef SMP_DEFAULT_IO_CAPS
+    #define SMP_DEFAULT_IO_CAPS     SMP_IO_CAP_KBDISP
+#endif
+
+/* OOB data present or not */
+enum
+{
+    SMP_OOB_NONE,
+    SMP_OOB_PRESENT,
+    SMP_OOB_UNKNOWN
+};
+typedef UINT8  tSMP_OOB_FLAG;
+
+/* type of OOB data required from application */
+enum
+{
+    SMP_OOB_INVALID_TYPE,
+    SMP_OOB_PEER,
+    SMP_OOB_LOCAL,
+    SMP_OOB_BOTH
+};
+typedef UINT8   tSMP_OOB_DATA_TYPE;
+
+#define SMP_AUTH_NO_BOND        0x00
+#define SMP_AUTH_GEN_BOND       0x01 //todo sdh change GEN_BOND to BOND
+
+/* SMP Authentication requirement */
+#define SMP_AUTH_YN_BIT         (1 << 2)
+#define SMP_SC_SUPPORT_BIT      (1 << 3)
+#define SMP_KP_SUPPORT_BIT      (1 << 4)
+
+#define SMP_AUTH_MASK    (SMP_AUTH_GEN_BOND|SMP_AUTH_YN_BIT|SMP_SC_SUPPORT_BIT|SMP_KP_SUPPORT_BIT)
+
+#define SMP_AUTH_BOND           SMP_AUTH_GEN_BOND
+
+/* no MITM, No Bonding, encryption only */
+#define SMP_AUTH_NB_ENC_ONLY    0x00 //(SMP_AUTH_MASK | BTM_AUTH_SP_NO)
+
+/* MITM, No Bonding, Use IO Capability to determine authentication procedure */
+#define SMP_AUTH_NB_IOCAP       (SMP_AUTH_NO_BOND | SMP_AUTH_YN_BIT)
+
+/* No MITM, General Bonding, Encryption only */
+#define SMP_AUTH_GB_ENC_ONLY    (SMP_AUTH_GEN_BOND )
+
+/* MITM, General Bonding, Use IO Capability to determine authentication procedure */
+#define SMP_AUTH_GB_IOCAP       (SMP_AUTH_GEN_BOND | SMP_AUTH_YN_BIT)
+
+/* Secure Connections, no MITM, no Bonding */
+#define SMP_AUTH_SC_ENC_ONLY    (SMP_SC_SUPPORT_BIT)
+
+/* Secure Connections, no MITM, Bonding */
+#define SMP_AUTH_SC_GB          (SMP_SC_SUPPORT_BIT | SMP_AUTH_GEN_BOND)
+
+/* Secure Connections, MITM, no Bonding */
+#define SMP_AUTH_SC_MITM_NB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_NO_BOND)
+
+/* Secure Connections, MITM, Bonding */
+#define SMP_AUTH_SC_MITM_GB     (SMP_SC_SUPPORT_BIT | SMP_AUTH_YN_BIT | SMP_AUTH_GEN_BOND)
+
+ /* All AuthReq RFU bits are set to 1 - NOTE: reserved bit in Bonding_Flags is not set */
+#define SMP_AUTH_ALL_RFU_SET    0xF8
+
+typedef UINT8 tSMP_AUTH_REQ;
+
+#define SMP_SEC_NONE                 0
+#define SMP_SEC_UNAUTHENTICATE      (1 << 0)
+#define SMP_SEC_AUTHENTICATED       (1 << 2)
+typedef UINT8 tSMP_SEC_LEVEL;
+
+/* Maximum Encryption Key Size range */
+#define SMP_ENCR_KEY_SIZE_MIN       7
+#define SMP_ENCR_KEY_SIZE_MAX       16
+
+/* SMP key types */
+#define SMP_SEC_KEY_TYPE_ENC                (1 << 0)    /* encryption key */
+#define SMP_SEC_KEY_TYPE_ID                 (1 << 1)    /* identity key */
+#define SMP_SEC_KEY_TYPE_CSRK               (1 << 2)    /* slave CSRK */
+#define SMP_SEC_KEY_TYPE_LK                 (1 << 3)    /* BR/EDR link key */
+typedef UINT8 tSMP_KEYS;
+
+#define SMP_BR_SEC_DEFAULT_KEY   (SMP_SEC_KEY_TYPE_ENC | SMP_SEC_KEY_TYPE_ID | \
+                                  SMP_SEC_KEY_TYPE_CSRK)
+
+/* default security key distribution value */
+#define SMP_SEC_DEFAULT_KEY      (SMP_SEC_KEY_TYPE_ENC | SMP_SEC_KEY_TYPE_ID | \
+                                  SMP_SEC_KEY_TYPE_CSRK | SMP_SEC_KEY_TYPE_LK)
+
+#define SMP_SC_KEY_STARTED      0   /* passkey entry started */
+#define SMP_SC_KEY_ENTERED      1   /* passkey digit entered */
+#define SMP_SC_KEY_ERASED       2   /* passkey digit erased */
+#define SMP_SC_KEY_CLEARED      3   /* passkey cleared */
+#define SMP_SC_KEY_COMPLT       4   /* passkey entry completed */
+#define SMP_SC_KEY_OUT_OF_RANGE 5   /* out of range */
+typedef UINT8 tSMP_SC_KEY_TYPE;
+
+/* data type for BTM_SP_IO_REQ_EVT */
+typedef struct
+{
+    tSMP_IO_CAP     io_cap;         /* local IO capabilities */
+    tSMP_OOB_FLAG   oob_data;       /* OOB data present (locally) for the peer device */
+    tSMP_AUTH_REQ   auth_req;       /* Authentication required (for local device) */
+    UINT8           max_key_size;   /* max encryption key size */
+    tSMP_KEYS       init_keys;      /* initiator keys to be distributed */
+    tSMP_KEYS       resp_keys;      /* responder keys */
+} tSMP_IO_REQ;
+
+typedef struct
+{
+    tSMP_STATUS reason;
+    tSMP_SEC_LEVEL sec_level;
+    BOOLEAN is_pair_cancel;
+    BOOLEAN smp_over_br;
+} tSMP_CMPL;
+
+typedef struct
+{
+    BT_OCTET32  x;
+    BT_OCTET32  y;
+} tSMP_PUBLIC_KEY;
+
+/* the data associated with the info sent to the peer via OOB interface */
+typedef struct
+{
+    BOOLEAN         present;
+    BT_OCTET16      randomizer;
+    BT_OCTET16      commitment;
+
+    tBLE_BD_ADDR    addr_sent_to;
+    BT_OCTET32      private_key_used;   /* is used to calculate: */
+                    /* publ_key_used = P-256(private_key_used, curve_p256.G) - send it to the */
+                    /* other side */
+                    /* dhkey = P-256(private_key_used, publ key rcvd from the other side) */
+    tSMP_PUBLIC_KEY publ_key_used; /* P-256(private_key_used, curve_p256.G) */
+} tSMP_LOC_OOB_DATA;
+
+/* the data associated with the info received from the peer via OOB interface */
+typedef struct
+{
+    BOOLEAN         present;
+    BT_OCTET16      randomizer;
+    BT_OCTET16      commitment;
+    tBLE_BD_ADDR    addr_rcvd_from;
+} tSMP_PEER_OOB_DATA;
+
+typedef struct
+{
+    tSMP_LOC_OOB_DATA   loc_oob_data;
+    tSMP_PEER_OOB_DATA  peer_oob_data;
+} tSMP_SC_OOB_DATA;
+
+
+typedef union
+{
+    UINT32          passkey;
+    tSMP_IO_REQ     io_req;     /* IO request */
+    tSMP_CMPL       cmplt;
+    tSMP_OOB_DATA_TYPE  req_oob_type;
+    tSMP_LOC_OOB_DATA   loc_oob_data;
+}tSMP_EVT_DATA;
+
+
+/* AES Encryption output */
+typedef struct
+{
+    UINT8   status;
+    UINT8   param_len;
+    UINT16  opcode;
+    UINT8   param_buf[BT_OCTET16_LEN];
+} tSMP_ENC;
+
+/* Security Manager events - Called by the stack when Security Manager related events occur.*/
+typedef UINT8 (tSMP_CALLBACK) (tSMP_EVT event, BD_ADDR bd_addr, tSMP_EVT_DATA *p_data);
+
+/* callback function for CMAC algorithm
+*/
+typedef void (tCMAC_CMPL_CBACK)(UINT8 *p_mac, UINT16 tlen, UINT32 sign_counter);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SMP_API_TYPES_H
