From 3eb52334e6f40eaef42e4669305b56f9a3de2614 Mon Sep 17 00:00:00 2001
From: flar2 <asegaert@gmail.com>
Date: Thu, 21 Nov 2013 23:19:46 -0500
Subject: [PATCH] Overclocking

Signed-off-by: flar2 <asegaert@gmail.com>
---
 arch/arm/mach-msm/acpuclock-8064.c                 | 145 ++++++++++++++++++-
 arch/arm/mach-msm/acpuclock-krait.c                | 154 ++++++++++++++++++++-
 arch/arm/mach-msm/asustek/flo/board-flo-gpu.c      |  37 +++--
 .../arm/mach-msm/asustek/flo/board-flo-regulator.c |   8 +-
 arch/arm/mach-msm/clock-8960.c                     |  31 ++++-
 arch/arm/mach-msm/clock-pll.c                      |  36 +++++
 arch/arm/mach-msm/include/mach/kgsl.h              |   2 +
 arch/arm/mach-msm/msm_dcvs.c                       |   2 +-
 drivers/gpu/msm/kgsl_pwrctrl.c                     |  64 ++++++++-
 drivers/gpu/msm/kgsl_pwrscale_trustzone.c          |   2 +-
 10 files changed, 444 insertions(+), 37 deletions(-)

diff --git a/arch/arm/mach-msm/acpuclock-8064.c b/arch/arm/mach-msm/acpuclock-8064.c
index 0fe1793d5df4..3840d9ecf7c7 100644
--- a/arch/arm/mach-msm/acpuclock-8064.c
+++ b/arch/arm/mach-msm/acpuclock-8064.c
@@ -22,6 +22,8 @@
 #include "acpuclock.h"
 #include "acpuclock-krait.h"
 
+int opt_bin = 1; 
+
 static struct hfpll_data hfpll_data __initdata = {
 	.mode_offset = 0x00,
 	.l_offset = 0x08,
@@ -47,7 +49,7 @@ static struct scalable scalable[] __initdata = {
 		.aux_clk_sel = 3,
 		.sec_clk_sel = 2,
 		.l2cpmr_iaddr = 0x4501,
-		.vreg[VREG_CORE] = { "krait0", 1300000 },
+		.vreg[VREG_CORE] = { "krait0", 1350000 },
 		.vreg[VREG_MEM]  = { "krait0_mem", 1150000 },
 		.vreg[VREG_DIG]  = { "krait0_dig", 1150000 },
 		.vreg[VREG_HFPLL_A] = { "krait0_hfpll", 1800000 },
@@ -58,7 +60,7 @@ static struct scalable scalable[] __initdata = {
 		.aux_clk_sel = 3,
 		.sec_clk_sel = 2,
 		.l2cpmr_iaddr = 0x5501,
-		.vreg[VREG_CORE] = { "krait1", 1300000 },
+		.vreg[VREG_CORE] = { "krait1", 1350000 },
 		.vreg[VREG_MEM]  = { "krait1_mem", 1150000 },
 		.vreg[VREG_DIG]  = { "krait1_dig", 1150000 },
 		.vreg[VREG_HFPLL_A] = { "krait1_hfpll", 1800000 },
@@ -69,7 +71,7 @@ static struct scalable scalable[] __initdata = {
 		.aux_clk_sel = 3,
 		.sec_clk_sel = 2,
 		.l2cpmr_iaddr = 0x6501,
-		.vreg[VREG_CORE] = { "krait2", 1300000 },
+		.vreg[VREG_CORE] = { "krait2", 1350000 },
 		.vreg[VREG_MEM]  = { "krait2_mem", 1150000 },
 		.vreg[VREG_DIG]  = { "krait2_dig", 1150000 },
 		.vreg[VREG_HFPLL_A] = { "krait2_hfpll", 1800000 },
@@ -80,7 +82,7 @@ static struct scalable scalable[] __initdata = {
 		.aux_clk_sel = 3,
 		.sec_clk_sel = 2,
 		.l2cpmr_iaddr = 0x7501,
-		.vreg[VREG_CORE] = { "krait3", 1300000 },
+		.vreg[VREG_CORE] = { "krait3", 1350000 },
 		.vreg[VREG_MEM]  = { "krait3_mem", 1150000 },
 		.vreg[VREG_DIG]  = { "krait3_dig", 1150000 },
 		.vreg[VREG_HFPLL_A] = { "krait3_hfpll", 1800000 },
@@ -106,6 +108,7 @@ static struct msm_bus_paths bw_level_tbl[] __initdata = {
 	[3] = BW_MBPS(2128), /* At least 266 MHz on bus. */
 	[4] = BW_MBPS(3200), /* At least 400 MHz on bus. */
 	[5] = BW_MBPS(4264), /* At least 533 MHz on bus. */
+	[6] = BW_MBPS(4800), /* At least 600 MHz on bus. */
 };
 
 static struct msm_bus_scale_pdata bus_scale_data __initdata = {
@@ -134,6 +137,44 @@ static struct l2_level l2_freq_tbl[] __initdata = {
 	{ }
 };
 
+static struct l2_level l2_freq_tbl_elementalx[] __initdata = {
+	[0]  = { {  384000, PLL_8, 0, 0x00 },  950000, 1050000, 1 },
+	[1]  = { {  432000, HFPLL, 2, 0x20 }, 1050000, 1050000, 2 },
+	[2]  = { {  486000, HFPLL, 2, 0x24 }, 1050000, 1050000, 2 },
+	[3]  = { {  540000, HFPLL, 2, 0x28 }, 1050000, 1050000, 2 },
+	[4]  = { {  594000, HFPLL, 1, 0x16 }, 1050000, 1050000, 2 },
+	[5]  = { {  648000, HFPLL, 1, 0x18 }, 1050000, 1050000, 4 },
+	[6]  = { {  702000, HFPLL, 1, 0x1A }, 1150000, 1150000, 4 },
+	[7]  = { {  756000, HFPLL, 1, 0x1C }, 1150000, 1150000, 4 },
+	[8]  = { {  810000, HFPLL, 1, 0x1E }, 1150000, 1150000, 4 },
+	[9]  = { {  864000, HFPLL, 1, 0x20 }, 1150000, 1150000, 4 },
+	[10] = { {  918000, HFPLL, 1, 0x22 }, 1150000, 1150000, 5 },
+	[11] = { {  972000, HFPLL, 1, 0x24 }, 1150000, 1150000, 5 },
+	[12] = { { 1026000, HFPLL, 1, 0x26 }, 1150000, 1150000, 5 },
+	[13] = { { 1080000, HFPLL, 1, 0x28 }, 1150000, 1150000, 5 },
+	[14] = { { 1188000, HFPLL, 1, 0x2C }, 1150000, 1150000, 5 },
+	{ }
+};
+
+static struct l2_level l2_freq_tbl_ultra[] __initdata = {
+	[0]  = { {  384000, PLL_8, 0, 0x00 },  950000, 1050000, 1 },
+	[1]  = { {  432000, HFPLL, 2, 0x20 }, 1050000, 1050000, 2 },
+	[2]  = { {  486000, HFPLL, 2, 0x24 }, 1050000, 1050000, 2 },
+	[3]  = { {  540000, HFPLL, 2, 0x28 }, 1050000, 1050000, 2 },
+	[4]  = { {  594000, HFPLL, 1, 0x16 }, 1050000, 1050000, 2 },
+	[5]  = { {  648000, HFPLL, 1, 0x18 }, 1050000, 1050000, 4 },
+	[6]  = { {  702000, HFPLL, 1, 0x1A }, 1150000, 1150000, 4 },
+	[7]  = { {  756000, HFPLL, 1, 0x1C }, 1150000, 1150000, 4 },
+	[8]  = { {  810000, HFPLL, 1, 0x1E }, 1150000, 1150000, 4 },
+	[9]  = { {  864000, HFPLL, 1, 0x20 }, 1150000, 1150000, 4 },
+	[10] = { {  918000, HFPLL, 1, 0x22 }, 1150000, 1150000, 6 },
+	[11] = { {  972000, HFPLL, 1, 0x24 }, 1150000, 1150000, 6 },
+	[12] = { { 1026000, HFPLL, 1, 0x26 }, 1150000, 1150000, 6 },
+	[13] = { { 1080000, HFPLL, 1, 0x28 }, 1150000, 1150000, 6 },
+	[14] = { { 1215000, HFPLL, 1, 0x2D }, 1150000, 1150000, 6 },
+	{ }
+};
+
 static struct acpu_level tbl_slow[] __initdata = {
 	{ 1, {   384000, PLL_8, 0, 0x00 }, L2(0),   950000 },
 	{ 0, {   432000, HFPLL, 2, 0x20 }, L2(5),   975000 },
@@ -251,6 +292,16 @@ static struct acpu_level tbl_PVS0_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1125000 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1150000 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1162500 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1187500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1212500 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1237500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1250000 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1275000 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1300000 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1312500 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1325000 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1325000 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1325000 },
 	{ 0, { 0 } }
 };
 
@@ -267,6 +318,16 @@ static struct acpu_level tbl_PVS1_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1087500 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1112500 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1125000 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1150000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1175000 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1200000 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1212500 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1225000 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1250000 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1275000 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1300000 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1325000 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1325000 },
 	{ 0, { 0 } }
 };
 
@@ -283,6 +344,16 @@ static struct acpu_level tbl_PVS2_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1037500 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1075000 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1087500 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1112500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1137500 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1162500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1175000 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1187500 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1212500 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1237500 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1262500 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1287500 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1312500 },
 	{ 0, { 0 } }
 };
 
@@ -299,6 +370,16 @@ static struct acpu_level tbl_PVS3_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14), 1000000 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1037500 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1050000 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1075000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1100000 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1125000 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1137500 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1150000 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1175000 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1200000 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1225000 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1250000 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1275000 },
 	{ 0, { 0 } }
 };
 
@@ -315,6 +396,16 @@ static struct acpu_level tbl_PVS4_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  975000 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14), 1000000 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1012500 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1037500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1062500 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1087500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1100000 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1112500 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1137500 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1175000 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1200000 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1225000 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1250000 },
 	{ 0, { 0 } }
 };
 
@@ -331,6 +422,16 @@ static struct acpu_level tbl_PVS5_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  987500 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14), 1000000 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1025000 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1050000 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1075000 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1087500 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1100000 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1137500 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1162500 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1187500 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1212500 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1237500 },
 	{ 0, { 0 } }
 };
 
@@ -347,6 +448,16 @@ static struct acpu_level tbl_PVS6_1512MHz[] __initdata = {
 	{ 1, {  1350000, HFPLL, 1, 0x32 }, L2(14),  962500 },
 	{ 1, {  1458000, HFPLL, 1, 0x36 }, L2(14),  975000 },
 	{ 1, {  1512000, HFPLL, 1, 0x38 }, L2(14),  987500 },
+	{ 1, {  1620000, HFPLL, 1, 0x3C }, L2(14), 1012500 },
+	{ 1, {  1728000, HFPLL, 1, 0x40 }, L2(14), 1037500 },
+	{ 1, {  1836000, HFPLL, 1, 0x44 }, L2(14), 1062500 },
+	{ 1, {  1890000, HFPLL, 1, 0x46 }, L2(14), 1075000 },
+	{ 1, {  1944000, HFPLL, 1, 0x48 }, L2(14), 1087500 },
+	{ 1, {  1998000, HFPLL, 1, 0x4A }, L2(14), 1125000 },
+	{ 1, {  2052000, HFPLL, 1, 0x4C }, L2(14), 1150000 },
+	{ 1, {  2106000, HFPLL, 1, 0x4E }, L2(14), 1175000 },
+	{ 1, {  2160000, HFPLL, 1, 0x4F }, L2(14), 1200000 },
+	{ 1, {  2214000, HFPLL, 1, 0x50 }, L2(14), 1225000 },
 	{ 0, { 0 } }
 };
 
@@ -652,6 +763,22 @@ static struct acpuclk_krait_params acpuclk_8064_params __initdata = {
 	.stby_khz = 384000,
 };
 
+static int __init get_opt_level(char *l2_opt)
+{
+	if (strcmp(l2_opt, "0") == 0) {
+		opt_bin = 0;
+	} else if (strcmp(l2_opt, "1") == 0) {
+		opt_bin = 1;
+	} else if (strcmp(l2_opt, "2") == 0) {
+		opt_bin = 2;
+	} else {
+		opt_bin = 0;
+	}
+	return 0;
+}
+
+__setup("l2_opt=", get_opt_level); 
+
 static int __init acpuclk_8064_probe(struct platform_device *pdev)
 {
 	if (cpu_is_apq8064ab() ||
@@ -660,6 +787,16 @@ static int __init acpuclk_8064_probe(struct platform_device *pdev)
 		acpuclk_8064_params.hfpll_data->nom_vdd_l_max = 74;
 	}
 
+	if (opt_bin == 1) {
+		acpuclk_8064_params.l2_freq_tbl = l2_freq_tbl_elementalx;
+		acpuclk_8064_params.l2_freq_tbl_size = sizeof(l2_freq_tbl_elementalx);
+	}
+
+	if (opt_bin == 2) {
+		acpuclk_8064_params.l2_freq_tbl = l2_freq_tbl_ultra;
+		acpuclk_8064_params.l2_freq_tbl_size = sizeof(l2_freq_tbl_ultra);
+	}
+
 	return acpuclk_krait_init(&pdev->dev, &acpuclk_8064_params);
 }
 
diff --git a/arch/arm/mach-msm/acpuclock-krait.c b/arch/arm/mach-msm/acpuclock-krait.c
index 75a995b0e841..fcc3f64fe0aa 100644
--- a/arch/arm/mach-msm/acpuclock-krait.c
+++ b/arch/arm/mach-msm/acpuclock-krait.c
@@ -46,6 +46,114 @@
 
 #define SECCLKAGD		BIT(4)
 
+
+/** elementalx defs  **/
+
+int uv_bin = 0;
+uint32_t arg_max_oc0 = 1512000;
+uint32_t arg_max_oc1 = 1512000;
+uint32_t arg_max_oc2 = 1512000;
+uint32_t arg_max_oc3 = 1512000;
+
+int pvs_number = 0;
+module_param(pvs_number, int, 0755); 
+
+/* boot arg max_oc */
+static int __init cpufreq_read_arg_max_oc0(char *max_oc0)
+{
+	unsigned long ui_khz;
+	int err;
+	err = strict_strtoul(max_oc0, 0, &ui_khz);
+	if (err) {
+		arg_max_oc0 = 1512000;
+		printk(KERN_INFO "[elementalx]: max_oc0='%i'\n", arg_max_oc0);
+		return 1;
+	}
+	
+	arg_max_oc0 = ui_khz;
+	
+	return 0;
+}
+__setup("max_oc0=", cpufreq_read_arg_max_oc0);
+
+static int __init cpufreq_read_arg_max_oc1(char *max_oc1)
+{
+	unsigned long ui_khz;
+	int err;
+	err = strict_strtoul(max_oc1, 0, &ui_khz);
+	if (err) {
+		arg_max_oc1 = 1512000;
+		printk(KERN_INFO "[elementalx]: max_oc1='%i'\n", arg_max_oc1);
+		return 1;
+	}
+	
+	arg_max_oc1 = ui_khz;
+	
+	return 0;
+}
+__setup("max_oc1=", cpufreq_read_arg_max_oc1);
+
+static int __init cpufreq_read_arg_max_oc2(char *max_oc2)
+{
+	unsigned long ui_khz;
+	int err;
+	err = strict_strtoul(max_oc2, 0, &ui_khz);
+	if (err) {
+		arg_max_oc2 = 1512000;
+		printk(KERN_INFO "[elementalx]: max_oc2='%i'\n", arg_max_oc2);
+		return 1;
+	}
+	
+	arg_max_oc2 = ui_khz;
+	
+	return 0;
+}
+__setup("max_oc2=", cpufreq_read_arg_max_oc2);
+
+static int __init cpufreq_read_arg_max_oc3(char *max_oc3)
+{
+	unsigned long ui_khz;
+	int err;
+	err = strict_strtoul(max_oc3, 0, &ui_khz);
+	if (err) {
+		arg_max_oc3 = 1512000;
+		printk(KERN_INFO "[elementalx]: max_oc3='%i'\n", arg_max_oc3);
+		return 1;
+	}
+	
+	arg_max_oc3 = ui_khz;
+	
+	return 0;
+}
+__setup("max_oc3=", cpufreq_read_arg_max_oc3);
+
+static int __init get_uv_level(char *vdd_uv)
+{
+	if (strcmp(vdd_uv, "0") == 0) {
+		uv_bin = 0;
+	} else if (strcmp(vdd_uv, "1") == 0) {
+		uv_bin = 1;
+	} else if (strcmp(vdd_uv, "2") == 0) {
+		uv_bin = 2;
+	} else if (strcmp(vdd_uv, "3") == 0) {
+		uv_bin = 3;
+	} else if (strcmp(vdd_uv, "4") == 0) {
+		uv_bin = 4;
+	} else if (strcmp(vdd_uv, "5") == 0) {
+		uv_bin = 5;
+	} else if (strcmp(vdd_uv, "6") == 0) {
+		uv_bin = 6;
+	} else {
+		uv_bin = 0;
+	}
+	return 0;
+}
+
+__setup("vdd_uv=", get_uv_level); 
+
+/** end elementalx defs  **/
+
+
 static DEFINE_MUTEX(driver_lock);
 static DEFINE_SPINLOCK(l2_lock);
 
@@ -928,7 +1036,7 @@ static void __init bus_init(const struct l2_level *l2_level)
 #ifdef CONFIG_CPU_VOLTAGE_TABLE
 
 #define HFPLL_MIN_VDD		 700000
-#define HFPLL_MAX_VDD		1300000
+#define HFPLL_MAX_VDD		1350000
 
 ssize_t acpuclk_get_vdd_levels_str(char *buf) {
 
@@ -966,24 +1074,24 @@ void acpuclk_set_vdd(unsigned int khz, int vdd_uv) {
 
 		drv.acpu_freq_tbl[i].vdd_core = new_vdd_uv;
 	}
-	pr_warn("user voltage table modified!\n");
 	mutex_unlock(&driver_lock);
 }
 #endif	/* CONFIG_CPU_VOTALGE_TABLE */
 
 #ifdef CONFIG_CPU_FREQ_MSM
-static struct cpufreq_frequency_table freq_table[NR_CPUS][35];
+static struct cpufreq_frequency_table freq_table[NR_CPUS][46];
 
 static void __init cpufreq_table_init(void)
 {
 	int cpu;
+	uint32_t limit_max_oc[4] = {arg_max_oc0, arg_max_oc1, arg_max_oc2, arg_max_oc3}; 
 
 	for_each_possible_cpu(cpu) {
 		int i, freq_cnt = 0;
 		/* Construct the freq_table tables from acpu_freq_tbl. */
 		for (i = 0; drv.acpu_freq_tbl[i].speed.khz != 0
 				&& freq_cnt < ARRAY_SIZE(*freq_table); i++) {
-			if (drv.acpu_freq_tbl[i].use_for_scaling) {
+			if (drv.acpu_freq_tbl[i].speed.khz <= limit_max_oc[cpu]) { 
 				freq_table[cpu][freq_cnt].index = freq_cnt;
 				freq_table[cpu][freq_cnt].frequency
 					= drv.acpu_freq_tbl[i].speed.khz;
@@ -1081,6 +1189,39 @@ static void krait_apply_vmin(struct acpu_level *tbl)
 	}
 }
 
+static void apply_undervolting(void)
+{
+	if (uv_bin == 6) {
+		drv.acpu_freq_tbl[0].vdd_core = 725000;
+	        printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+
+	if (uv_bin == 5) {
+		drv.acpu_freq_tbl[0].vdd_core = 750000;
+	        printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+
+	if (uv_bin == 4) {
+		drv.acpu_freq_tbl[0].vdd_core = 775000;
+	        printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+
+	if (uv_bin == 3) {
+		drv.acpu_freq_tbl[0].vdd_core = 800000;
+	        printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+
+	if (uv_bin == 2) {
+		drv.acpu_freq_tbl[0].vdd_core = 825000;
+	        printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+
+	if (uv_bin == 1) {
+		drv.acpu_freq_tbl[0].vdd_core = 850000;
+		printk(KERN_INFO "[elementalx]: min_voltage='%i'\n", drv.acpu_freq_tbl[0].vdd_core );
+	}
+}
+
 static int __init get_speed_bin(u32 pte_efuse)
 {
 	uint32_t speed_bin;
@@ -1113,6 +1254,8 @@ static int __init get_pvs_bin(u32 pte_efuse)
 	} else {
 		dev_info(drv.dev, "ACPU PVS: %d\n", pvs_bin);
 	}
+	
+	pvs_number = pvs_bin;
 
 	return pvs_bin;
 }
@@ -1185,6 +1328,9 @@ static void __init hw_init(void)
 	if (krait_needs_vmin())
 		krait_apply_vmin(drv.acpu_freq_tbl);
 
+	if (uv_bin)
+		apply_undervolting(); 
+
 	l2->hfpll_base = ioremap(l2->hfpll_phys_base, SZ_32);
 	BUG_ON(!l2->hfpll_base);
 
diff --git a/arch/arm/mach-msm/asustek/flo/board-flo-gpu.c b/arch/arm/mach-msm/asustek/flo/board-flo-gpu.c
index 8d86c5402a37..91cbbdcb7ce5 100644
--- a/arch/arm/mach-msm/asustek/flo/board-flo-gpu.c
+++ b/arch/arm/mach-msm/asustek/flo/board-flo-gpu.c
@@ -22,6 +22,8 @@
 #include "devices.h"
 #include "board-flo.h"
 
+uint32_t max_gpu = 1;
+
 #ifdef CONFIG_MSM_DCVS
 static struct msm_dcvs_freq_entry grp3d_freq[] = {
 	{0, 900, 0, 0, 0},
@@ -93,13 +95,13 @@ static struct msm_bus_vectors grp3d_low_vectors[] = {
 		.src = MSM_BUS_MASTER_GRAPHICS_3D,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(1000),
+		.ib = KGSL_CONVERT_TO_MBPS(1200),
 	},
 	{
 		.src = MSM_BUS_MASTER_GRAPHICS_3D_PORT1,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(1000),
+		.ib = KGSL_CONVERT_TO_MBPS(1200),
 	},
 };
 
@@ -138,13 +140,13 @@ static struct msm_bus_vectors grp3d_max_vectors[] = {
 		.src = MSM_BUS_MASTER_GRAPHICS_3D,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(4264),
+		.ib = KGSL_CONVERT_TO_MBPS(4800),
 	},
 	{
 		.src = MSM_BUS_MASTER_GRAPHICS_3D_PORT1,
 		.dst = MSM_BUS_SLAVE_EBI_CH0,
 		.ab = 0,
-		.ib = KGSL_CONVERT_TO_MBPS(4264),
+		.ib = KGSL_CONVERT_TO_MBPS(4800),
 	},
 };
 
@@ -227,7 +229,7 @@ static struct kgsl_device_iommu_data kgsl_3d0_iommu_data[] = {
 static struct kgsl_device_platform_data kgsl_3d0_pdata = {
 	.pwrlevel = {
 		{
-			.gpu_freq = 400000000,
+			.gpu_freq = 450000000,
 			.bus_freq = 4,
 			.io_fraction = 0,
 		},
@@ -241,18 +243,13 @@ static struct kgsl_device_platform_data kgsl_3d0_pdata = {
 			.bus_freq = 2,
 			.io_fraction = 100,
 		},
-		{
-			.gpu_freq = 128000000,
-			.bus_freq = 1,
-			.io_fraction = 100,
-		},
 		{
 			.gpu_freq = 27000000,
 			.bus_freq = 0,
 		},
 	},
 	.init_level = 1,
-	.num_levels = 5,
+	.num_levels = 4,
 	.set_grp_async = NULL,
 	.idle_timeout = HZ/10,
 	.strtstp_sleepwake = true,
@@ -277,12 +274,28 @@ struct platform_device device_kgsl_3d0 = {
 	},
 };
 
+/*gpuoc*/
+static int __init read_max_gpu(char *gpu_oc)
+{
+	if (strcmp(gpu_oc, "1") == 0) {
+		max_gpu = 1;
+	} else {
+		max_gpu = 0;
+	}	
+	return 0;
+}
+
+__setup("gpu_oc=", read_max_gpu);
+/*end gpuoc*/
+
 void __init apq8064_init_gpu(void)
 {
 	unsigned int version = socinfo_get_version();
+	if (max_gpu == 0)
+		kgsl_3d0_pdata.pwrlevel[0].gpu_freq = 400000000;
 
 	if (cpu_is_apq8064ab())
-		kgsl_3d0_pdata.pwrlevel[0].gpu_freq = 450000000;
+		kgsl_3d0_pdata.pwrlevel[0].gpu_freq = 400000000;
 	if (SOCINFO_VERSION_MAJOR(version) == 2) {
 		kgsl_3d0_pdata.chipid = ADRENO_CHIPID(3, 2, 0, 2);
 	} else {
diff --git a/arch/arm/mach-msm/asustek/flo/board-flo-regulator.c b/arch/arm/mach-msm/asustek/flo/board-flo-regulator.c
index 340ead0eff99..add0669717fe 100644
--- a/arch/arm/mach-msm/asustek/flo/board-flo-regulator.c
+++ b/arch/arm/mach-msm/asustek/flo/board-flo-regulator.c
@@ -567,15 +567,15 @@ mpq8064_gpio_regulator_pdata[] __devinitdata = {
 /* SAW regulator constraints */
 struct regulator_init_data msm8064_saw_regulator_pdata_8921_s5 =
 	/*	      ID  vreg_name	       min_uV   max_uV */
-	SAW_VREG_INIT(S5, "8921_s5",	       700000, 1300000);
+	SAW_VREG_INIT(S5, "8921_s5",	       700000, 1350000);
 struct regulator_init_data msm8064_saw_regulator_pdata_8921_s6 =
-	SAW_VREG_INIT(S6, "8921_s6",	       700000, 1300000);
+	SAW_VREG_INIT(S6, "8921_s6",	       700000, 1350000);
 
 struct regulator_init_data msm8064_saw_regulator_pdata_8821_s0 =
 	/*	      ID       vreg_name	min_uV  max_uV */
-	SAW_VREG_INIT(8821_S0, "8821_s0",       700000, 1300000);
+	SAW_VREG_INIT(8821_S0, "8821_s0",       700000, 1350000);
 struct regulator_init_data msm8064_saw_regulator_pdata_8821_s1 =
-	SAW_VREG_INIT(8821_S1, "8821_s1",       700000, 1300000);
+	SAW_VREG_INIT(8821_S1, "8821_s1",       700000, 1350000);
 
 /* PM8921 regulator constraints */
 struct pm8xxx_regulator_platform_data
diff --git a/arch/arm/mach-msm/clock-8960.c b/arch/arm/mach-msm/clock-8960.c
index 3c66d3ab8846..fdca03c563cb 100644
--- a/arch/arm/mach-msm/clock-8960.c
+++ b/arch/arm/mach-msm/clock-8960.c
@@ -3531,6 +3531,12 @@ static struct clk_freq_tbl clk_tbl_gfx3d[] = {
 	F_GFX3D(320000000, pll2,  2,  5),
 	F_GFX3D(400000000, pll2,  1,  2),
 	F_GFX3D(450000000, pll15, 1,  2),
+	F_GFX3D(477000000, pll15, 1,  2),
+	F_GFX3D(490500000, pll15, 1,  2),
+	F_GFX3D(504000000, pll15, 1,  2),
+	F_GFX3D(531000000, pll15, 1,  2),
+	F_GFX3D(558000000, pll15, 1,  2),
+	F_GFX3D(585000000, pll15, 1,  2),
 	F_END
 };
 
@@ -3586,7 +3592,7 @@ static unsigned long fmax_gfx3d_8064ab[VDD_DIG_NUM] = {
 static unsigned long fmax_gfx3d_8064[VDD_DIG_NUM] = {
 	[VDD_DIG_LOW]     = 128000000,
 	[VDD_DIG_NOMINAL] = 325000000,
-	[VDD_DIG_HIGH]    = 400000000
+	[VDD_DIG_HIGH]    = 450000000
 };
 
 static unsigned long fmax_gfx3d_8930[VDD_DIG_NUM] = {
@@ -3646,7 +3652,7 @@ static struct rcg_clk gfx3d_clk = {
 		.dbg_name = "gfx3d_clk",
 		.ops = &clk_ops_rcg,
 		VDD_DIG_FMAX_MAP3(LOW,  128000000, NOMINAL, 300000000,
-				  HIGH, 400000000),
+				  HIGH, 533333000),
 		CLK_INIT(gfx3d_clk.c),
 		.depends = &gmem_axi_clk.c,
 	},
@@ -6335,7 +6341,7 @@ static struct pll_config pll4_config_393 __initdata = {
 	.main_output_mask = BIT(23),
 };
 
-static struct pll_config_regs pll15_regs __initdata = {
+static struct pll_config_regs pll15_regs = {
 	.l_reg = MM_PLL3_L_VAL_REG,
 	.m_reg = MM_PLL3_M_VAL_REG,
 	.n_reg = MM_PLL3_N_VAL_REG,
@@ -6343,10 +6349,10 @@ static struct pll_config_regs pll15_regs __initdata = {
 	.mode_reg = MM_PLL3_MODE_REG,
 };
 
-static struct pll_config pll15_config __initdata = {
-	.l = (0x24 | BVAL(31, 7, 0x620)),
+static struct pll_config pll15_config = {
+	.l = (0x21 | BVAL(31, 7, 0x620)),
 	.m = 0x1,
-	.n = 0x9,
+	.n = 0x3,
 	.vco_val = BVAL(17, 16, 0x2),
 	.vco_mask = BM(17, 16),
 	.pre_div_val = 0x0,
@@ -6600,6 +6606,19 @@ static void __init reg_init(void)
 	}
 }
 
+//GPU_OC
+
+extern void configure_pllOC(struct pll_config *config, struct pll_config_regs *regs, u32 ena_fsm_mode);
+
+void __ref SetGPUpll_config(u32 loc, unsigned long freq)
+{
+	pll15_config.l = (loc | BVAL(31, 7, 0x620));
+	pll15_config.m = 0x1;
+	pll15_config.n = 0x3;
+	configure_pllOC(&pll15_config, &pll15_regs, 0);
+	printk("ElementalX: set GPU OC %ld", freq / 1000000);
+}
+
 struct clock_init_data msm8960_clock_init_data __initdata;
 static void __init msm8960_clock_pre_init(void)
 {
diff --git a/arch/arm/mach-msm/clock-pll.c b/arch/arm/mach-msm/clock-pll.c
index aeb1c5ed0c70..931df11db46d 100644
--- a/arch/arm/mach-msm/clock-pll.c
+++ b/arch/arm/mach-msm/clock-pll.c
@@ -501,6 +501,42 @@ void __init __configure_pll(struct pll_config *config,
 	writel_relaxed(regval, PLL_CONFIG_REG(regs));
 }
 
+//GPU_OC
+void configure_pllOC(struct pll_config *config,
+    struct pll_config_regs *regs, u32 ena_fsm_mode)
+{
+  u32 regval;
+
+  writel_relaxed(config->l, PLL_L_REG(regs));
+  writel_relaxed(config->m, PLL_M_REG(regs));
+  writel_relaxed(config->n, PLL_N_REG(regs));
+
+  regval = readl_relaxed(PLL_CONFIG_REG(regs));
+
+  /* Enable the MN accumulator  */
+  if (config->mn_ena_mask) {
+    regval &= ~config->mn_ena_mask;
+    regval |= config->mn_ena_val;
+  }
+
+  /* Enable the main output */
+  if (config->main_output_mask) {
+    regval &= ~config->main_output_mask;
+    regval |= config->main_output_val;
+  }
+
+  /* Set pre-divider and post-divider values */
+  regval &= ~config->pre_div_mask;
+  regval |= config->pre_div_val;
+  regval &= ~config->post_div_mask;
+  regval |= config->post_div_val;
+
+  /* Select VCO setting */
+  regval &= ~config->vco_mask;
+  regval |= config->vco_val;
+  writel_relaxed(regval, PLL_CONFIG_REG(regs));
+} 
+
 void __init configure_sr_pll(struct pll_config *config,
 		struct pll_config_regs *regs, u32 ena_fsm_mode)
 {
diff --git a/arch/arm/mach-msm/include/mach/kgsl.h b/arch/arm/mach-msm/include/mach/kgsl.h
index 2d7e8df5d563..fc9ab5e9ed35 100644
--- a/arch/arm/mach-msm/include/mach/kgsl.h
+++ b/arch/arm/mach-msm/include/mach/kgsl.h
@@ -41,6 +41,8 @@
 	 (((_mi) & 0xFF) << 8) | \
 	 ((_pa) & 0xFF))
 
+extern uint32_t max_gpu;
+
 enum kgsl_iommu_context_id {
 	KGSL_IOMMU_CONTEXT_USER = 0,
 	KGSL_IOMMU_CONTEXT_PRIV = 1,
diff --git a/arch/arm/mach-msm/msm_dcvs.c b/arch/arm/mach-msm/msm_dcvs.c
index 9e0be6395978..0d6389a1c4e2 100644
--- a/arch/arm/mach-msm/msm_dcvs.c
+++ b/arch/arm/mach-msm/msm_dcvs.c
@@ -146,7 +146,7 @@ static struct dcvs_core core_list[CORES_MAX];
 
 static struct kobject *cores_kobj;
 
-#define DCVS_MAX_NUM_FREQS 15
+#define DCVS_MAX_NUM_FREQS 23
 static struct msm_dcvs_freq_entry cpu_freq_tbl[DCVS_MAX_NUM_FREQS];
 static unsigned num_cpu_freqs;
 static struct msm_dcvs_platform_data *dcvs_pdata;
diff --git a/drivers/gpu/msm/kgsl_pwrctrl.c b/drivers/gpu/msm/kgsl_pwrctrl.c
index e7eaa93b12ae..a876e3a9bcce 100644
--- a/drivers/gpu/msm/kgsl_pwrctrl.c
+++ b/drivers/gpu/msm/kgsl_pwrctrl.c
@@ -26,6 +26,8 @@
 #include "kgsl_trace.h"
 #include "kgsl_sharedmem.h"
 
+#include <mach/kgsl.h>
+
 #define KGSL_PWRFLAGS_POWER_ON 0
 #define KGSL_PWRFLAGS_CLK_ON   1
 #define KGSL_PWRFLAGS_AXI_ON   2
@@ -44,6 +46,8 @@
 #define INIT_UDELAY		200
 #define MAX_UDELAY		2000
 
+unsigned long internal_max = 450000000;
+
 struct clk_pair {
 	const char *name;
 	uint map;
@@ -391,6 +395,8 @@ static int _get_nearest_pwrlevel(struct kgsl_pwrctrl *pwr, unsigned int clock)
 	return -ERANGE;
 }
 
+extern void SetGPUpll_config(u32 loc, unsigned long freq);
+
 static int kgsl_pwrctrl_max_gpuclk_store(struct device *dev,
 					 struct device_attribute *attr,
 					 const char *buf, size_t count)
@@ -409,6 +415,34 @@ static int kgsl_pwrctrl_max_gpuclk_store(struct device *dev,
 	if (ret != 1)
 		return count;
 
+	if (max_gpu) {
+
+		if (val == 450000000) {
+			SetGPUpll_config(0x21, val);
+		}
+		else if (val == 477000000) {
+			SetGPUpll_config(0x23, val);
+		}
+		else if (val == 490500000) {
+			SetGPUpll_config(0x24, val);
+		}
+		else if (val == 504000000) {
+			SetGPUpll_config(0x25, val);
+		}
+		else if (val == 531000000) {
+			SetGPUpll_config(0x27, val);
+		}
+		else if (val == 558000000) {
+			SetGPUpll_config(0x29, val);
+		}
+		else if (val == 585000000) {
+			SetGPUpll_config(0x2B, val);
+		}
+	
+		internal_max = val;
+
+	}
+	
 	mutex_lock(&device->mutex);
 	level = _get_nearest_pwrlevel(pwr, val);
 	if (level < 0)
@@ -439,8 +473,13 @@ static int kgsl_pwrctrl_max_gpuclk_show(struct device *dev,
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-	return snprintf(buf, PAGE_SIZE, "%d\n",
-			pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
+
+	if (max_gpu)
+		return snprintf(buf, PAGE_SIZE, "%ld\n",
+				internal_max);
+	else
+		return snprintf(buf, PAGE_SIZE, "%d\n",
+				pwr->pwrlevels[pwr->thermal_pwrlevel].gpu_freq);
 }
 
 static int kgsl_pwrctrl_gpuclk_store(struct device *dev,
@@ -479,8 +518,12 @@ static int kgsl_pwrctrl_gpuclk_show(struct device *dev,
 	if (device == NULL)
 		return 0;
 	pwr = &device->pwrctrl;
-	return snprintf(buf, PAGE_SIZE, "%d\n",
+	if (pwr->active_pwrlevel != 0 || !max_gpu)
+		return snprintf(buf, PAGE_SIZE, "%d\n",
 			pwr->pwrlevels[pwr->active_pwrlevel].gpu_freq);
+	else
+		return snprintf(buf, PAGE_SIZE, "%ld\n",
+			internal_max);
 }
 
 static int kgsl_pwrctrl_idle_timer_store(struct device *dev,
@@ -626,8 +669,19 @@ static int kgsl_pwrctrl_gpu_available_frequencies_show(
 		return 0;
 	pwr = &device->pwrctrl;
 	for (index = 0; index < pwr->num_pwrlevels - 1; index++)
-		num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",
-		pwr->pwrlevels[index].gpu_freq);
+
+		if (index == 0 && max_gpu)
+		{
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",585000000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",558000000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",531000000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",504000000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",490500000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",477000000);
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",450000000);
+		}
+		else
+			num_chars += snprintf(buf + num_chars, PAGE_SIZE, "%d ",pwr->pwrlevels[index].gpu_freq);
 	buf[num_chars++] = '\n';
 	return num_chars;
 }
diff --git a/drivers/gpu/msm/kgsl_pwrscale_trustzone.c b/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
index 62b673d5edb6..c0a790c74d70 100644
--- a/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
+++ b/drivers/gpu/msm/kgsl_pwrscale_trustzone.c
@@ -295,7 +295,7 @@ static void tz_sleep(struct kgsl_device *device,
 {
 	struct tz_priv *priv = pwrscale->priv;
 
-	__secure_tz_entry2(TZ_RESET_ID, 0, 0);
+	kgsl_pwrctrl_pwrlevel_change(device, 3);
 	priv->bin.total_time = 0;
 	priv->bin.busy_time = 0;
 }
